{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Template": {
		"prefix": "tmp",
		"body": [	
			"#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pl = pair<ll, ll>;\n#define vt vector\n#define f first\n#define s second\n#define all(x) x.begin(), x.end() \n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); i--)\n#define F0R(i, b) FOR (i, 0, b)\n#define endl '\\n'\nconst ll INF = 1e18;\n\ntemplate<template<typename> class Container, typename T>\nostream& operator<<(ostream& os, Container<T> o) {\n    os << \"{\"; \n    int g = o.size(); \n    for (auto i : o) os << i << ((--g) == 0 ? \"\" : \", \"); \n    os << \"}\";\n    return os;\n}\n\nvoid _print() {\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, typename ...V>\nvoid _print(T t, V... v) {\n    cerr << t; if (sizeof...(v)) cerr << \", \"; _print(v...);\n}\n\n#ifdef LOCAL\n#define dbg(x...) cerr <<__func__ << \":\" <<__LINE__ << \" \" << #x << \" = \"; _print(x);\n#else\n#define dbg(x...)\n#endif\n\nmain() {\n    cin.tie(0)->sync_with_stdio(0);\n    \n    $0\n}"
		]	
	},
	"Codeforces": {
		"prefix": "codeforces",
		"body": [
			"#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pl = pair<ll, ll>;\n#define vt vector\n#define f first\n#define s second\n#define all(x) x.begin(), x.end() \n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); i--)\n#define F0R(i, b) FOR (i, 0, b)\n#define endl '\\n'\nconst ll INF = 1e18;\n\ntemplate<template<typename> class Container, typename T>\nostream& operator<<(ostream& os, Container<T> o) {\n    os << \"{\"; \n    int g = o.size(); \n    for (auto i : o) os << i << ((--g) == 0 ? \"\" : \", \"); \n    os << \"}\";\n    return os;\n}\n\nvoid _print() {\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, typename ...V>\nvoid _print(T t, V... v) {\n    cerr << t; if (sizeof...(v)) cerr << \", \"; _print(v...);\n}\n\n#ifdef LOCAL\n#define dbg(x...) cerr <<__func__ << \":\" <<__LINE__ << \" \" << #x << \" = \"; _print(x);\n#else\n#define dbg(x...)\n#endif\n\nvoid solve(int case_number) {\n    $0\n}\n\nmain() {\n    cin.tie(0)->sync_with_stdio(0);\n    \n    int tests; cin >> tests;\n    FOR (i, 1, tests + 1) {\n        solve(i);\n    }\n}"
		]
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"template<class T> struct SegTree {\n    T ID;\n    int n; \n    vt<T> seg;\n    void init(int _n, T _ID) {\n        ID = _ID;\n        for (n = 1; n < _n; n *= 2);\n        seg.assign(2 * n, ID);\n    }\n    void upd(int i, T val) {\n        seg[i += n] = val;\n        while (i /= 2) seg[i] = seg[2 * i] + seg[2 * i + 1];\n    }\n    T query(int l, int r) { \n        T a = ID, b = ID;\n        for (l += n, r += n + 1; l < r; l /= 2, r /= 2) {\n            if (l & 1) a = a + seg[l++];\n            if (r & 1) b = seg[--r] + b;\n        }\n        return a + b;\n    }\n    T& operator[](int i) {\n        return seg[i + n];\n    }\n};"
		]
	},
	"Lazy Segment Tree": {
		"prefix": "lazyseg",
		"body": [
			"struct Lazy {\n    ll v;\n    bool inc;\n    void operator+=(const Lazy &b) {\n        if (b.inc) v += b.v;\n        else v = b.v, inc = false;\n    }\n};\n \nstruct Node {\n    ll mx, sum;\n    Node operator+(const Node &b) {\n        return {max(mx, b.mx), sum + b.sum};\n    }\n    void upd(const Lazy &u, int l, int r) {\n        if (!u.inc) mx = sum = 0;\n        mx += u.v, sum += u.v * (r - l + 1);\n    }\n};\n\nconst Lazy LID = {0, true};\nconst Node NID = {-INF, 0};\n \nconst int sz = 1 << 17;\nstruct LazySeg { \n    vt<Node> seg;\n    vt<Lazy> lazy;\n    void init() {\n        seg.resize(2 * sz, NID);\n        lazy.resize(2 * sz, LID);\n    }\n    void pull(int i) {\n        seg[i] = seg[2 * i] + seg[2 * i + 1];\n    }\n    void push(int i, int l, int r) {\n        seg[i].upd(lazy[i], l, r);\n        if (l != r) F0R (j, 2) lazy[2 * i + j] += lazy[i];\n        lazy[i] = LID;\n    }\n    void build() {\n        for (int i = sz - 1; i > 0; i--) pull(i);\n    }\n    void upd(int lo, int hi, Lazy val, int i = 1, int l = 0, int r = sz - 1) {\n        push(i, l, r);\n        if (r < lo || l > hi) return;\n        if (lo <= l && r <= hi) {\n            lazy[i] += val;\n            push(i, l, r);\n            return;\n        }\n        int m = (l + r) / 2;\n        upd(lo, hi, val, 2 * i, l, m);\n        upd(lo, hi, val, 2 * i + 1, m + 1, r);\n        pull(i);\n    }\n    Node query(int lo = 0, int hi = sz - 1, int i = 1, int l = 0, int r = sz - 1) {\n        push(i, l, r);\n        if (r < lo || l > hi) return NID;\n        if (lo <= l && r <= hi) return seg[i];\n        int m = (l + r) / 2;\n        return query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m + 1, r);\n    }\n    Node& operator[](int i) {\n        return seg[i + sz];\n    }\n};"
		]
	},
	"Lazy Create Segment Tree": {
		"prefix": "lazycreateseg",
		"body": [
			"const int inf = 1e9;\nusing ptr = struct Node*;\nconst int sz = 1 << 30;\nstruct Node {\n    int val;\n    ptr lc, rc;\n\n    ptr get(ptr& p) { return p ? p : p = new Node {inf}; }\n\n    int query(int lo, int hi, int l = 0, int r = sz - 1) {\n        if (lo > r || hi < l) return inf;\n        if (lo <= l && r <= hi) return val;\n        int m = (l + r) / 2;\n        return min(get(lc)->query(lo, hi, l, m), get(rc)->query(lo, hi, m + 1, r));\n    }\n\n    int upd(int i, int nval, int l = 0, int r = sz - 1) {\n        if (l == r) return val = nval;\n        int m = (l + r) / 2;\n        if (i <= m) get(lc)->upd(i, nval, l, m);\n        else get(rc)->upd(i, nval, m + 1, r);\n        return val = min(get(lc)->val, get(rc)->val);\n    }\n};"
		]
	},
	"Persistent Segment Tree": {
		"prefix": "psegtree",
		"body": [
			"using ptr = struct Node*;\nconst int sz = 1 << 18;\n \nstruct Node {\n    int v;\n    ptr lc, rc;\n \n    ptr pull(ptr lc, ptr rc) {\n        return new Node {min(lc->v, rc->v), lc, rc};\n    }\n \n    ptr upd(int i, int nv, int l = 0, int r = sz - 1) {\n        if (l == r) return new Node {nv};\n        int m = (l + r) / 2;\n        if (i <= m) return pull(lc->upd(i, nv, l, m), rc);\n        else return pull(lc, rc->upd(i, nv, m + 1, r));\n    }\n \n    int query(int lo, int hi, int l = 0, int r = sz - 1) {\n        if (lo > r || hi < l) return 1e9;\n        if (lo <= l && r <= hi) return v;\n        int m = (l + r) / 2;\n        return min(lc->query(lo, hi, l, m), rc->query(lo, hi, m + 1, r)); \n    }\n};"
		]
	},
	"Sparse Table": {
		"prefix": "sparsetable",
		"body": [
			"template<class T> struct RMQ {\n    vt<vt<T>> dp;\n    void init(const vt<T>& v) {\n        dp.resize(32 - __builtin_clz(v.size()), vt<T>(v.size()));\n        copy(all(v), begin(dp[0]));\n        for (int j = 1; 1 << j <= v.size(); ++j) {\n            F0R (i, v.size() - (1 << j) + 1) dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);\n        }\n    }\n    T query(int l, int r) {\n        int d = 31 - __builtin_clz(r - l + 1);\n        return min(dp[d][l], dp[d][r - (1 << d) + 1]); \n    }\n};"
		]
	},
	"Disjoint Sparse Table": {
		"prefix": "disjointsparsetable",
		"body": [
			"template<class T> struct RangeQuery {\n    ll n, sz;\n    T id; // identity element\n    vt<vt<T>> stor;\n    vt<T> a; // put values in here\n    T comb (T a, T b) { return a + b; } // any associative operation\n    void fill(int l, int r, int ind) {\n        if (ind < 0) return;\n        int m = (l + r) / 2;\n        T prod = id; \n        for (int i = m - 1; i >= l; i--) stor[i][ind] = prod = comb(a[i], prod);\n        prod = id; \n        FOR (i, m, r) stor[i][ind] = prod = comb(prod, a[i]);\n        fill(l,m,ind-1); \n        fill(m,r,ind-1);\n    }\n    void init(int _sz, T _id) {\n        n = 1, id = _id;\n        while ((1 << n) < _sz) n++;\n        sz = 1 << n;\n        a.resize(sz);\n        stor.resize(sz, vt<T>(32 - __builtin_clz(sz)));\n    }\n    void build() {\n        fill(0, sz, n - 1);\n    }\n    T query(int l, int r) {\n        if (l == r) return a[l];\n        int t = 31 - __builtin_clz(r ^ l);\n        return comb(stor[l][t], stor[r][t]);\n    }\n};"
		]
	},
	"Treap": {
		"prefix": "treap",
		"body": [
			"using K = ll; // key type\nrandom_device rd;\nmt19937 mt(rd());\n\nll ID = INF;\nll cmb(ll a, ll b) {\n    return min(a, b);\n}\n\nusing ptr = struct Node*;\nstruct Node {\n\tK key;\n\tint pri;\n    ptr l, r;\n\tint sz; \n\n\t// custom\n\tll val;\n\tll agg;\n\n\tNode(K _key, ll _val) {\n        pri = mt(); \n        sz = 1; \n        l = r = nullptr;\n        val = agg = _val;\n        key = _key;\n\t}\n\n\t~Node() { \n        delete l;\n        delete r;\n\t}\n};\n\nint sz(ptr n) { return n ? n->sz : 0; }\nll val(ptr n) { return n ? n->val : ID; }\nll agg(ptr n) { return n ? n->agg : ID; }\n\nptr pull(ptr n) {\n    ptr a = n->l, b = n->r;\n    n->sz = sz(a) + 1 + sz(b);\n    n->agg = cmb(agg(a), cmb(n->val, agg(b)));\n    return n;\n}\n\npair<ptr, ptr> split(ptr n, K k) { // splits before k\n\tif (!n) return {n, n};\n    if (k <= n->key) {\n        auto [l, r] = split(n->l, k); \n        n->l = r;\n        return {l, pull(n)};\n\t} else {\n\t\tauto [l, r] = split(n->r, k); \n    \tn->r = l;\n\t\treturn {pull(n), r};\n\t}\n}\n\npair<ptr, ptr> spliti(ptr n, int i) { // splits before i\n\tif (!n) return {n, n};\n    if (i <= sz(n->l)) {\n        auto [l, r] = spliti(n->l, i); \n        n->l = r;\n        return {l, pull(n)};\n    } else {\n\t\tauto [l, r] = spliti(n->r, i - sz(n->l) - 1); \n        n->r = l;\n\t\treturn {pull(n), r};\n\t}\n}\n\nptr merge(ptr l, ptr r) { //  keys in l < keys in r\n\tif (!l || !r) return l ? l : r;\n\tptr t;\n\tif (l->pri > r->pri) l->r = merge(l->r, r), t = l;\n\telse r->l = merge(l, r->l), t = r;\n\treturn pull(t);\n}\n\nptr ins(ptr n, K k, ll val) { // insert k \n\tauto [l, r] = split(n, k);\n\treturn merge(l, merge(new Node(k, val), r));\n}\n\nptr insi(ptr n, int i, K k, ll val) { // insert before i\t\n\tauto [l, r] = spliti(n, i);\n\treturn merge(l, merge(new Node(k, val), r));\n}\n\nptr del(ptr n, K k) { // delete k \n\tauto a = split(n, k), b = spliti(a.s, 1);\n\treturn merge(a.f, b.s);\n}\n\nptr deli(ptr n, int i) {\n\tauto b = spliti(n, i + 1), a = spliti(b.f, i);\n\treturn merge(a.f, b.s);\n}\n\nptr find(ptr n, K k) {\n\tif (!n || n->key == k) return n;\n\tif (n->key < k) return find(n->l, k);\n\telse return find(n->r, k);\n}\n\nptr findi(ptr n, int i) {\n    if (!n || n->sz == i) return n;\n    if (i < sz(n->l)) return find(n->l, i);\n    else return find(n->r, i - sz(n->l) - 1);\n}\n\nll query(ptr &n, K lo, K hi) {\n\tauto [lm, r] = split(n, hi + 1); // only works for integer key types \n\tauto [l, m] = split(lm, lo);\n\tll res = agg(m);\n\tn = merge(l, merge(m, r));\n\treturn res;\n}\n\nll queryi(ptr &n, int lo, int hi) {\n    auto [lm, r] = spliti(n, hi + 1);\n    auto [l, m] = spliti(lm, lo);\n    ll res = agg(m);\n    n = merge(l, merge(m, r));\n    return res;\n}\n\nvoid upd(ptr& n, K k, ll nv) { // assumes no duplicate keys\n    auto [l, mr] = split(n, k);\n    auto [m, r] = split(mr, k + 1);\n    if (m) m->val = m->agg = nv;\n    else m = new Node(k, nv);\n    n = merge(l, merge(m, r));\n}\n\nvoid updi(ptr& n, int i, ll nv) {\n    auto [l, mr] = spliti(n, i);\n    auto [m, r] = spliti(n, 1);\n    assert(m);\n    m->val = m->agg = nv;\n    n = merge(l, merge(m, r));\n}\n\nint mn(ptr n) {\n    if (n->l) return mn(n->l);\n    else return n->key;\n}\n\nptr unite(ptr l, ptr r) {\n    if (!l || !r) return l ? l : r;\n    // l has the smallest key\n    if (mn(l) > mn(r)) swap(l, r);\n    ptr res = 0;\n    while (r) {\n        auto [lt, rt] = split(l, mn(r) + 1);\n        res = merge(res, lt);\n        tie(l, r) = make_pair(r, rt);\n    }   \n    return merge(res, l);\n}\n\nvoid heapify(ptr n) {\n\tif (!n) return;\n\tptr mx = n;\n\tif (n->l && n->l->pri > mx->pri) mx = n->l;\n\tif (n->r && n->r->pri > mx->pri) mx = n->r;\n\tif (mx != n) swap(n->pri, mx->pri), heapify(mx);\n}\n\nptr build(int l, int r, vt<ptr>& ns) {\n\tif (l > r) return nullptr;\n\tif (l == r) return ns[l];\n\tint m = (r + l) / 2;\n\tns[m]->l = build(l, m - 1, ns);\n\tns[m]->r = build(m + 1, r, ns);\n\theapify(ns[m]);\n\treturn pull(ns[m]);\n}\n\nNode* tree;"
		]
	},
	"Lazy Treap": {
		"prefix": "lazytreap",
		"body": [
			"using K = ll;\nrandom_device rd;\nmt19937 mt(rd());\n\nstruct Lazy {\n    bool rev;\n    ll v;\n    bool inc;\n    void operator+=(const Lazy &b) {\n        if (b.inc) v += b.v;\n        else v = b.v, inc = false;\n        rev ^= b.rev;\n    }\n};\n\nstruct Value {\n    ll mx, sum;\n    void upd(const Lazy &b, int sz) {\n        if (!b.inc) mx = sum = 0;\n        mx += b.v, sum += b.v * sz;\n    }\n    Value operator+(const Value &b) const {\n        return {max(mx, b.mx), sum + b.sum};\n    }\n};\n\nconst Lazy LID = {false, 0, true};\nconst Value VID = {0, 0};\n\nusing ptr = struct Node*;\n\nstruct Node {\n    int pri;\n    K key;\n    ptr l, r;\n    int sz;\n\n    Value val, agg;\n    Lazy lazy;\n\n    Node(K _key, Value _val) {\n        sz = 1;\n        pri = mt();\n        key = _key;\n        l = r = 0;\n        val = agg = _val;\n        lazy = LID;\n    }\n\n    ~Node() {\n        delete l;\n        delete r;\n    }\n};\n\nint sz(ptr n) { return n ? n->sz : 0; }\nValue val(ptr n) { return n ? n->val : VID; }\nValue agg(ptr n) { return n ? n->agg : VID; }\n\nptr push(ptr n) {\n    if (!n) return n;\n    if (n->lazy.rev) swap(n->l, n->r);\n    ptr l = n->l, r = n->r;\n    n->val.upd(n->lazy, 1);\n    n->agg.upd(n->lazy, n->sz);\n    if (l) n->l->lazy += n->lazy;\n    if (r) n->r->lazy += n->lazy;\n    n->lazy = LID;\n    return n;\n}\n\nptr pull(ptr n) {\n    ptr l = n->l, r = n->r;\n    push(l), push(r);\n    n->sz = sz(l) + 1 + sz(r);\n    n->agg = agg(l) + n->val + agg(r);\n    return n;\n}\n\npair<ptr, ptr> split(ptr n, K k) {\n    if (!n) return {n, n};\n    push(n);\n    if (k <= n->key) {\n        auto [l, r] = split(n->l, k);\n        n->l = r;\n        return {l, pull(n)};\n    } else {\n        auto [l, r] = split(n->r, k);\n        n->r = l;\n        return {pull(n), r};\n    }\n}\n\npair<ptr, ptr> spliti(ptr n, int i) {\n    if (!n) return {n, n};\n    push(n);\n    if (i <= sz(n->l)) {\n        auto [l, r] = spliti(n->l, i);\n        n->l = r;\n        return {l, pull(n)};\n    } else {\n        auto [l, r] = spliti(n->r, i - sz(n->l) - 1);\n        n->r = l;\n        return {pull(n), r};\n    }\n}\n\nptr merge(ptr l, ptr r) {\n    if (!l || !r) return l ? l : r;\n    push(l), push(r);\n    ptr t;\n    if (l->pri > r->pri) l->r = merge(l->r, r), t = l;\n    else r->l = merge(l, r->l), t = r; \n    return pull(t);\n}\n\nptr ins(ptr n, K k, Value val) { // insert k \n\tauto [l, r] = split(n, k);\n\treturn merge(l, merge(new Node(k, val), r));\n}\n\nptr insi(ptr n, int i, K k, Value val) { // insert before i\t\n\tauto [l, r] = spliti(n, i);\n\treturn merge(l, merge(new Node(k, val), r));\n}\n\nptr del(ptr n, K k) { // delete k \n\tauto a = split(n, k), b = spliti(a.s, 1);\n\treturn merge(a.f, b.s);\n}\n\nptr deli(ptr n, int i) {\n\tauto b = spliti(n, i + 1), a = spliti(b.f, i);\n\treturn merge(a.f, b.s);\n}\n\nptr find(ptr n, K k) {\n\tpush(n);\t\n\tif (!n || n->key == k) return n;\n\tif (k < n->key) return find(n->l, k);\n\telse return find(n->r, k);\n}\n\nptr findi(ptr n, int i) {\n\tpush(n);\n\tif (!n || i == sz(n->l)) return n;\n\tif (i < sz(n->l)) return find(n->l, i);\n\telse return find(n->r, i);\n}\n\nptr upd(ptr n, K lo, K hi, Lazy nv) {\n\tif (lo > hi) return n;\n\tauto [lhs, r] = split(n, hi + 1);\n\tauto [l, m] = split(lhs, lo);\n\tm->lazy += nv;\n\treturn merge(l, merge(m, r));\n}\n\nptr updi(ptr n, int lo, int hi, Lazy nv) {\n\tif (lo > hi) return n;\n\tauto [lm, r] = spliti(n, hi + 1);\n\tauto [l, m] = spliti(lm, lo);\n\tm->lazy += nv;\n\treturn merge(l, merge(m, r));\n}\n\nValue query(ptr &n, K lo, K hi)  {\n\tauto [lm, r] = split(n, hi + 1);\n\tauto [l, m] = split(lm, lo);\n\tValue res = agg(m);\n\tn = merge(l, merge(m, r));\n\treturn res;\n}\n\nValue queryi(ptr &n, int lo, int hi) {\n\tauto [lm, r] = spliti(n, hi + 1);\n\tauto [l, m] = spliti(lm, lo);\n\tValue res = agg(m);\n\tn = merge(l, merge(m, r));\n\treturn res;\n}\n\nint mn(ptr n) {\n    assert(n);\n    push(n);\n    if (n->l) return mn(n->l);\n    else return n->key;\n}\n\nptr unite(ptr l, ptr r) {\n    if (!l || !r) return l ? l : r;\n    // l has the smallest key\n    if (mn(l) > mn(r)) swap(l, r);\n    ptr res = 0;\n    while (r) {\n        auto [lt, rt] = split(l, mn(r) + 1);\n        res = merge(res, lt);\n        tie(l, r) = make_pair(r, rt);\n    }   \n    return merge(res, l);\n}\n\nvoid heapify(ptr n) {\n\tif (!n) return;\n\tptr mx = n;\n\tif (n->l && n->l->pri > mx->pri) mx = n->l;\n\tif (n->r && n->r->pri > mx->pri) mx = n->r;\n\tif (mx != n) swap(n->pri, mx->pri), heapify(mx);\n}\n\nptr build(int l, int r, vt<ptr>& ns) {\n\tif (l > r) return nullptr;\n\tif (l == r) return ns[l];\n\tint m = (r + l) / 2;\n\tns[m]->l = build(l, m - 1, ns);\n\tns[m]->r = build(m + 1, r, ns);\n\theapify(ns[m]);\n\treturn pull(ns[m]);\n}\n\nNode* tree;"
		]
	},
	"Li Chao Tree": {
		"prefix": "lichao",
		"body": [
			"struct Line {\n    ll m, c; \n    ll operator()(ll x) {\n        return m * x + c;\n    }\n};\n\nconst ll sz = 1ll << 30;\n\nusing ptr = struct Node*;\nstruct Node {\n    ptr lc, rc; \n    Line line;\n\n    Node(Line _line) {\n        line = _line;\n        lc = rc = 0;\n    }\n};\n\n// min tree (flip signs for max)\nptr add(ptr& n, Line loser, ll l = 0, ll r = sz - 1) {\n    if (!n) return n = new Node(loser);\n    ll m = (l + r) / 2;\n    if (loser(m) < n->line(m)) swap(loser, n->line);\n    if (loser(l) < n->line(l)) return add(n->lc, loser, l, m);\n    else return add(n->rc, loser, m + 1, r);\n}\n\nll query(ptr n, ll x, ll l = 0, ll r = sz - 1) {\n    if (!n) return sz;\n    ll m = (l + r) / 2;\n    if (x <= m) return min(n->line(x), query(n->lc, x, l, m));\n    else return min(n->line(x), query(n->rc, x, m + 1, r));\n}"
		]
	},
	"Modular Power": {
		"prefix": "modpow",
		"body": [
			"ll power(ll x, ll y) { // make y unsigned long long if large numbers\n    ll res = 1;\n    x %= MOD;\n    while (y) {\n        if (y & 1) res = (res * x) % MOD;\n        y >>= 1;\n        x = (x * x) % MOD;\n    }\n    return res;\n}"
		]
	},
	"Floyd-Warshall": {
		"prefix": "apsp",
		"body": [
			"// for validated input (no neg cycles, etc, m[i][i] = 0)\nvoid apsp(vt<vt<ll>>& m) {\n    F0R(k, n) F0R(i, n) F0R(j, n) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n}"
		]
	},
	"SCC": {
		"prefix": "scc",
		"body": [
			"struct SCC {\n\tll N; \n\tvt<vt<ll>> adj, radj;\n\tvt<ll> todo, comp, comps; \n\tvt<bool> seen;\n\tvoid init(ll _N) { \n\t  N = _N; \n\t\tadj.resize(N), radj.resize(N);\n    comp = vt<ll>(N,-1);\n    seen.resize(N); \n  }\n\tvoid ae(ll x, ll y) { adj[x].pb(y), radj[y].pb(x); }\n\tvoid dfs(ll x) {\n\t\tseen[x] = 1; \n\t  for(ll y : adj[x]) if (!seen[y]) dfs(y);\n\t\ttodo.pb(x); \n\t}\n\tvoid dfs2(ll x, ll v) {\n\t\tcomp[x] = v; \n\t\tfor (ll y : radj[x]) if (comp[y] == -1) dfs2(y, v); \n\t}\n\tvoid gen() {\n\t\tF0R (i, N) if (!seen[i]) dfs(i);\n\t\treverse(all(todo)); \n\t\tfor (ll x : todo) if (comp[x] == -1) dfs2(x, x), comps.pb(x);\n\t}\n};"
		]
	},
	"Max Flow (Dinic)": {
		"prefix": "dinic",
		"body": [
			"struct Dinic {\n    struct Edge {\n        int to; \n        ll flo, cap; \n    };\n    int N; \n    vt<Edge> eds; \n    vt<vt<int>> adj;\n    void init(int _N) {\n        N = _N; \n        adj.resize(N), cur.resize(N); \n    }\n    void ae(int u, int v, ll cap, ll rcap = 0) { \n        assert(min(cap, rcap) >= 0); \n        adj[u].pb(eds.size()); \n        eds.pb({v, 0, cap});\n        adj[v].pb(eds.size()); \n        eds.pb({u, 0, rcap});\n    }\n    vt<int> lev; \n    vt<vt<int>::iterator> cur;\n    bool bfs(int s, int t) {\n        lev = vt<int>(N, -1); \n        F0R(i, N) cur[i] = begin(adj[i]);\n        queue<int> q({s}); \n        lev[s] = 0; \n        while (q.size()) { \n            int u = q.front(); \n            q.pop();\n            for(auto &e : adj[u]) { \n                const Edge& E = eds[e];\n                int v = E.to; \n                if (lev[v] < 0 && E.flo < E.cap) q.push(v), lev[v] = lev[u] + 1;\n            }\n        }\n        return lev[t] >= 0;\n    }\n    ll dfs(int v, int t, ll flo) {\n        if (v == t) return flo;\n        for (; cur[v] != end(adj[v]); cur[v]++) {\n            Edge& E = eds[*cur[v]];\n            if (lev[E.to] != lev[v] + 1 || E.flo == E.cap) continue;\n            ll df = dfs(E.to, t, min(flo, E.cap-E.flo));\n            if (df) { \n                E.flo += df; eds[*cur[v]^1].flo -= df;\n                return df; \n            }       \n        }\n        return 0;\n    }\n    ll maxFlow(int s, int t) {\n        ll tot = 0; \n        while (bfs(s, t)) while (ll df = dfs(s, t, numeric_limits<ll>::max())) tot += df;\n        return tot;\n    }\n};"
		]
	},
	"TSP": {
		"prefix": "tsp",
		"body": [
			"vt<vt<ll>> dp(1 << n, vt<ll>(n, INF));\nvt<vt<ll>> cost(n, vt<ll>(n, INF));\n\n// initialise starting states\nF0R (i, n) {\n\t  dp[1 << i][i] = 0;\n}\n\n// iterative dp\n// correctness is guaranteed, because given any dp state, all previous states will already be \n// evaluated since unflipping any bit will result in a smaller number\nF0R (i, 1 << n) {\n    F0R (j, n) {\n        if (dp[i][j] == INF) continue; // skip infinity\n        F0R (k, n) {\n            if (i & (1 << k)) continue; // skip things already in bitmask\n            dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + cost[j][k]); // push dp values\n        }\n    }\n}\n\n// find minimum of all complete walks\nll ans = INF;\nF0R (i, n) {\n    ans = min(ans, dp[(1 << n) - 1][i]);\n}"
		]
	},
	"LCA RMQ": {
		"prefix": "lcarmq",
		"body": [
			"// include RMQ\nstruct LCA {\n\tint n; \n\tvt<vt<int>> adj;\n\tvt<int> depth, pos, par; // rev is for compress\n\tvt<pl> tmp; \n\tRMQ<pl> r;\n\tvoid init(int _n) { \n    n = _n; \n    adj.resize(n); \n\t\tdepth = pos = par = vt<int>(n); \n\t}\n\tvoid ae(int x, int y) { \n    adj[x].pb(y), adj[y].pb(x); \n\t}\n\tvoid dfs(int x) {\n\t\tpos[x] = tmp.size(); \n    tmp.pb({depth[x], x}); \n\t\tfor(int y : adj[x]) \n\t\t\tif (y != par[x]) {\n\t\t\t\tdepth[y] = depth[par[y] = x] + 1, dfs(y);\n\t\t\t\ttmp.pb({depth[x], x}); \n\t    }\n\t}\n\tvoid gen(int R = 0) { \n    par[R] = R; \n    dfs(R); r.init(tmp); \n\t}\n\tint lca(int u, int v) {\n\t\tu = pos[u], v = pos[v]; \n    if (u > v) swap(u,v);\n\t\treturn r.query(u,v).s;\n\t}\n\tint dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; \n\t}\n};"
		]
	},
	"LCA Binary Lifting": {
		"prefix": "lcabinary",
		"body": [
			"struct LCA {\n    int n; \n    vt<vt<pl>> adj; \n    vt<vt<int>> par;\n    vt<int> depth;\n    vt<ll> tfx; // treefiu sum\n    void init(int _n) {  n = _n;\n        int d = 1; \n        while ((1<<d) < n) ++d;\n        par.assign(d, vt<int>(n)); \n        adj.resize(n);\n        depth.resize(n);\n        tfx.resize(n);\n    }\n    void ae(int u, int v, ll w = 1) { adj[u].pb({v, w}), adj[v].pb({u, w}); }\n    void gen(int R = 0) { par[0][R] = R; dfs(R); }\n    void dfs(int u = 0) {\n        FOR (i, 1, par.size()) par[i][u] = par[i - 1][par[i - 1][u]];\n        for (auto [v, w] : adj[u]) {\n            if (v != par[0][u]) depth[v] = depth[par[0][v] = u] + 1, tfx[v] = tfx[u] + w, dfs(v);\n        }\n    }\n    int jmp(int u, int d) {\n        F0R (i, par.size()) if ((d >> i) & 1) u = par[i][u];\n        return u; \n    }\n    int lca(int u, int v) {\n        if (depth[u] < depth[v]) swap(u, v);\n        u = jmp(u, depth[u] - depth[v]); \n        if (u == v) return u;\n        ROF (i, 0, par.size()) {\n            int u = par[i][u], v = par[i][v];\n            if (u != v) u = u, v = v;\n        }\n        return par[0][u];\n    }\n    int dist(int u, int v) { // # edges on path\n        return depth[u] + depth[v] - 2 * depth[lca(u, v)]; \n    }\n    // onlv if weighted paths\n    ll wdist(int u, int v) { // path sum\n        return tfx[u] + tfx[v] - 2 * tfx[lca(u, v)];\n    }\n};"
		]
	},
	"HLD": {
		"prefix": "hld",
		"body": [
			"struct Lazy {\n    ll v;\n    bool inc;\n    void operator+=(const Lazy &b) {\n        if (b.inc) v += b.v;\n        else v = b.v, inc = false;\n    }\n};\n \nstruct Node {\n    ll mx, sum;\n    Node operator+(const Node &b) {\n        return {max(mx, b.mx), sum + b.sum};\n    }\n    void upd(const Lazy &u, int l, int r) {\n        if (!u.inc) mx = sum = 0;\n        mx += u.v, sum += u.v * (r - l + 1);\n    }\n};\n\nconst Node NID = {0, 0};\nconst Lazy UID = {0, true};\n \ntemplate<class T, class U, int SZ> struct LazySeg { \n    vt<T> seg;\n    vt<U> lazy;\n    void init() {\n        seg.resize(2 * SZ, NID);\n        lazy.resize(2 * SZ, UID);\n    }\n    void pull(int i) {\n        seg[i] = seg[2 * i] + seg[2 * i + 1];\n    }\n    void push(int i, int l, int r) {\n        seg[i].upd(lazy[i], l, r);\n        if (l != r)  F0R (j, 2) lazy[2 * i + j] += lazy[i];\n        lazy[i] = UID;\n    }\n    void build() {\n        for (int i = SZ - 1; i > 0; i--) pull(i);\n    }\n    void upd(int lo, int hi, U val, int i = 1, int l = 0, int r = SZ - 1) {\n        push(i, l, r);\n        if (r < lo || l > hi) return;\n        if (lo <= l && r <= hi) {\n            lazy[i] += val;\n            push(i, l, r);\n            return;\n        }\n        int m = (l + r) / 2;\n        upd(lo, hi, val, 2 * i, l, m);\n        upd(lo, hi, val, 2 * i + 1, m + 1, r);\n        pull(i);\n    }\n    T query(int lo = 0, int hi = SZ - 1, int i = 1, int l = 0, int r = SZ - 1) {\n        push(i, l, r);\n        if (r < lo || l > hi) return NID;\n        if (lo <= l && r <= hi) return seg[i];\n        int m = (l + r) / 2;\n        return query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m + 1, r);\n    }\n    T& operator[](int i) {\n        return seg[i + SZ];\n    }\n};\n\ntemplate<class T, class U, int sz, bool in_edges> struct HLD {\n    vt<int> adj[sz];\n    int par[sz], root[sz], depth[sz], size[sz], pos[sz], time;\n    vt<int> rpos;\n    LazySeg<T, U, sz> tree;\n\n    void ae(int u, int v) {\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    void dfs_sz(int u) {\n        size[u] = 1;\n        for (int& v : adj[u]) {\n            par[v] = u;\n            depth[v] = depth[u] + 1;\n            adj[v].erase(find(all(adj[v]), u));\n            dfs_sz(v);\n            size[u] += size[v];\n            if (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);\n        }\n    }\n    void dfs_hld(int u) {\n        pos[u] = time++;\n        rpos.pb(u);\n        for (int& v : adj[u]) {\n            root[v] = (v == adj[u][0] ? root[u] : v);\n            dfs_hld(v);\n        }\n    }\n    void init(int r = 0) {\n        par[r] = depth[r] = time = 0;\n        dfs_sz(r);\n        root[r] = r;\n        dfs_hld(r);\n        tree.init();\n    }\n    int lca(int u, int v) {\n        while (root[u] != root[v]) {\n            if (depth[root[u]] > depth[root[v]]) swap(u, v);\n            v = par[root[v]];\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    template <class Op>\n    void process(int u, int v, Op op) {\n        while (root[u] != root[v]) {\n            if (depth[root[u]] > depth[root[v]]) swap(u, v);\n            op(pos[root[v]], pos[v]);\n            v = par[root[v] ];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + in_edges, pos[v]);\n    }\n    void modify(int u, int v, U upd) {\n        process(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });\n    }\n    T query(int u, int v) {\n        T res = NID;\n        process(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });\n        return res;\n    }\n    void modify_subtree(int u, U upd) {\n        tree.upd(pos[u] + in_edges, pos[u] + size[u] - 1, upd);\n    }\n    T query_subtree(int u) {\n        return tree.query(pos[u] + in_edges, pos[u] + size[u] - 1);\n    }\n};\n\nll n, k;\nHLD<Node, Lazy, 1 << 16, false> hld;"
		]
	},
	"Basic HLD": {
		"prefix": "basichld",
		"body": [
			"struct SegTree {\n    int n;\n    vt<int> seg;\n    void init(int _n) {\n        for (n = 1; n < _n; n *= 2);\n        seg.resize(2 * n);\n    }\n    int query(int i, int balls) {\n        int sum = 0;\n        for (i += n; i > 0; i /= 2) sum += seg[i];\n        return sum;\n    }\n    void upd(int l, int r, int v) {\n        for (l += n, r += n + 1; l < r; l /= 2, r /= 2) {\n            if (l & 1) seg[l++] += v;\n            if (r & 1) seg[--r] += v;\n        }\n    }\n};\n\ntemplate<bool in_edges> struct HLD {\n    int sz;\n    vt<vt<int>> adj;\n    vt<int> par, root, depth, size, pos;\n    int time;\n    SegTree tree;\n\n    void ae(int u, int v) {\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    void dfs_sz(int u) {\n        size[u] = 1;\n        for (int& v : adj[u]) {\n            par[v] = u;\n            depth[v] = depth[u] + 1;\n            adj[v].erase(find(all(adj[v]), u));\n            dfs_sz(v);\n            size[u] += size[v];\n            if (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);\n        }\n    }\n    void dfs_hld(int u) {\n        pos[u] = time++;\n        for (int& v : adj[u]) {\n            root[v] = (v == adj[u][0] ? root[u] : v);\n            dfs_hld(v);\n        }\n    }\n    void init(int _sz) {\n        sz = _sz;\n        adj.resize(sz);\n        par = root = depth = size = pos = vt<int>(sz);\n    }\n    void gen(int r = 0) {\n        par[r] = depth[r] = time = 0;\n        dfs_sz(r);\n        root[r] = r;\n        dfs_hld(r);\n        tree.init(sz);\n    }\n    int lca(int u, int v) {\n        while (root[u] != root[v]) {\n            if (depth[root[u]] > depth[root[v]]) swap(u, v);\n            v = par[root[v]];\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    template <class Op>\n    void process(int u, int v, Op op) {\n        while (root[u] != root[v]) {\n            if (depth[root[u]] > depth[root[v]]) swap(u, v);\n            op(pos[root[v]], pos[v]);\n            v = par[root[v]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + in_edges, pos[v]);\n    }\n    void modify(int u, int v, ll upd) {\n        process(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });\n    }\n    ll query(int u, int v) {\n        ll res = 0;\n        process(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });\n        return res;\n    }\n};"
		]
	},
	"Random": {
		"prefix": "random",
		"body": [
			"random_device rd;\nmt19937 mt(rd());\nusing uni = uniform_int_distribution<int>;"
		]
	},
	"Math": {
		"prefix": "math",
		"body": [
			"const ll MOD = 1e9+7;\n\nll mul(ll a, ll b) {\n    return a * b % MOD;\n}\n\nll pow(ll base, ll exp = MOD - 2) {\n    ll res = 1, y = base;\n    while (exp) {\n        if (exp & 1) res = mul(res, y);\n        y = mul(y, y);\n        exp >>= 1;\n    }\n    return res;\n}\n\nstruct Math {\n    vt<ll> fact, inv;\n    \n    Math(int n = 1) {\n        fact.resize(n + 1);\n        inv.resize(n + 1);\n        fact[0] = inv[0] = 1;\n        FOR(i, 1, n + 1) fact[i] = mul(fact[i-1], i);\n        inv[n] = pow(fact[n]);\n        ROF (i, 1, n + 1) inv[i-1] = mul(inv[i], i);\n    }\n\n    ll comb(int n, int k) {\n        if (n < k) return 0;\n        return mul(mul(fact[n], inv[k]), inv[n - k]);\n    }\n\n    ll perm(int n, int k) {\n        if (n < k) return 0;\n        return mul(fact[n], inv[n - k]);\n    }\n    \n    ll multi(vector<int> v) {\n        ll res = fact[accumulate(v.begin(), v.end(), 0)];\n        for (int i : v) res = mul(res, inv[i]);\n        return res;\n    }\n\n} math(100005); "
		]
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"struct DSU {\n    vt<int> e; \n    void init(int n) { \n        e.resize(n, -1);\n    }\n    int find(int x) { \n        return e[x] < 0 ? x : e[x] = find(e[x]); \n    }   \n    bool unite(int x, int y) {\n        x = find(x), y = find(y); \n        if (x == y) return 0;\n        if (e[x] > e[y]) swap(x,y);\n        e[x] += e[y]; \n        e[y] = x; \n        return 1;\n    }\n    // optional\n    bool sameSet(int a, int b) { \n        return find(a) == find(b); \n    }\n    int size(int x) { \n        return -e[find(x)]; \n    }\n};"
		]
	},
	"Virtual Tree": {
		"prefix": "virtualtree",
		"body": [
			"vt<pl> virtual_tree(vt<ll>& nodes) { // pairs of {ancestor, child}\n\t\tauto cmp = [&] (ll u, ll v) { return pos[u] < pos[v]; };\n\t\tsort(all(nodes), cmp);\n\t\tint sz = nodes.size();\n\t\tF0R (i, sz - 1) nodes.pb(lca(nodes[i], nodes[i + 1]));\n\t\tsort(all(nodes), cmp);\n\t\tnodes.erase(unique(all(nodes)), nodes.end());\n\t\tvt<pl> res;\n\t\tF0R (i, (int) nodes.size() - 1) res.pb({lca(nodes[i], nodes[i + 1]), nodes[i + 1]});\n\t\treturn res;\n}"
		]
	},
	"Monotonic CHT": {
		"prefix": "moncht",
		"body": [
			"// u can usually just get away with a / b\nll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down\n\nstruct Line {\n    ll m, c;\n \n    ll inter(Line& oth) {\n        return (c - oth.c) / (oth.m - m);\n    }\n \n    ll operator()(ll x) {\n        return x * m + c;\n    }\n};\n \nstruct CHT {\n\t\t// always draw out the hull on paper just to be safe\n    deque<Line> hull;\n \n    // dependent on query\n    // compare new line with first, and first with second\n    void add(Line l) {\n        while (hull.size() >= 2 && hull[0].inter(l) <= hull[1].inter(hull[0])) hull.pop_front();\n        hull.push_front(l);\n    }\n \n    ll query(ll x) {\n        while (hull.size() >= 2 && hull.end()[-1](x) >= hull.end()[-2](x)) hull.pop_back();\n        return hull.back()(x);\n    }\n};"
		]
	},
	"Simulated Annealing": {
		"prefix": "simanneal",
		"body": [
			"#pragma optimize \"Ofast,unroll-all-loops,inline\"\n \n#include <bits/stdc++.h>\n#include <sys/time.h>\n \nusing namespace std;\n \nusing ll = long long;\nusing db = long double;\n#define uid uniform_int_distribution\n#define urd uniform_real_distribution\nusing pl = pair<int, int>;\n#define vt vector\n#define f first\n#define s second\n#define all(x) x.begin(), x.end() \n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); i--)\n#define F0R(i, b) FOR (i, 0, b)\n#define debug(x) do{auto _x = x; cerr << #x << \" = \" << _x << endl;} while(0)\nconst ll INF = 1e18;\n \ndouble get_time() { timeval tv; gettimeofday(&tv, NULL); return tv.tv_sec + tv.tv_usec * 1e-6; }\ndouble start_time;\ndouble elapsed() { return get_time() - start_time; }\n \nrandom_device rd;\nmt19937 mt(rd());\n \nuniform_real_distribution<db> rdist(0, 1);\ninline db next_double() { return rdist(mt); }\n \nint rnd(int lo, int hi) {\n    return mt() % (hi - lo + 1) + lo;\n}\n\n \n// start and end temperatures (dependant on cost function)\ndb t0 = 1;\nconst db tn = 0.0001;\n \nconst db MAX_TIME = 25000;\n\nifstream fin;\nofstream fout;\n \n// stuff\n\n\n// end stuff\n \nstruct State {\n    db value;\n\n    db calc_value() {\n        db tot = 0;\n\n \n        return value = tot;\n    }\n \n    void get_neighbour() { // modify current state into some neighbour state\n\n    }\n \n    void print() {\n        cerr << \"cost: \" << value;\n    }\n \n    db comp(const State& b) { // positive if a < b (b is better than a) \n        return value - b.value;\n    }\n};\n \nState best;\n \nvoid solve(int test_case) {\n\n    cerr << \"\\nsolving test case \" << test_case << endl;\n\n    fin = ifstream(\"/home/caterpillow/cp/orac2/contests/fario/2008/leafin/leaf.\" + to_string(test_case) + \".in\");\n    fout = ofstream(\"/home/caterpillow/cp/orac2/contests/fario/2008/leafout/leaf.\" + to_string(test_case) + \".out\");\n\n    start_time = get_time();\n\n    State cur {};\n\n    // input (and set cur state)\n\n\n\n    // end input\n \n    int its = 0;\n    t0 = 0.001;\n\n    cur.calc_value();\n    best = cur;\n\n    // t0 = cur.value;\n\n    while (true) {\n        its++;\n        db time_passed = elapsed() / MAX_TIME;\n        if (time_passed > 1) break;\n        \n        State neighbour = cur;\n        neighbour.get_neighbour();\n        neighbour.calc_value();\n\n        db temp = t0 * pow(tn / t0, time_passed);\n\n        if (cur.comp(neighbour) >= 0 || next_double() < exp((cur.comp(neighbour)) / temp)) { \n            cur = neighbour;\n        }\n \n        if (best.comp(cur) > 0) {\n            best = cur;\n        }\n    }\n \n    cerr << \"Time elapsed: \" << elapsed() << endl;\n    cerr << \"States checked: \" << its << endl;\n    best.print();\n} \n\nmain() {\n    cin.tie(0)->sync_with_stdio(0);\n\n    vt<int> cases = {3, 4, 5, 9, 10};\n\n    for (int i : cases) {\n        solve(i);\n    }\n}"
		]
	},
	"Pragmas": {
		"prefix": "pragmas",
		"body": [
			"#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
		]
	},
	"Mod Stuff": {
		"prefix": "modstuff",
		"body": [
			"const ll MOD = 1e9 + 7;\n\nll mul(ll a) {\n    return a % MOD;\n}\n\ntemplate<typename... Args>\nll mul(ll first, Args... args) {\n    return ((first % MOD) * mul(args...)) % MOD;\n}\n\nll add(ll a, ll b) {\n    return (a + b + MOD) % MOD; \n}\n\nvoid inc(ll& a, ll b) {\n    dbg(a, b);\n    a = (a + b) % MOD;\n}"
		]
	},
	"Debug": {
		"prefix": "debug",
		"body": [
			"template<template<typename> class Container, typename T>\nostream& operator<<(ostream& os, Container<T> o) {\n        os << \"{\"; int g = o.size(); for (auto i : o) os << i << ((--g)==0?\"\":\", \"); os << \"}\";\n    return os;\n}\n\nvoid _print() {\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, typename ...V>\nvoid _print(T t, V... v) {\n    cerr << t; if (sizeof...(v)) cerr << \", \"; _print(v...);\n}\n\n#ifdef LOCAL\n#define dbg(x...) cerr <<__func__ << \":\" <<__LINE__ << \" \" << #x << \" = \"; _print(x);\n#else\n#define dbg(x...)\n#endif"
		]
	}
}