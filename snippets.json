{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
    "tmp": {
        "prefix": "tmp",
        "body": [
            "#include <bits/extc++.h>",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "// #pragma GCC optimize(\"O3,unroll-loops\")",
            "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "template<class T> using vt = vector<T>;",
            "using str = string;",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;",
            "using db = long double;",
            "using pi = pair<int, int>;",
            "using pl = pair<ll, ll>;",
            "using pd = pair<db, db>;",
            "using vi = vt<int>;",
            "using vl = vt<ll>;",
            "using vb = vt<bool>;",
            "using vvi = vt<vt<int>>;",
            "using vvl = vt<vt<ll>>;",
            "using vvb = vt<vt<bool>>;",
            "using vpi = vt<pi>;",
            "using vpl = vt<pl>;",
            "",
            "const ll mod = 1e9 + 7;",
            "// const ll mod = 998244353;",
            "const int precision = 24;",
            "",
            "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
            "",
            "struct chash { // large odd number for C",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
            "\tll operator()(ll x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
            "};",
            "",
            "#define gptable gp_hash_table",
            "#define priority_queue std::priority_queue",
            "template<class K, class V, class hash> gptable<K, V, hash> make_gptable() {",
            "\treturn gptable<K, V, hash>({}, {}, {}, {}, {1 << 16});",
            "}",
            "",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define bg(x) begin(x)",
            "#define en(x) end(x) ",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define size(x) (static_cast<int>((x).size()))",
            "#define sq(x) ((x) * (x))",
            "#define rsz resize",
            "#define ins insert",
            "#define ft front()",
            "#define bk back()",
            "#ifndef LOCAL",
            "#define endl '\\n'",
            "#endif",
            "",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "template<class T> int lwb(vt<T>& a, const T& b) { return int(lb(all(a), b) - bg(a)); }",
            "template<class T> int upb(vt<T>& a, const T& b) { return int(ub(all(a), b) - bg(a)); }",
            "template<class T> void rem_dup(vt<T>& v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "#define contains(a, x) find(all(x), a) == end(x)",
            "",
            "#define cmp(exp) [&] (const auto& x, const auto& y) { return exp; }",
            "",
            "#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())",
            "#define __NARG_I_(...) __ARG_N(__VA_ARGS__)",
            "#define __ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N",
            "#define __RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
            "",
            "#define _VFUNC_(name, n) name##n",
            "#define _VFUNC(name, n) _VFUNC_(name, n)",
            "#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)",
            "",
            "#define FOR1(a) for (int _ = 0; _ < (a); _++)",
            "#define FOR2(i, b) for (int i = 0; i < (b); i++)",
            "#define FOR3(i, a, b) for (int i = (a); i < (b); i++)",
            "#define ROF2(i, b) for (int i = (b) - 1; i >= 0; i--)",
            "#define ROF3(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "",
            "#define each2(a, x) for (auto& a : x)",
            "#define each3(a, b, x) for (auto& [a, b] : x)",
            "#define each4(a, b, c, x) for (auto& [a, b, c] : x)",
            "#define reach2(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& a = *it; 1)",
            "#define reach3(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& [a, b] = *it; 1)",
            "#define reach4(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define enum3(i, a, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& a = *it; 1)",
            "#define enum4(i, a, b, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b] = *it; 1)",
            "#define enum5(i, a, b, c, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b, c] = *it; 1)",
            "#define renum3(i, a, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& a = *it; 1)",
            "#define renum4(i, a, b, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& [a, b] = *it; 1)",
            "#define renum5(i, a, b, c, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define FOR(...) VFUNC(FOR, __VA_ARGS__)",
            "#define ROF(...) VFUNC(ROF, __VA_ARGS__)",
            "#define each(...) VFUNC(each, __VA_ARGS__)",
            "#define reach(...) VFUNC(reach, __VA_ARGS__)",
            "#define enum(...) VFUNC(enum, __VA_ARGS__)",
            "#define renum(...) VFUNC(renum, __VA_ARGS__)",
            "",
            "#define lam1(x) [&] () { return x; }",
            "#define lam2(x, y) [&] (x) { return y;}",
            "#define lam3(x, y, z) [&] (x, y) { return z; }",
            "#define lam4(w, x, y, z) [&] (w, x, y) { return z; }",
            "",
            "#define lam(...) VFUNC(lam, __VA_ARGS__)",
            "",
            "__gnu_cxx::sfmt19937 mt((uint32_t) chrono::steady_clock::now().time_since_epoch().count());",
            "ll mpow(ll x, ll y = mod - 2) {",
            "\tll res = 1;",
            "\tfor (; y; x = (x * x) % mod, y >>= 1) if (y & 1) res = (res * x) % mod;",
            "\treturn res;",
            "}",
            "ll gen(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(mt); }",
            "",
            "int rs, cs;",
            "const int dr[5] {0, -1, 0, 1, 0}, dc[5] {1, 0, -1, 0, 0};",
            "bool valid(int r, int c) { return r >= 0 && c >= 0 && r < rs && c < cs; }",
            "vpi get_adj(int r, int c) {",
            "\tvpi ret(4);",
            "\tFOR (i, 4) ret[i] = {r + dr[i], c + dc[i]};",
            "\treturn ret;",
            "}",
            "vpi get_valid_adj(int r, int c) {",
            "\tvpi ret;",
            "\tFOR (i, 4) {",
            "\t\tint nr = r + dr[i];",
            "\t\tint nc = c + dc[i];",
            "\t\tif (valid(nr, nc)) ret.eb(nr, nc);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); }",
            "constexpr int pctl(ll x) { return __builtin_popcountll(x); }",
            "// 2 ^ bits(n) is the largest power of 2 <= n",
            "constexpr int bits(int x) { return x ? 31 - __builtin_clz(x) : 0; }",
            "constexpr int bits(ll x) { return x ? 63 - __builtin_clzll(x) : 0; }",
            "constexpr int p2(int x) { return 1 << x; }",
            "constexpr ll p2l(int x) { return 1ll << x; }",
            "constexpr int msk2(int x) { return p2(x) - 1; }",
            "constexpr ll msk2l(int x) { return p2l(x) - 1; }",
            "",
            "ll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }",
            "",
            "namespace IO {",
            "#ifndef LOCAL",
            "\tconst int BSZ = 1 << 15;",
            "\tchar ibuf[BSZ]; int ipos, ilen;",
            "\tchar _next_char() {",
            "\t\tif (ipos == ilen) {",
            "\t\t\tipos = 0;",
            "\t\t\tilen = fread(ibuf, 1, BSZ, stdin);",
            "\t\t\tif (!ilen) return EOF;",
            "\t\t}",
            "\t\treturn ibuf[ipos++];",
            "\t}",
            "\tchar _nc() {",
            "\t\tchar ch;",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t\treturn ch;",
            "\t}",
            "\tvoid _rc(char& ch) {",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t}",
            "\tstring _ns() {",
            "\t\tstring x;",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t\treturn x;",
            "\t}",
            "\tvoid _rs(string& x) {",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t}",
            "\tint _ni() {",
            "\t\tint x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\tll _nl() {",
            "\t\tll x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\ttemplate<class T> void _ri(T& x) {",
            "\t\tchar ch;",
            "\t\tint sgn = 1;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\tx *= sgn;",
            "\t}",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { _ri(t); _ri(ts...); }",
            "\tchar obuf[BSZ], numBuf[100]; int opos;",
            "\tvoid flushOut() {",
            "\t\tfwrite(obuf, 1, opos, stdout); opos = 0;",
            "\t}",
            "\tvoid _wc(char c) {",
            "\t\tif (opos == BSZ) flushOut();",
            "\t\tobuf[opos++] = c;",
            "\t}",
            "\tvoid _ws(string s) { for (char& c : s) _wc(c); }",
            "\ttemplate<class T> void _wi(T x) {",
            "\t\tif (x < 0) _wc('-'), x *= -1;",
            "\t\tint len = 0;",
            "\t\tfor (; x >= 10; x /= 10) numBuf[len++] = '0' + (x % 10);",
            "\t\t_wc('0' + x);",
            "\t\tfor (int i = len - 1; i >= 0; i--) _wc(numBuf[i]);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) {",
            "\t\tstr in; _rs(in); x = stold(in);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) {",
            "\t\tostringstream sout;",
            "\t\tsout << std::fixed << std::setprecision(precision) << x;",
            "\t\tstr out = sout.str();",
            "\t\teach(c, out) _wc(c);",
            "\t}",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { assert(atexit(flushOut) == 0); }",
            "#else",
            "\tchar _nc() { char ch; cin >> ch; return ch; }",
            "\tvoid _rc(char& ch) { cin >> ch; }",
            "\tstring _ns() { string x; cin >> x; return x; }",
            "\tvoid _rs(string& x) { cin >> x; }",
            "\tint _ni() { int x; cin >> x; return x; }",
            "\tll _nl() { ll x; cin >> x; return x; }",
            "\ttemplate<class T> void _ri(T& x) { cin >> x; }",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { ri(t); ri(ts...); }",
            "\tvoid _wc(char c) {",
            "\t\tif (c == '\\n') cout << endl;",
            "\t\telse cout << c;",
            "\t}",
            "\tvoid _ws(string s) { cout << s; }",
            "\ttemplate<class T> void _wi(T x) { cout << x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) { cin >> x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) { cout << std::fixed << std::setprecision(precision) << x; }",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { cin.tie(0)->sync_with_stdio(0); }",
            "#endif",
            "}",
            "",
            "void setfileaio(string name) {",
            "#ifndef LOCAL",
            "\tif (name == \"\") return;",
            "\tfreopen((name + \"in.txt\").c_str(), \"r\", stdin);",
            "\tfreopen((name + \"out.txt\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "void setfile(string pfx) {",
            "#ifndef LOCAL",
            "\tif (pfx == \"\") return;",
            "\tfreopen((pfx + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((pfx + \".out\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "template<typename... Args> // tuples",
            "ostream& operator<<(ostream& os, tuple<Args...> t) {",
            "\tapply([&](Args... args) { string dlm = \"{\"; ((os << dlm << args, dlm = \", \"), ...); }, t);",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<typename T, typename V> // pairs",
            "ostream& operator<<(ostream& os, pair<T, V> p) { return os << \"{\" << p.f << \", \" << p.s << \"}\"; }",
            "",
            "template<typename T, typename V>",
            "istream& operator>>(istream& os, pair<T, V> p) { return os >> p.f >> p.s; }",
            "",
            "template<class T, class = decltype(begin(declval<T>()))> // iterables",
            "typename enable_if<!is_same<T, string>::value, ostream&>::type operator<<(ostream& os, const T& v) {",
            "\tos << \"{\";",
            "\tstring dlm = \"\";",
            "\tfor (auto i : v) os << dlm << i, dlm = \", \";",
            "\treturn os << \"}\";",
            "}",
            "",
            "void read(char& x) { x = IO::_nc(); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type read(T& x) { IO::_ri(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type read(T &x) { IO::_rf(x); }",
            "void read(bool& x) { char c; read(c); x = (c == '1'); }",
            "void read(string& x) { IO::_rs(x); }",
            "template<typename... Args> ",
            "void read(tuple<Args...>& t) { apply([&](Args&... args) {((read(args)), ...); }, t); }",
            "template<class T, class U> void read(pair<T, U>& x) { read(x.f); read(x.s); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type read(T& v) { for (auto& i : v) read(i); }",
            "template<class T, class... Ts> void read(T& t, Ts&... ts) { read(t); read(ts...); }",
            "",
            "void _print(const char& c) { IO::_wc(c); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type _print(T x) { IO::_wi(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type _print(T& x) { IO::_wf(x); }",
            "void _print(const bool& x) { IO::_wi(x); }",
            "void _print(const string& x) { IO::_ws(x); }",
            "void _print(const char* x) { IO::_ws(x); }",
            "template<typename... Args> ",
            "void _print(tuple<Args...> t) { string delim = \"\"; apply([&](Args... args) {((_print(delim), _print(args), delim = ' '), ...); }, t); }",
            "template<class T, class U>",
            "void _print(const pair<T, U>& x) { _print(x.first); _print(' '); _print(x.second); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type _print(const T& v) { each(i, v) _print(i), _print(' '); }",
            "template<class T> void print(const T& t) { _print(t); _print(' '); }",
            "template<class T, class... Ts> void print(const T& t, const Ts&... ts) { _print(t); _print(' '); print(ts...); }",
            "template <typename T>",
            "void print(initializer_list<T> args) { each(e, args) _print(e); }",
            "void println() { _print('\\n'); }",
            "template<class T> void println(const T& t) { _print(t); _print('\\n'); }",
            "template<class T, class... Ts> void println(const T& t, const Ts&... ts) { _print(t); _print(' '); println(ts...); }",
            "template<class T>",
            "void println(initializer_list<T> args) { each(e, args) _print(e); _print('\\n'); }",
            "",
            "int nxti() { return IO::_ni(); }",
            "ll nxtl() { return IO::_nl(); }",
            "char nxtc() { return IO::_nc(); }",
            "",
            "#define ri1(a) int a = IO::_ni()",
            "#define ri2(a, b) int a = IO::_ni(); int b = IO::_ni()",
            "#define ri3(a, b, c) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni()",
            "#define ri4(a, b, c, d) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni(); int d = IO::_ni()",
            "#define rid1(a) int a = IO::_ni() - 1",
            "#define rid2(a, b) int a = IO::_ni() - 1; int b = IO::_ni() - 1",
            "#define rid3(a, b, c) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1",
            "#define rid4(a, b, c, d) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1; int d = IO::_ni() - 1",
            "#define rl1(a) ll a = IO::_nl()",
            "#define rl2(a, b) ll a = IO::_nl(); ll b = IO::_nl()",
            "#define rl3(a, b, c) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl()",
            "#define rl4(a, b, c, d) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl(); ll d = IO::_nl()",
            "#define rd1(a) db a = IO::_nf()",
            "#define rd2(a, b) db a = IO::_nf(); db b = IO::_nf()",
            "#define rd3(a, b, c) a = IO::_nf(); b = IO::_nf(); c = IO::_nf()",
            "#define rd4(a, b, c, d) a = IO::_nf(); b = IO::_nf(); c = IO::_nf(), d = IO::_nf()",
            "#define rc1(a) char a = IO::_nc()",
            "#define rc2(a, b) char a = IO::_nc(); char b = IO::_nc()",
            "#define rc3(a, b, c) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc()",
            "#define rc4(a, b, c, d) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc(); char d = IO::_nc()",
            "#define rs1(a) string a = IO::_ns()",
            "#define rs2(a, b) string a = IO::_ns(); string b = IO::_ns()",
            "#define rvi(a, n) vi a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvid(a, n) vi a(n); FOR (i, n) IO::_ri(a[i]), a[i]--;",
            "#define rvl(a, n) vl a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvb(a, n) vb a(n); FOR (i, n) a[i] = (nxtc() == '1')",
            "",
            "#define ri(...) VFUNC(ri, __VA_ARGS__)",
            "#define rid(...) VFUNC(rid, __VA_ARGS__)",
            "#define rl(...) VFUNC(rl, __VA_ARGS__)",
            "#define rd(...) VFUNC(rd, __VA_ARGS__)",
            "#define rc(...) VFUNC(rc, __VA_ARGS__)",
            "#define rs(...) VFUNC(rs, __VA_ARGS__)",
            "",
            "const int inf = 1e9;",
            "const ll INF = 1e18;",
            "const db eps = 1e-9;",
            "",
            "vi make_perm(int n) { vi ret(n); iota(all(ret), 0); return ret; }",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "#ifdef LOCAL",
            "template <typename T, typename... V>",
            "void printer(string pfx, const char *names, T&& head, V&& ...tail) {",
            "\tint i = 0, brackets = 0;",
            "\twhile (names[i] && (names[i] != ',' || brackets)) {",
            "\t\tif (names[i] == '(' || names[i] == '{') brackets++;",
            "\t\tif (names[i] == ')' || names[i] == '}') brackets--;",
            "\t\ti++;",
            "\t}",
            "\tconstexpr bool is_str = is_same_v<decay_t<T>, const char*>;",
            "\tif (is_str) cerr << \" \" << head;",
            "\telse cerr << pfx, cerr.write(names, i) << \" = \" << head; ",
            "\tif constexpr (sizeof...(tail)) printer(is_str ? \"\" : \",\", names + i + 1, tail...);",
            "\telse cerr << endl;",
            "}",
            "",
            "#define dbg(...) printer(to_string(__LINE__) + \": \", #__VA_ARGS__, __VA_ARGS__)",
            "#else",
            "#define dbg(x...)",
            "#define cerr if (0) std::cerr",
            "#endif",
            "",
            "/*",
            "",
            "",
            "",
            "*/",
            "",
            "main() {",
            "\tIO::initO(); ",
            "",
            "\t$0",
            "}"
        ]
    },
    "tmpcf": {
        "prefix": "tmpcf",
        "body": [
            "#include <bits/extc++.h>",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "// #pragma GCC optimize(\"O3,unroll-loops\")",
            "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "template<class T> using vt = vector<T>;",
            "using str = string;",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;",
            "using db = long double;",
            "using pi = pair<int, int>;",
            "using pl = pair<ll, ll>;",
            "using pd = pair<db, db>;",
            "using vi = vt<int>;",
            "using vl = vt<ll>;",
            "using vb = vt<bool>;",
            "using vvi = vt<vt<int>>;",
            "using vvl = vt<vt<ll>>;",
            "using vvb = vt<vt<bool>>;",
            "using vpi = vt<pi>;",
            "using vpl = vt<pl>;",
            "",
            "const ll mod = 1e9 + 7;",
            "// const ll mod = 998244353;",
            "const int precision = 24;",
            "",
            "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
            "",
            "struct chash { // large odd number for C",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
            "\tll operator()(ll x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
            "};",
            "",
            "#define gptable gp_hash_table",
            "#define priority_queue std::priority_queue",
            "template<class K, class V, class hash> gptable<K, V, hash> make_gptable() {",
            "\treturn gptable<K, V, hash>({}, {}, {}, {}, {1 << 16});",
            "}",
            "",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define bg(x) begin(x)",
            "#define en(x) end(x) ",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define size(x) (static_cast<int>((x).size()))",
            "#define sq(x) ((x) * (x))",
            "#define rsz resize",
            "#define ins insert",
            "#define ft front()",
            "#define bk back()",
            "#ifndef LOCAL",
            "#define endl '\\n'",
            "#endif",
            "",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "template<class T> int lwb(vt<T>& a, const T& b) { return int(lb(all(a), b) - bg(a)); }",
            "template<class T> int upb(vt<T>& a, const T& b) { return int(ub(all(a), b) - bg(a)); }",
            "template<class T> void rem_dup(vt<T>& v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "#define contains(a, x) find(all(x), a) == end(x)",
            "",
            "#define cmp(exp) [&] (const auto& x, const auto& y) { return exp; }",
            "",
            "#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())",
            "#define __NARG_I_(...) __ARG_N(__VA_ARGS__)",
            "#define __ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N",
            "#define __RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
            "",
            "#define _VFUNC_(name, n) name##n",
            "#define _VFUNC(name, n) _VFUNC_(name, n)",
            "#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)",
            "",
            "#define FOR1(a) for (int _ = 0; _ < (a); _++)",
            "#define FOR2(i, b) for (int i = 0; i < (b); i++)",
            "#define FOR3(i, a, b) for (int i = (a); i < (b); i++)",
            "#define ROF2(i, b) for (int i = (b) - 1; i >= 0; i--)",
            "#define ROF3(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "",
            "#define each2(a, x) for (auto& a : x)",
            "#define each3(a, b, x) for (auto& [a, b] : x)",
            "#define each4(a, b, c, x) for (auto& [a, b, c] : x)",
            "#define reach2(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& a = *it; 1)",
            "#define reach3(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& [a, b] = *it; 1)",
            "#define reach4(a, x) for (auto it = rbegin(x); it != rend(x); it++) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define enum3(i, a, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& a = *it; 1)",
            "#define enum4(i, a, b, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b] = *it; 1)",
            "#define enum5(i, a, b, c, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b, c] = *it; 1)",
            "#define renum3(i, a, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& a = *it; 1)",
            "#define renum4(i, a, b, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& [a, b] = *it; 1)",
            "#define renum5(i, a, b, c, x) if (int i = ((int) size(x)) - 1; 1) for (auto it = rbegin(x); it != rend(x); it++, i--) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define FOR(...) VFUNC(FOR, __VA_ARGS__)",
            "#define ROF(...) VFUNC(ROF, __VA_ARGS__)",
            "#define each(...) VFUNC(each, __VA_ARGS__)",
            "#define reach(...) VFUNC(reach, __VA_ARGS__)",
            "#define enum(...) VFUNC(enum, __VA_ARGS__)",
            "#define renum(...) VFUNC(renum, __VA_ARGS__)",
            "",
            "#define lam1(x) [&] () { return x; }",
            "#define lam2(x, y) [&] (x) { return y;}",
            "#define lam3(x, y, z) [&] (x, y) { return z; }",
            "#define lam4(w, x, y, z) [&] (w, x, y) { return z; }",
            "",
            "#define lam(...) VFUNC(lam, __VA_ARGS__)",
            "",
            "__gnu_cxx::sfmt19937 mt((uint32_t) chrono::steady_clock::now().time_since_epoch().count());",
            "ll mpow(ll x, ll y = mod - 2) {",
            "\tll res = 1;",
            "\tfor (; y; x = (x * x) % mod, y >>= 1) if (y & 1) res = (res * x) % mod;",
            "\treturn res;",
            "}",
            "ll gen(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(mt); }",
            "",
            "int rs, cs;",
            "const int dr[5] {0, -1, 0, 1, 0}, dc[5] {1, 0, -1, 0, 0};",
            "bool valid(int r, int c) { return r >= 0 && c >= 0 && r < rs && c < cs; }",
            "vpi get_adj(int r, int c) {",
            "\tvpi ret(4);",
            "\tFOR (i, 4) ret[i] = {r + dr[i], c + dc[i]};",
            "\treturn ret;",
            "}",
            "vpi get_valid_adj(int r, int c) {",
            "\tvpi ret;",
            "\tFOR (i, 4) {",
            "\t\tint nr = r + dr[i];",
            "\t\tint nc = c + dc[i];",
            "\t\tif (valid(nr, nc)) ret.eb(nr, nc);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); }",
            "constexpr int pctl(ll x) { return __builtin_popcountll(x); }",
            "// 2 ^ bits(n) is the largest power of 2 <= n",
            "constexpr int bits(int x) { return x ? 31 - __builtin_clz(x) : 0; }",
            "constexpr int bits(ll x) { return x ? 63 - __builtin_clzll(x) : 0; }",
            "constexpr int p2(int x) { return 1 << x; }",
            "constexpr ll p2l(int x) { return 1ll << x; }",
            "constexpr int msk2(int x) { return p2(x) - 1; }",
            "constexpr ll msk2l(int x) { return p2l(x) - 1; }",
            "",
            "ll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }",
            "",
            "namespace IO {",
            "#ifndef LOCAL",
            "\tconst int BSZ = 1 << 15;",
            "\tchar ibuf[BSZ]; int ipos, ilen;",
            "\tchar _next_char() {",
            "\t\tif (ipos == ilen) {",
            "\t\t\tipos = 0;",
            "\t\t\tilen = fread(ibuf, 1, BSZ, stdin);",
            "\t\t\tif (!ilen) return EOF;",
            "\t\t}",
            "\t\treturn ibuf[ipos++];",
            "\t}",
            "\tchar _nc() {",
            "\t\tchar ch;",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t\treturn ch;",
            "\t}",
            "\tvoid _rc(char& ch) {",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t}",
            "\tstring _ns() {",
            "\t\tstring x;",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t\treturn x;",
            "\t}",
            "\tvoid _rs(string& x) {",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t}",
            "\tint _ni() {",
            "\t\tint x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\tll _nl() {",
            "\t\tll x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\ttemplate<class T> void _ri(T& x) {",
            "\t\tchar ch;",
            "\t\tint sgn = 1;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\tx *= sgn;",
            "\t}",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { _ri(t); _ri(ts...); }",
            "\tchar obuf[BSZ], numBuf[100]; int opos;",
            "\tvoid flushOut() {",
            "\t\tfwrite(obuf, 1, opos, stdout); opos = 0;",
            "\t}",
            "\tvoid _wc(char c) {",
            "\t\tif (opos == BSZ) flushOut();",
            "\t\tobuf[opos++] = c;",
            "\t}",
            "\tvoid _ws(string s) { for (char& c : s) _wc(c); }",
            "\ttemplate<class T> void _wi(T x) {",
            "\t\tif (x < 0) _wc('-'), x *= -1;",
            "\t\tint len = 0;",
            "\t\tfor (; x >= 10; x /= 10) numBuf[len++] = '0' + (x % 10);",
            "\t\t_wc('0' + x);",
            "\t\tfor (int i = len - 1; i >= 0; i--) _wc(numBuf[i]);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) {",
            "\t\tstr in; _rs(in); x = stold(in);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) {",
            "\t\tostringstream sout;",
            "\t\tsout << std::fixed << std::setprecision(precision) << x;",
            "\t\tstr out = sout.str();",
            "\t\teach(c, out) _wc(c);",
            "\t}",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { assert(atexit(flushOut) == 0); }",
            "#else",
            "\tchar _nc() { char ch; cin >> ch; return ch; }",
            "\tvoid _rc(char& ch) { cin >> ch; }",
            "\tstring _ns() { string x; cin >> x; return x; }",
            "\tvoid _rs(string& x) { cin >> x; }",
            "\tint _ni() { int x; cin >> x; return x; }",
            "\tll _nl() { ll x; cin >> x; return x; }",
            "\ttemplate<class T> void _ri(T& x) { cin >> x; }",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { ri(t); ri(ts...); }",
            "\tvoid _wc(char c) {",
            "\t\tif (c == '\\n') cout << endl;",
            "\t\telse cout << c;",
            "\t}",
            "\tvoid _ws(string s) { cout << s; }",
            "\ttemplate<class T> void _wi(T x) { cout << x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) { cin >> x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) { cout << std::fixed << std::setprecision(precision) << x; }",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { cin.tie(0)->sync_with_stdio(0); }",
            "#endif",
            "}",
            "",
            "void setfileaio(string name) {",
            "#ifndef LOCAL",
            "\tif (name == \"\") return;",
            "\tfreopen((name + \"in.txt\").c_str(), \"r\", stdin);",
            "\tfreopen((name + \"out.txt\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "void setfile(string pfx) {",
            "#ifndef LOCAL",
            "\tif (pfx == \"\") return;",
            "\tfreopen((pfx + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((pfx + \".out\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "template<typename... Args> // tuples",
            "ostream& operator<<(ostream& os, tuple<Args...> t) {",
            "\tapply([&](Args... args) { string dlm = \"{\"; ((os << dlm << args, dlm = \", \"), ...); }, t);",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<typename T, typename V> // pairs",
            "ostream& operator<<(ostream& os, pair<T, V> p) { return os << \"{\" << p.f << \", \" << p.s << \"}\"; }",
            "",
            "template<typename T, typename V>",
            "istream& operator>>(istream& os, pair<T, V> p) { return os >> p.f >> p.s; }",
            "",
            "template<class T, class = decltype(begin(declval<T>()))> // iterables",
            "typename enable_if<!is_same<T, string>::value, ostream&>::type operator<<(ostream& os, const T& v) {",
            "\tos << \"{\";",
            "\tstring dlm = \"\";",
            "\tfor (auto i : v) os << dlm << i, dlm = \", \";",
            "\treturn os << \"}\";",
            "}",
            "",
            "void read(char& x) { x = IO::_nc(); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type read(T& x) { IO::_ri(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type read(T &x) { IO::_rf(x); }",
            "void read(bool& x) { char c; read(c); x = (c == '1'); }",
            "void read(string& x) { IO::_rs(x); }",
            "template<typename... Args> ",
            "void read(tuple<Args...>& t) { apply([&](Args&... args) {((read(args)), ...); }, t); }",
            "template<class T, class U> void read(pair<T, U>& x) { read(x.f); read(x.s); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type read(T& v) { for (auto& i : v) read(i); }",
            "template<class T, class... Ts> void read(T& t, Ts&... ts) { read(t); read(ts...); }",
            "",
            "void _print(const char& c) { IO::_wc(c); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type _print(T x) { IO::_wi(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type _print(T& x) { IO::_wf(x); }",
            "void _print(const bool& x) { IO::_wi(x); }",
            "void _print(const string& x) { IO::_ws(x); }",
            "void _print(const char* x) { IO::_ws(x); }",
            "template<typename... Args> ",
            "void _print(tuple<Args...> t) { string delim = \"\"; apply([&](Args... args) {((_print(delim), _print(args), delim = ' '), ...); }, t); }",
            "template<class T, class U>",
            "void _print(const pair<T, U>& x) { _print(x.first); _print(' '); _print(x.second); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type _print(const T& v) { each(i, v) _print(i), _print(' '); }",
            "template<class T> void print(const T& t) { _print(t); _print(' '); }",
            "template<class T, class... Ts> void print(const T& t, const Ts&... ts) { _print(t); _print(' '); print(ts...); }",
            "template <typename T>",
            "void print(initializer_list<T> args) { each(e, args) _print(e); }",
            "void println() { _print('\\n'); }",
            "template<class T> void println(const T& t) { _print(t); _print('\\n'); }",
            "template<class T, class... Ts> void println(const T& t, const Ts&... ts) { _print(t); _print(' '); println(ts...); }",
            "template<class T>",
            "void println(initializer_list<T> args) { each(e, args) _print(e); _print('\\n'); }",
            "",
            "int nxti() { return IO::_ni(); }",
            "ll nxtl() { return IO::_nl(); }",
            "char nxtc() { return IO::_nc(); }",
            "",
            "#define ri1(a) int a = IO::_ni()",
            "#define ri2(a, b) int a = IO::_ni(); int b = IO::_ni()",
            "#define ri3(a, b, c) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni()",
            "#define ri4(a, b, c, d) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni(); int d = IO::_ni()",
            "#define rid1(a) int a = IO::_ni() - 1",
            "#define rid2(a, b) int a = IO::_ni() - 1; int b = IO::_ni() - 1",
            "#define rid3(a, b, c) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1",
            "#define rid4(a, b, c, d) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1; int d = IO::_ni() - 1",
            "#define rl1(a) ll a = IO::_nl()",
            "#define rl2(a, b) ll a = IO::_nl(); ll b = IO::_nl()",
            "#define rl3(a, b, c) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl()",
            "#define rl4(a, b, c, d) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl(); ll d = IO::_nl()",
            "#define rd1(a) db a = IO::_nf()",
            "#define rd2(a, b) db a = IO::_nf(); db b = IO::_nf()",
            "#define rd3(a, b, c) a = IO::_nf(); b = IO::_nf(); c = IO::_nf()",
            "#define rd4(a, b, c, d) a = IO::_nf(); b = IO::_nf(); c = IO::_nf(), d = IO::_nf()",
            "#define rc1(a) char a = IO::_nc()",
            "#define rc2(a, b) char a = IO::_nc(); char b = IO::_nc()",
            "#define rc3(a, b, c) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc()",
            "#define rc4(a, b, c, d) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc(); char d = IO::_nc()",
            "#define rs1(a) string a = IO::_ns()",
            "#define rs2(a, b) string a = IO::_ns(); string b = IO::_ns()",
            "#define rvi(a, n) vi a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvid(a, n) vi a(n); FOR (i, n) IO::_ri(a[i]), a[i]--;",
            "#define rvl(a, n) vl a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvb(a, n) vb a(n); FOR (i, n) a[i] = (nxtc() == '1')",
            "",
            "#define ri(...) VFUNC(ri, __VA_ARGS__)",
            "#define rid(...) VFUNC(rid, __VA_ARGS__)",
            "#define rl(...) VFUNC(rl, __VA_ARGS__)",
            "#define rd(...) VFUNC(rd, __VA_ARGS__)",
            "#define rc(...) VFUNC(rc, __VA_ARGS__)",
            "#define rs(...) VFUNC(rs, __VA_ARGS__)",
            "",
            "const int inf = 1e9;",
            "const ll INF = 1e18;",
            "const db eps = 1e-9;",
            "",
            "vi make_perm(int n) { vi ret(n); iota(all(ret), 0); return ret; }",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "#ifdef LOCAL",
            "template <typename T, typename... V>",
            "void printer(string pfx, const char *names, T&& head, V&& ...tail) {",
            "\tint i = 0, brackets = 0;",
            "\twhile (names[i] && (names[i] != ',' || brackets)) {",
            "\t\tif (names[i] == '(' || names[i] == '{') brackets++;",
            "\t\tif (names[i] == ')' || names[i] == '}') brackets--;",
            "\t\ti++;",
            "\t}",
            "\tconstexpr bool is_str = is_same_v<decay_t<T>, const char*>;",
            "\tif (is_str) cerr << \" \" << head;",
            "\telse cerr << pfx, cerr.write(names, i) << \" = \" << head; ",
            "\tif constexpr (sizeof...(tail)) printer(is_str ? \"\" : \",\", names + i + 1, tail...);",
            "\telse cerr << endl;",
            "}",
            "",
            "#define dbg(...) printer(to_string(__LINE__) + \": \", #__VA_ARGS__, __VA_ARGS__)",
            "#else",
            "#define dbg(x...)",
            "#define cerr if (0) std::cerr",
            "#endif",
            "",
            "/*",
            "",
            "",
            "",
            "*/",
            "",
            "struct Solver {",
            "",
            "\tvoid sovle() {",
            "\t\t$0",
            "\t}",
            "};",
            "",
            "main() {",
            "\tIO::initO();",
            "",
            "\tri(t); ",
            "\tFOR (i, t) {",
            "\t\tSolver solver {}; ",
            "\t\tsolver.sovle();",
            "\t}",
            "}"
        ]
    },
    "crt": {
        "prefix": "crt",
        "body": [
            "// finds two integers x and y, such that ax + by = gcd(a, b)",
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a / b * x, d;",
            "}",
            "",
            "ll crt(ll a, ll m, ll b, ll n) {",
            "\tif (n > m) swap(a, b), swap(m, n);",
            "\tll x, y, g = euclid(m, n, x, y);",
            "\tassert((a - b) % g == 0); // else no solution",
            "\tx = (b - a) % n * x % n / g * m + a;",
            "\treturn x < 0 ? x + m * n / g : x;",
            "}"
        ]
    },
    "tmpaio": {
        "prefix": "tmpaio",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "main() {",
            "#ifndef LOCAL",
            "\tfreopen(\"in.txt\", \"r\", stdin);",
            "\tfreopen(\"out.txt\", \"w\", stdout);",
            "#endif",
            "\tcin.tie(0)->sync_with_stdio(0); // fastio",
            "",
            "\t$0",
            "}",
            "",
            ""
        ]
    },
	"tmpioi": {
        "prefix": "tmpioi",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "using ll = long long;",
            "#define vt vector",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define all(x) x.begin(), x.end() ",
            "#define size(x) ((int) (x).size())",
            "#define FOR(i, a, b) for (int i = (a); i < (b); i++)",
            "#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "#define F0R(i, b) FOR (i, 0, b)",
            "#define endl '\\n'",
            "const ll INF = 1e18;",
            "",
            "main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t",
            "\t$0",
            "}"
        ]
    },	
    "lichao": {
        "prefix": "lichao",
        "body": [
            "struct Line {",
            "\tll m, c;",
            "\tll operator()(ll x) {",
            "\t\treturn m * x + c;",
            "\t}",
            "};",
            "",
            "const ll sz = 1ll << 30;",
            "",
            "using ptr = struct Node*;",
            "struct Node {",
            "\tptr lc, rc;",
            "\tLine line;",
            "",
            "\tNode(Line _line) {",
            "\t\tline = _line;",
            "\t\tlc = rc = 0;",
            "\t}",
            "};",
            "",
            "// min tree (flip signs for max)",
            "void add(ptr& n, Line loser, ll l = 0, ll r = sz) {",
            "\tif (n ? 0 : n = new Node(loser)) return;",
            "\tll m = (l + r) / 2;",
            "\tif (loser(m) < n->line(m)) swap(loser, n->line);",
            "\tif (r - l == 1) return;",
            "\tif (loser(l) < n->line(l)) add(n->lc, loser, l, m);",
            "\telse add(n->rc, loser, m, r);",
            "}",
            "",
            "ll query(ptr n, ll x, ll l = 0, ll r = sz) {",
            "\tif (!n) return sz;",
            "\tll m = (l + r) / 2;",
            "\tif (x < m) return min(n->line(x), query(n->lc, x, l, m));",
            "\telse return min(n->line(x), query(n->rc, x, m, r));",
            "}"
        ]
    },
    "moncht": {
        "prefix": "moncht",
        "body": [
            "// u can usually just get away with a / b",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down",
            "",
            "struct Line {",
            "\tll m, c;",
            " ",
            "\tll inter(Line& oth) {",
            "\t\treturn (c - oth.c) / (oth.m - m);",
            "\t}",
            " ",
            "\tll operator()(ll x) {",
            "\t\treturn x * m + c;",
            "\t}",
            "};",
            " ",
            "struct CHT {",
            "\t\t// always draw out the hull on paper just to be safe",
            "\tdeque<Line> hull;",
            " ",
            "\t// dependent on query",
            "\t// compare new line with first, and first with second",
            "\tvoid add(Line l) {",
            "\t\twhile (size(hull) >= 2 && hull[0].inter(l) <= hull[1].inter(hull[0])) hull.pop_front();",
            "\t\thull.push_front(l);",
            "\t}",
            " ",
            "\tll query(ll x) {",
            "\t\twhile (size(hull) >= 2 && hull.end()[-1](x) >= hull.end()[-2](x)) hull.pop_back();",
            "\t\treturn hull.back()(x);",
            "\t}",
            "};"
        ]
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct DSU {",
            "\tvt<int> e; ",
            "\tvoid init(int n) { ",
            "\t\te.resize(n, -1);",
            "\t}",
            "\tint operator[](int x) { ",
            "\t\treturn e[x] < 0 ? x : e[x] = (*this)[e[x]]; ",
            "\t}   ",
            "\tbool operator()(int x, int y) {",
            "\t\tx = (*this)[x], y = (*this)[y]; ",
            "\t\tif (x == y) return 0;",
            "\t\tif (e[x] > e[y]) swap(x,y);",
            "\t\te[x] += e[y]; ",
            "\t\te[y] = x; ",
            "\t\treturn 1;",
            "\t}",
            "\t// optional",
            "\tbool same_set(int a, int b) { return (*this)[a] == (*this)[b]; }",
            "\tint sz(int x) { return -e[(*this)[x]]; }",
            "\tint add() { e.pb(-1); return size(e) - 1; }",
            "};"
        ]
    },
    "dsurb": {
        "prefix": "dsurbh",
        "body": [
            "struct DSU {",
            "\tint n;",
            "\tvt<int> e;",
            "\tvt<vt<pi>> stk; ",
            "\tvoid init(int _n) { n = _n; e.resize(n + 1, -1); e[n] = n; }",
            "\tvoid push() { stk.pb({}); }",
            "\tvoid pop() { ",
            "\t\treverse(all(stk.back()));",
            "\t\tfor (auto [i, v] : stk.back()) e[i] = v;",
            "\t\tstk.pop_back();",
            "\t}",
            "\tvoid upd(int i, int v) { stk.back().pb({i, e[i]}); e[i] = v; }",
            "\tint find(int x) { return e[x] < 0 ? x : find(e[x]); }",
            "\tvoid unite(int x, int y) {",
            "\t\tx = find(x), y = find(y);",
            "\t\tif (x == y) return;",
            "\t\tif (e[x] < e[y]) swap(x, y);",
            "\t\tupd(y, e[x] + e[y]);",
            "\t\tupd(x, y);",
            "\t\tupd(n, e[n] - 1);",
            "\t}",
            "\tint comps() { return e[n]; }",
            "};"
        ]
    },
    "dynacon": {
        "prefix": "dynacon",
        "body": [
            "struct DynaCon {",
            "\tint n, q, t = 0;",
            "\tvt<vt<pi>> seg;",
            "\tmap<pi, int> eds;",
            "\tDSU dsu;",
            "\tvoid init(int _n, int _q) {",
            "\t\tfor (q = 1; q < _q; q *= 2);",
            "\t\tseg.resize(2 * q);",
            "\t\tdsu.init(n = _n);",
            "\t}",
            "\tvoid toggle(int u, int v, bool erase = true) {",
            "\t\tif (u > v) swap(u, v);",
            "\t\tif (eds.count({u, v})) {",
            "\t\t\tfor (int l = eds[{u, v}] + q, r = min(++t + q, 2 * q); l < r; l /= 2, r /= 2) {",
            "\t\t\t\tif (l & 1) seg[l++].pb({u, v});",
            "\t\t\t\tif (r & 1) seg[--r].pb({u, v});",
            "\t\t\t}",
            "\t\t\tif (erase) eds.erase({u, v});",
            "\t\t} else eds[{u, v}] = t++;",
            "\t}",
            "\tvoid query() { seg[q + t++].pb({-1, -1}); }",
            "\tvoid dfs(int i, vt<int>& ans) {",
            "\t\tdsu.push();",
            "\t\tfor (auto [u, v] : seg[i]) {",
            "\t\t\tif (u == -1) ans.pb(dsu.comps());",
            "\t\t\telse dsu.unite(u, v);",
            "\t\t}",
            "\t\tif (i < q) dfs(2 * i, ans), dfs(2 * i + 1, ans);",
            "\t\tdsu.pop();",
            "\t}",
            "\tvt<int> ans() {",
            "\t\tfor (auto [u, v] : eds) toggle(u.f, u.s, false);",
            "\t\tvt<int> res;",
            "\t\tdfs(1, res);",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "genseg": {
        "prefix": "genseg",
        "body": [
            "template<class T> struct SegTree {",
            "\tT ID;",
            "\tint n; ",
            "\tvt<T> seg;",
            "\tvoid init(int _n, T _ID) {",
            "\t\tID = _ID;",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.assign(2 * n, ID);",
            "\t}",
            "\tvoid upd(int i, T val) {",
            "\t\tseg[i += n] = val;",
            "\t\twhile (i /= 2) seg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tT query(int l, int r) { // inc exc",
            "\t\tT a = ID, b = ID;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) a = a + seg[l++];",
            "\t\t\tif (r & 1) b = seg[--r] + b;",
            "\t\t}",
            "\t\treturn a + b;",
            "\t}",
            "\tT& operator[](int i) {",
            "\t\treturn seg[i + n];",
            "\t}",
            "};"
        ]
    },
    "minseg": {
        "prefix": "minseg",
        "body": [
            "struct SegTree {",
            "\t#define func(a, b) min(a, b)",
            "\t#define ID INF",
            "\tint n;",
            "\tvt<ll> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n, ID);",
            "\t}",
            "\tvoid upd(int i, ll v) {",
            "\t\tseg[i += n] = v;",
            "\t\twhile (i /= 2) seg[i] = func(seg[2 * i], seg[2 * i + 1]);",
            "\t}",
            "\tll query(int l, int r) { // inc exc ",
            "\t\tll res = ID;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) res = func(res, seg[l++]);",
            "\t\t\tif (r & 1) res = func(seg[--r], res);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t#undef ID",
            "\t#undef func",
            "};"
        ]
    },
    "sumseg": {
        "prefix": "sumseg",
        "body": [
            "struct SegTree {",
            "\tint n;",
            "\tvt<ll> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n);",
            "\t}",
            "\tvoid upd(int i, ll v) {",
            "\t\tseg[i += n] = v;",
            "\t\twhile (i /= 2) seg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tll query(int l, int r) { // inc exc",
            "\t\tll res = 0;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) res += seg[l++];",
            "\t\t\tif (r & 1) res += seg[--r];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "pseg": {
        "prefix": "pseg",
        "body": [
            "using ptr = struct Node*;",
            "const int sz = 1 << 18;",
            " ",
            "struct Node {",
            "\t#define func(a, b) min(a, b)",
            "\t#define ID inf",
            "\tint v;",
            "\tptr lc, rc;",
            " ",
            "\tptr pull(ptr lc, ptr rc) {",
            "\t\treturn new Node {func(lc->v, rc->v), lc, rc};",
            "\t}",
            " ",
            "\tptr upd(int i, int nv, int l = 0, int r = sz) {",
            "\t\tif (r - l == 1) return new Node {nv};",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) return pull(lc->upd(i, nv, l, m), rc);",
            "\t\telse return pull(lc, rc->upd(i, nv, m, r));",
            "\t}",
            " ",
            "\tint query(int lo, int hi, int l = 0, int r = sz) {",
            "\t\tif (lo >= r || hi <= l) return ID;",
            "\t\tif (lo <= l && r <= hi) return v;",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn func(lc->query(lo, hi, l, m), rc->query(lo, hi, m, r)); ",
            "\t}",
            "\t#undef id",
            "\t#undef func",
            "};"
        ]
    },
    "sparseseg": {
        "prefix": "sparseseg",
        "body": [
            "using ptr = struct Node*;",
            "const int sz = 1 << 30;",
            "struct Node {",
            "\t#define func(a, b) min(a, b)",
            "\t#define ID INF",
            "\tll val;",
            "\tptr lc, rc;",
            "",
            "\tptr get(ptr& p) { return p ? p : p = new Node {ID}; }",
            "",
            "\tll query(int lo, int hi, int l = 0, int r = sz) {",
            "\t\tif (lo >= r || hi <= l) return ID;",
            "\t\tif (lo <= l && r <= hi) return val;",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn func(get(lc)->query(lo, hi, l, m), get(rc)->query(lo, hi, m, r));",
            "\t}",
            "",
            "\tll upd(int i, ll nval, int l = 0, int r = sz) {",
            "\t\tif (r - l == 1) return val = nval;",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) get(lc)->upd(i, nval, l, m);",
            "\t\telse get(rc)->upd(i, nval, m, r);",
            "\t\treturn val = func(get(lc)->val, get(rc)->val);",
            "\t}",
            "\t#undef ID",
            "\t#undef func",
            "};"
        ]
    },
    "lazysparseseg": {
        "prefix": "lazysparseseg",
        "body": [
            "struct Lazy {",
            "\tint v;",
            "\tbool inc;",
            "",
            "\tvoid operator+=(const Lazy& oth) {",
            "\t\tif (!oth.inc) v = 0, inc = 0;",
            "\t\tv += oth.v;",
            "\t}",
            "};",
            "",
            "struct Val {",
            "\tll sum;",
            "\tint mx;",
            "",
            "\tVal operator+(const Val& oth) const {",
            "\t\treturn {sum + oth.sum, max(mx, oth.mx)};",
            "\t}",
            "",
            "\tvoid upd(Lazy& lazy, ll l, ll r) {",
            "\t\tif (!lazy.inc) sum = mx = 0;",
            "\t\tsum += lazy.v * (r - l);",
            "\t\tmx += lazy.v;",
            "\t}",
            "};",
            "",
            "const Lazy lid = {0, 1};",
            "const Val vid = {0, -inf};",
            "",
            "using ptr = struct Node*;",
            "const int sz = 1 << 30;",
            "struct Node {",
            "\tVal val;",
            "\tLazy lazy;",
            "\tptr lc, rc;",
            "",
            "\tptr get(ptr& p) { return p ? p : p = new Node {vid, lid}; }",
            "",
            "\tvoid push(ll l, ll r) {",
            "\t\tval.upd(lazy, l, r);",
            "\t\tif (r - l > 1) get(lc)->lazy += lazy, get(rc)->lazy += lazy;",
            "\t\tlazy = lid;",
            "\t}",
            "",
            "\tVal query(ll lo, ll hi, ll l = 0, ll r = sz) {",
            "\t\tpush(l, r);",
            "\t\tif (lo >= r || hi <= l) return vid;",
            "\t\tif (lo <= l && r <= hi) return val;",
            "\t\tll m = (l + r) / 2;",
            "\t\treturn get(lc)->query(lo, hi, l, m) + get(rc)->query(lo, hi, m, r);",
            "\t}",
            "",
            "\tvoid upd(ll lo, ll hi, Lazy v, ll l = 0, ll r = sz) {",
            "\t\tpush(l, r);",
            "\t\tif (lo >= r || hi <= l) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy += v;",
            "\t\t\tpush(l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tll m = (l + r) / 2;",
            "\t\tget(lc)->upd(lo, hi, v, l, m);",
            "\t\tget(rc)->upd(lo, hi, v, m, r);",
            "\t\tval = get(lc)->val + get(rc)->val;",
            "\t}",
            "};"
        ]
    },
    "kthmin": {
        "prefix": "kthmin",
        "body": [
            "using ptr = struct Node*;",
            "const ll sz = 1 << 30;",
            " ",
            "struct Node {",
            "\tint cnt;",
            "\tptr lc, rc;",
            " ",
            "\tptr pull(ptr lc, ptr rc) {",
            "\t\treturn new Node {lc->cnt + rc->cnt, lc, rc};",
            "\t}",
            " ",
            "\tptr upd(int i, int l = 0, int r = sz) {",
            "\t\tif (r - l == 1) return new Node {cnt + 1};",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) return pull(lc->upd(i, l, m), rc);",
            "\t\telse return pull(lc, rc->upd(i, m, r));",
            "\t}",
            "};",
            "",
            "int walk(ptr lo, ptr hi, int k, int l = 0, int r = sz) {",
            "\tif (r - l == 1) return l;",
            "\tint m = (l + r) / 2;",
            "\tint lhs = hi->lc->cnt - lo->lc->cnt;",
            "\tif (lhs >= k) return walk(lo->lc, hi->lc, k, l, m);",
            "\telse return walk(lo->rc, hi->rc, k - lhs, m, r);",
            "}"
        ]
    },
    "caterpillowtree": {
        "prefix": "caterpillowtree",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "\t",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tROF (d, 0, depth) {",
            "\t\t\tseg[d][x >> 6] |= 1ull << (x & 63);",
            "\t\t\tx >>= 6;",
            "\t\t}",
            "\t} ",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tROF (d, 0, depth) {",
            "\t\t\tseg[d][x >> 6] &= ~(1ull << (x & 63));",
            "\t\t\tseg[d][x >> 6] |= b << (x & 63);",
            "\t\t\tx >>= 6;",
            "\t\t\tb = bool(seg[d][x]);",
            "\t\t}",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tx = std::max(x, 0);",
            "\t\tint d = depth - 1;",
            "\t\twhile (true) {",
            "\t\t\tif (ull m = seg[d][x >> 6] >> (x & 63)) {",
            "\t\t\t\tx += __builtin_ctzll(m);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tx = (x >> 6) + 1;",
            "\t\t\tif (d == 0 || x >= (1 << (6 * d))) return sz;",
            "\t\t\td--;",
            "\t\t}",
            "\t\twhile (++d < depth) {",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[d][x]);",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "\t\tx = std::min(x, sz - 1);",
            "\t\tint d = depth - 1;",
            "\t\twhile (true) {",
            "\t\t\tif (ull m = seg[d][x >> 6] << (63 - (x & 63))) {",
            "\t\t\t\tx -= __builtin_clzll(m);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tx = (x >> 6) - 1;",
            "\t\t\tif (d == 0 || x == -1) return -1;",
            "\t\t\td--;",
            "\t\t}",
            "\t\twhile (++d < depth) {",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[d][x]);",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "",
            "\tint min() {",
            "\t\tif (empty()) return sz;",
            "\t\tint ans = 0;",
            "\t\tFOR (d, depth) {",
            "\t\t\tans <<= 6;",
            "\t\t\tans += __builtin_ctzll(seg[d][ans >> 6]);",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "",
            "\tint max() {",
            "\t\tif (empty()) return -1;",
            "\t\tint ans = 0;",
            "\t\tFOR (d, depth) {",
            "\t\t\tans <<= 6;",
            "\t\t\tans += 63 - __builtin_clzll(seg[d][ans >> 6]);",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "",
            "\tinline void clear() {",
            "\t\tfor (int x = min(); x < sz; x = min()) erase(x);",
            "\t}",
            "",
            "\tinline bool empty() { return !seg[0][0]; }",
            "\tinline int operator[](int i) { return 1 & (seg[depth - 1][i >> 6] >> (i & 63)); }",
            "};",
            ""
        ]
    },
    "caterpillowtreeunrolled": {
        "prefix": "caterpillowtreeunrolled",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tseg[2][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[1][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[0][x >> 6] |= 1ull << (x & 63);",
            "\t}",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tseg[2][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[2][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[2][x];",
            "\t\tseg[1][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[1][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[1][x];",
            "\t\tseg[0][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[0][x >> 6] |= b << (x & 63);",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tif (ull m = seg[2][x >> 6] >> (x & 63)) return x + __builtin_ctzll(m);",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << (12))) return sz;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << 6)) return sz;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn sz;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "",
            "\t\tif (ull m = seg[2][x >> 6] << (63 - (x & 63))) return x - __builtin_clzll(m);",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "};"
        ]
    },    "caterpillowtreeunrolled": {
        "prefix": "caterpillowtreeunrolled",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tseg[2][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[1][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[0][x >> 6] |= 1ull << (x & 63);",
            "\t}",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tseg[2][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[2][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[2][x];",
            "\t\tseg[1][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[1][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[1][x];",
            "\t\tseg[0][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[0][x >> 6] |= b << (x & 63);",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tif (ull m = seg[2][x >> 6] >> (x & 63)) return x + __builtin_ctzll(m);",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << (12))) return sz;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << 6)) return sz;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn sz;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "",
            "\t\tif (ull m = seg[2][x >> 6] << (63 - (x & 63))) return x - __builtin_clzll(m);",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "};"
        ]
    },
    "bcc": {
        "prefix": "bcc",
        "body": [
            "struct BCC { ",
            "\tint n, t; ",
            "\tvt<vt<int>> adj, comps;",
            "\tvt<int> tin, low, stk;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "",
            "\tvoid dfs(int u) {",
            "\t\ttin[u] = low[u] = ++t;",
            "\t\tstk.pb(u);   ",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tif (tin[v]) low[u] = min(low[u], tin[v]);",
            "\t\t\telse {",
            "\t\t\t\tdfs(v);",
            "\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\tif (low[v] == tin[u]) {",
            "\t\t\t\t\tcomps.pb({u});",
            "\t\t\t\t\tfor (int w = -1; w != v;) {",
            "\t\t\t\t\t\tcomps.back().pb(w = stk.back());",
            "\t\t\t\t\t\tstk.pop_back();",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid gen() {",
            "\t\tt = 0;",
            "\t\ttin = low = vt<int>(n);",
            "\t\tFOR (u, n) if (!tin[u]) dfs(u); ",
            "\t\tFOR (u, n) if (!size(adj[u])) comps.pb({u});   ",
            "\t}",
            "};"
        ]
    },
    "bct": {
        "prefix": "bct",
        "body": [
            "struct BCT { ",
            "\tint n, t = 0; ",
            "\tvt<vt<int>> adj, comps;",
            "\tvt<int> tin, low, stk, is_art;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "",
            "\tvoid dfs(int u) {",
            "\t\ttin[u] = low[u] = ++t;",
            "\t\tstk.pb(u);   ",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tif (tin[v]) low[u] = min(low[u], tin[v]);",
            "\t\t\telse {",
            "\t\t\t\tdfs(v);",
            "\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\tif (low[v] == tin[u]) {",
            "\t\t\t\t\tis_art[u] = (u != stk[0]) || tin[v] > tin[u] + 1;",
            "\t\t\t\t\tcomps.pb({u});",
            "\t\t\t\t\tfor (int w = -1; w != v;) {",
            "\t\t\t\t\t\tcomps.back().pb(w = stk.back());",
            "\t\t\t\t\t\tstk.pop_back();",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// make sure the graph is connected!",
            "\tvoid gen(int& n0, vt<vt<int>>& adj0, vt<int>& id) {",
            "\t\tt = 0;",
            "\t\ttin = low = is_art = vt<int>(n);",
            "\t\tFOR (u, n) if (!tin[u]) dfs(u); ",
            "\t\tFOR (u, n) if (!size(adj[u])) comps.pb({u});   ",
            "",
            "\t\tid.resize(n);   ",
            "\t\tFOR (u, n) {",
            "\t\t\tif (is_art[u]) {",
            "\t\t\t\tid[u] = n0++;",
            "\t\t\t\tadj0.pb({});",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfor (auto& comp : comps) {",
            "\t\t\tadj0.pb({});",
            "\t\t\tfor (int u : comp) {",
            "\t\t\t\tif (is_art[u]) {",
            "\t\t\t\t\tadj0[n0].pb(id[u]);",
            "\t\t\t\t\tadj0[id[u]].pb(n0);",
            "\t\t\t\t} else id[u] = n0;",
            "\t\t\t}",
            "\t\t\tn0++;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "template<class T> struct RMQ {",
            "\tvt<vt<T>> dp;",
            "\tvoid init(const vt<T>& v) {",
            "\t\tdp.resize(32 - __builtin_clz(size(v)), vt<T>(size(v)));",
            "\t\tcopy(all(v), begin(dp[0]));",
            "\t\tfor (int j = 1; 1 << j <= size(v); ++j) {",
            "\t\t\tFOR (i, size(v) - (1 << j) + 1) dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l + 1);",
            "\t\treturn min(dp[d][l], dp[d][r - (1 << d) + 1]); ",
            "\t}",
            "};",
            "",
            "struct LCA {",
            "\tint n; ",
            "\tvt<vt<int>> adj;",
            "\tvt<int> depth, pos, par, id;",
            "\tvt<pl> tmp; ",
            "\tRMQ<pl> rmq;",
            "\tvoid init(BCT& bct) { ",
            "\t\tn = 0;",
            "\t\tbct.gen(n, adj, id);",
            "\t\tdepth = pos = par = vt<int>(n); ",
            "\t}",
            "\tvoid dfs(int x) {",
            "\t\tpos[x] = size(tmp); ",
            "\t\ttmp.pb({depth[x], x}); ",
            "\t\tfor(int y : adj[x]) {",
            "\t\t\tif (y != par[x]) {",
            "\t\t\t\tdepth[y] = depth[par[y] = x] + 1, dfs(y);",
            "\t\t\t\ttmp.pb({depth[x], x}); ",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid gen(int rt = 0) { ",
            "\t\tpar[rt] = rt; ",
            "\t\tdfs(rt); ",
            "\t\trmq.init(tmp); ",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tu = pos[u], v = pos[v]; ",
            "\t\tif (u > v) swap(u,v);",
            "\t\treturn rmq.query(u,v).s;",
            "\t}",
            "\tint dist(int u, int v) {",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};"
        ]
    },
    "scc": {
        "prefix": "scc",
        "body": [
            "struct SCC {",
            "\tint n; ",
            "\tvt<vt<int>> adj, radj;",
            "\tvt<int> todo, seen, comp, comps; // comps is topologically sorted",
            "\tvoid init(int _n) { ",
            "\t\tn = _n; ",
            "\t\tadj = radj = vt<vt<int>>(n);",
            "\t\tcomp.resize(n, -1);",
            "\t\tseen.resize(n); ",
            "\t}",
            "\tvoid ae(int u, int v) { adj[u].pb(v), radj[v].pb(u); }",
            "\tvoid dfs(int u) {",
            "\t\tif (seen[u]++) return;",
            "\t\tfor (int v : adj[u]) dfs(v); ",
            "\t\ttodo.pb(u);",
            "\t}",
            "\tvoid rdfs(int u, int w) {",
            "\t\tcomp[u] = w;",
            "\t\tfor (int v : radj[u]) if (comp[v] == -1) rdfs(v, w); ",
            "\t}",
            "\tvoid gen() {",
            "\t\tFOR (i, n) dfs(i);",
            "\t\treverse(all(todo));",
            "\t\tfor (int u : todo) if (comp[u] == -1) rdfs(u, u), comps.pb(u);",
            "\t}",
            "};"
        ]
    },
        "dinic": {
        "prefix": "dinic",
        "body": [
            "// O(VE log U)",
            "// U is the max capacity of any edge",
            "struct Dinic {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tll c, oc;",
            "\t\tll flow() { return max(oc - c, 0LL); } // if you need flows",
            "\t};",
            "\tvt<int> lvl, ptr, q;",
            "\tvt<vt<Edge>> adj;",
            "",
            "\tvoid init(int n) {",
            "\t\tlvl = ptr = q = vt<int>(n);",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int a, int b, ll c, ll rcap = 0) {",
            "\t\tadj[a].push_back({b, size(adj[b]), c, c});",
            "\t\tadj[b].push_back({a, size(adj[a]) - 1, rcap, rcap});",
            "\t}",
            "\tll dfs(int v, int t, ll f) {",
            "\t\tif (v == t || !f) return f;",
            "\t\tfor (int& i = ptr[v]; i < size(adj[v]); i++) {",
            "\t\t\tEdge& e = adj[v][i];",
            "\t\t\tif (lvl[e.to] == lvl[v] + 1)",
            "\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {",
            "\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;",
            "\t\t\t\t\treturn p;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tll flow = 0; q[0] = s;",
            "\t\tFOR (L, 0, 31) do { // 'int L=30' maybe faster for random data",
            "\t\t\tlvl = ptr = vt<int>(size(q));",
            "\t\t\tint qi = 0, qe = lvl[s] = 1;",
            "\t\t\twhile (qi < qe && !lvl[t]) {",
            "\t\t\t\tint v = q[qi++];",
            "\t\t\t\tfor (Edge e : adj[v])",
            "\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))",
            "\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
            "\t\t\t}",
            "\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
            "\t\t} while (lvl[t]);",
            "\t\treturn flow;",
            "\t}",
            "\tbool leftOfMinCut(int a) { return lvl[a] != 0; }",
            "};"
        ]
    },
    "point": {
        "prefix": "point",
        "body": [
            "// T can be e.g. double or long long. (Avoid int.)",
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "\ttypedef Point P;",
            "\tT x, y;",
            "\texplicit Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "\tbool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }",
            "\tbool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }",
            "\tP operator+(P p) const { return P(x + p.x, y + p.y); }",
            "\tP operator-(P p) const { return P(x - p.x, y - p.y); }",
            "\tP operator*(T d) const { return P(x * d, y * d); }",
            "\tP operator/(T d) const { return P(x / d, y / d); }",
            "\tT dot(P p) const { return x * p.x + y * p.y; }",
            "\tT cross(P p) const { return x * p.y - y * p.x; }",
            "\tT cross(P a, P b) const { return (a - *this).cross(b - *this); }",
            "\tT dist2() const { return x * x + y * y; }",
            "\tdouble dist() const { return sqrt((double) dist2()); }",
            "\t// angle to x-axis in interval [-pi, pi]",
            "\tdouble angle() const { return atan2(y, x); }",
            "\tP unit() const { return *this / dist(); } // makes dist()=1",
            "\tP perp() const { return P(-y, x); } // rotates +90 degrees",
            "\tP normal() const { return perp().unit(); }",
            "\t// returns point rotated 'a' radians ccw around the origin",
            "\tP rotate(double a) const {",
            "\t\treturn P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); ",
            "\t}",
            "\tfriend ostream& operator<<(ostream& os, P p) {",
            "\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; ",
            "\t}",
            "};"
        ]
    },
	"manacher": {
        "prefix": "manacher",
        "body": [
            "// res[0][i] = half length of longest even palindrome around pos i (n + 1 elements) ",
            "// res[1][i] = half length of longest odd palindrome around index i rounded down (n elements)",
            "template<class T>",
            "array<vi, 2> manacher(const T& s) {",
            "\tint n = size(s);",
            "\tarray<vi,2> p = {vi(n+1), vi(n)};",
            "\tFOR (z,  2) for (int i = 0, l = 0, r = 0; i < n; i++) {",
            "\t\tint t = r - i + !z;",
            "\t\tif (i < r) p[z][i] = min(t, p[z][l + t]);",
            "\t\tint L = i - p[z][i], R = i + p[z][i] - !z;",
            "\t\twhile (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1])",
            "\t\t\tp[z][i]++, L--, R++;",
            "\t\tif (R > r) l = L, r = R;",
            "\t}",
            "\treturn p;",
            "}"
        ]
    },
    "hash": {
        "prefix": "hash",
        "body": [
            "// skip the stuff that starts with r if you dont care about reverse functions",
            "struct H {",
            "\tull x; H(ull x = 0) : x(x) {}",
            "\tH operator+(H o) { return x + o.x + (x + o.x < x); }",
            "\tH operator-(H o) { return *this + ~o.x; }",
            "\tH operator*(H o) { auto m = (__uint128_t) x * o.x;",
            "\t\treturn H((ull) m) + (ull)(m >> 64); }",
            "\tull get() const { return x + !~x; }",
            "\tbool operator==(H o) const { return get() == o.get(); }",
            "\tbool operator<(H o) const { return get() < o.get(); }",
            "};",
            "",
            "static const H C = (ll) 1e11 + 3; // (order ~ 3e9; random also ok)",
            "",
            "struct HashInterval {",
            "\tvector<H> ha, pw, rha; ",
            "\ttemplate<class T>",
            "\tHashInterval(T& str) : ha(size(str) + 1), pw(ha), rha(ha) {",
            "\t\tpw[0] = 1;",
            "\t\tFOR (i, size(str)) {",
            "\t\t\tha[i + 1] = ha[i] * C + str[i] + 1;",
            "\t\t\tpw[i + 1] = pw[i] * C;",
            "\t\t}",
            "\t\tROF (i, size(str)) rha[i] = rha[i + 1] * C + str[i] + 1;",
            "\t}",
            "\tH hash_interval(int a, int b) { // hash [a, b)",
            "\t\treturn ha[b] - ha[a] * pw[b - a];",
            "\t}",
            "\tH rhash_interval(int a, int b) { // hash [a, b) but from right to left",
            "\t\treturn rha[a] - rha[b] * pw[b - a];",
            "\t}",
            "};",
            "",
            "// get all hashes of length <len>",
            "template<class T>",
            "vector<H> get_hashes(T& str, int length) {",
            "\tif (size(str) < length) return {};",
            "\tH h = 0, pw = 1;",
            "\tFOR (i, length) h = h * C + str[i] + 1, pw = pw * C;",
            "\tvector<H> ret = {h};",
            "\tFOR (i, length, size(str)) {",
            "\t\tret.push_back(h = h * C + str[i] + 1 - pw * (str[i - length] + 1));",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "template<class T>",
            "H hash_string(T& s) { H h = 1; for (auto c : s) h = h * C + c + 1; return h; }"
        ]
    },
    "pushrelabel": {
        "prefix": "pushrelabel",
        "body": [
            "// O(VE sqrt E)",
            "",
            "template<typename flow_t = long long>",
            "struct PushRelabel {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tflow_t f, c;",
            "\t};",
            "\tvt<vt<Edge> > g;",
            "\tvt<flow_t> ec;",
            "\tvt<Edge*> cur;",
            "\tvt<vt<int> > hs;",
            "\tvt<int> h;",
            "",
            "\tvoid init(int n) {",
            "\t\tg.resize(n);",
            "\t\tec.resize(n);",
            "\t\tcur.resize(n);",
            "\t\ths.resize(2 * n);",
            "\t\th.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int s, int t, flow_t cap, flow_t rcap = 0) {",
            "\t\tif (s == t) return;",
            "\t\tEdge a = {t, size(g[t]), 0, cap};",
            "\t\tEdge b = {s, size(g[s]), 0, rcap};",
            "\t\tg[s].push_back(a);",
            "\t\tg[t].push_back(b);",
            "\t}",
            "\tvoid add_flow(Edge& e, flow_t f) {",
            "\t\tEdge &back = g[e.to][e.rev];",
            "\t\tif (!ec[e.to] && f)",
            "\t\t\ths[h[e.to]].push_back(e.to);",
            "\t\te.f += f; e.c -= f;",
            "\t\tec[e.to] += f;",
            "\t\tback.f -= f; back.c += f;",
            "\t\tec[back.to] -= f;",
            "\t}",
            "\tflow_t calc(int s, int t) {",
            "\t\tint v = size(g);",
            "\t\th[s] = v;",
            "\t\tec[t] = 1;",
            "\t\tvt<int> co(2 * v);",
            "\t\tco[0] = v - 1;",
            "\t\tfor(int i=0;i<v;++i) cur[i] = g[i].data();",
            "\t\tfor(auto &e:g[s]) add_flow(e, e.c);",
            "\t\tif(size(hs[0]))",
            "\t\tfor (int hi = 0; hi>=0; ) {",
            "\t\t\tint u = hs[hi].back();",
            "\t\t\ths[hi].pop_back();",
            "\t\t\twhile (ec[u] > 0) // discharge u",
            "\t\t\t\tif (cur[u] == g[u].data() + size(g[u])) {",
            "\t\t\t\t\th[u] = 1e9;",
            "\t\t\t\t\tfor(auto &e : g[u])",
            "\t\t\t\t\t\tif (e.c && h[u] > h[e.to] + 1)",
            "\t\t\t\t\t\t\th[u] = h[e.to] + 1, cur[u] = &e;",
            "\t\t\t\t\tif (++co[h[u]], !--co[hi] && hi < v)",
            "\t\t\t\t\t\tfor (int i=0; i<v; ++i)",
            "\t\t\t\t\t\t\tif (hi < h[i] && h[i] < v){",
            "\t\t\t\t\t\t\t\t--co[h[i]];",
            "\t\t\t\t\t\t\t\th[i] = v + 1;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\thi = h[u];",
            "\t\t\t\t} else if (cur[u]->c && h[u] == h[cur[u]->to] + 1)",
            "\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));",
            "\t\t\t\telse ++cur[u];",
            "\t\t\twhile (hi>=0 && hs[hi].empty()) --hi;",
            "\t\t}",
            "\t\treturn -ec[s];",
            "\t}",
            "\tbool leftOfMinCut(int a) { return h[a] >= sz(g); }",
            "};"
        ]
    },
    "mcmf": {
        "prefix": "mcmf",
        "body": [
            "struct MCMF {",
            "\tstruct edge {",
            "\t\tint from, to, rev;",
            "\t\tll cap, cost, flow;",
            "\t};",
            "\tint N;",
            "\tvt<vt<edge>> ed;",
            "\tvt<int> seen;",
            "\tvt<ll> dist, pi;",
            "\tvt<edge*> par;",
            "",
            "\tMCMF(int N) : N(N), ed(N), seen(N), dist(N), pi(N), par(N) {}",
            "",
            "\tvoid ae(int from, int to, ll cap, ll cost) {",
            "\t\tif (from == to) return;",
            "\t\ted[from].push_back(edge{ from, to, size(ed[to]), cap,cost,  0 });",
            "\t\ted[to].push_back(edge{ to,  from, size(ed[from]) - 1,  0, -cost, 0 });",
            "\t}",
            "",
            "\tvoid path(int s) {",
            "\t\tfill(all(seen), 0);",
            "\t\tfill(all(dist), INF);",
            "\t\tdist[s] = 0; ll di;",
            "",
            "\t\t__gnu_pbds::priority_queue<pair<ll, int>> q;",
            "\t\tvt<decltype(q)::point_iterator> its(N);",
            "\t\tq.push({ 0, s });",
            "",
            "\t\twhile (!q.empty()) {",
            "\t\t\ts = q.top().second; q.pop();",
            "\t\t\tseen[s] = 1; di = dist[s] + pi[s];",
            "\t\t\tfor (edge& e : ed[s]) if (!seen[e.to]) {",
            "\t\t\t\tll val = di - pi[e.to] + e.cost;",
            "\t\t\t\tif (e.cap - e.flow > 0 && val < dist[e.to]) {",
            "\t\t\t\t\tdist[e.to] = val;",
            "\t\t\t\t\tpar[e.to] = &e;",
            "\t\t\t\t\tif (its[e.to] == q.end())",
            "\t\t\t\t\t\tits[e.to] = q.push({ -dist[e.to], e.to });",
            "\t\t\t\t\telse",
            "\t\t\t\t\t\tq.modify(its[e.to], { -dist[e.to], e.to });",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tFOR (i, N) pi[i] = min(pi[i] + dist[i], INF);",
            "\t}",
            "",
            "\tpair<ll, ll> maxflow(int s, int t) {",
            "\t\tll totflow = 0, totcost = 0;",
            "\t\twhile (path(s), seen[t]) {",
            "\t\t\tll fl = INF;",
            "\t\t\tfor (edge* x = par[t]; x; x = par[x->from])",
            "\t\t\t\tfl = min(fl, x->cap - x->flow);",
            "",
            "\t\t\ttotflow += fl;",
            "\t\t\tfor (edge* x = par[t]; x; x = par[x->from]) {",
            "\t\t\t\tx->flow += fl;",
            "\t\t\t\ted[x->to][x->rev].flow -= fl;",
            "\t\t\t}",
            "\t\t}",
            "\t\tFOR (i, N) for(edge& e : ed[i]) totcost += e.cost * e.flow;",
            "\t\treturn {totflow, totcost/2};",
            "\t}",
            "",
            "\t// If some costs can be negative, call this before maxflow:",
            "\tvoid setpi(int s) { // (otherwise, leave this out)",
            "\t\tfill(all(pi), INF); pi[s] = 0;",
            "\t\tint it = N, ch = 1; ll v;",
            "\t\twhile (ch-- && it--)",
            "\t\t\tFOR (i, N) if (pi[i] != INF)",
            "\t\t\t\tfor (edge& e : ed[i]) if (e.cap)",
            "\t\t\t\t\tif ((v = pi[i] + e.cost) < pi[e.to])",
            "\t\t\t\t\t\tpi[e.to] = v, ch = 1;",
            "\t\tassert(it >= 0); // negative cost cycle",
            "\t}",
            "};"
        ]
    },
    "kuhns": {
        "prefix": "kuhns",
        "body": [
            "int a, b; // # of nodes on left/right side respectively",
            "vt<vt<int>> adj;",
            "// add directed edges from lhs to rhs",
            " ",
            "vt<int> matched;",
            "vt<bool> seen;",
            " ",
            "int dfs(int cur) {",
            "\tif (seen[cur]) return false; ",
            "\tseen[cur] = true;",
            "\tfor (int nxt : adj[cur]){",
            "\t\tif (matched[nxt] == -1 || dfs(matched[nxt])) {",
            "\t\t\tmatched[nxt] = cur;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "\treturn false;",
            "}",
            " ",
            "int solve() {",
            "\tint flow = 0;",
            "\tmatched.assign(b, -1);",
            "\tFOR (i, a){",
            "\t\tseen.assign(a, false);",
            "\t\tflow += dfs(i);",
            "\t}",
            "\treturn flow;",
            "}"
        ]
    },
    "randmatching": {
        "prefix": "randmatching",
        "body": [
            "random_device rd;",
            "mt19937 rng(rd());",
            "",
            "struct MCM {",
            "\tint n, t = 0;",
            "\tvt<vt<int>> adj;",
            "\tvt<int> mate, last_seen;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t\tmate.resize(n + 1, n);",
            "\t\tlast_seen.resize(n + 1);",
            "\t}",
            "",
            "\tint dfs(int u) {",
            "\t\tlast_seen[u] = t;",
            "\t\tshuffle(all(adj[u]), rng);",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tint m = mate[v];",
            "\t\t\tif (last_seen[m] != t) {",
            "\t\t\t\tmate[u] = v, mate[v] = u, mate[m] = n;",
            "\t\t\t\tif (m == n || dfs(m)) return 1;",
            "\t\t\t\tmate[v] = m, mate[m] = v, mate[u] = n;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tif (u == v) return;",
            "\t\tadj[u].push_back(v);",
            "\t\tadj[v].push_back(u);",
            "\t}",
            "",
            "\tconst int MAGIC = 1; // make bigger if wa",
            "\tvt<pi> calc() {",
            "\t\tFOR (bad, MAGIC) {",
            "\t\t\tint found = 0;",
            "\t\t\tFOR (u, n) if (mate[u] == n) t++, found |= dfs(u);",
            "\t\t\tif (found) bad = 0;",
            "\t\t}",
            "\t\tvt<pi> out;",
            "\t\tFOR (i, n) {",
            "\t\t\tif (mate[i] < i) out.pb({mate[i], i});",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "};"
        ]
    },
    "2sat": {
        "prefix": "2sat",
        "body": [
            "struct SCC {",
            "\tll n; ",
            "\tvt<vt<ll>> adj, radj;",
            "\tvt<ll> todo, comp, comps; ",
            "\tvt<bool> seen;",
            "\tvoid init(ll _n) { ",
            "\t\tn = _n; ",
            "\t\tadj.resize(n);",
            "\t\tradj.resize(n);",
            "\t\tcomp = vt<ll>(n, -1);",
            "\t\tseen.resize(n); ",
            "\t}",
            "\tvoid ae(ll x, ll y) { adj[x].pb(y), radj[y].pb(x); }",
            "\tvoid dfs(ll x) {",
            "\t\tseen[x] = 1; ",
            "\t\tfor(ll y : adj[x]) if (!seen[y]) dfs(y);",
            "\t\ttodo.pb(x); ",
            "\t}",
            "\tvoid dfs2(ll x, ll v) {",
            "\t\tcomp[x] = v; ",
            "\t\tfor (ll y : radj[x]) if (comp[y] == -1) dfs2(y, v); ",
            "\t}",
            "\tvoid gen() {",
            "\t\tFOR (i, n) if (!seen[i]) dfs(i);",
            "\t\treverse(all(todo)); ",
            "\t\tfor (ll x : todo) if (comp[x] == -1) dfs2(x, x), comps.pb(x);",
            "\t}",
            "};",
            "",
            "using pi = pair<int, int>;",
            "",
            "struct TwoSAT {",
            "\tint n = 0; ",
            "\tvt<pi> edges;",
            "\tvoid init(int _n) { n = _n; }",
            "\tint add() { return n++; }",
            "\tvoid either(int x, int y) { // x | y",
            "\t\tx = max(2 * x, -1 - 2 * x); // ~(2 * x)",
            "\t\ty = max(2 * y, -1 - 2 * y); // ~(2 * y)",
            "\t\tedges.pb({x, y}); ",
            "\t}",
            "\tvoid implies(int x, int y) { either(~x, y); } // x -> y",
            "\tvoid force(int x) { either(x, x); } // x = true",
            "\tvoid exactly_one(int x, int y) { either(x, y), either(~x, ~y); } // xor",
            "\tvoid tie(int x, int y) { implies(x, y), implies(~x, ~y); } // x and y have the same value",
            "\tvoid nand(int x, int y ) { either(~x, ~y); } // x and y are not both true",
            "\tvoid at_most_one(const vt<int>& li) { // at most one of li is true",
            "\t\tif (size(li) <= 1) return;",
            "\t\tint cur = ~li[0];",
            "\t\tFOR (i, 2, size(li)) {",
            "\t\t\tint next = add();",
            "\t\t\teither(cur, ~li[i]); ",
            "\t\t\teither(cur,next);",
            "\t\t\teither(~li[i], next); ",
            "\t\t\tcur = ~next;",
            "\t\t}",
            "\t\teither(cur, ~li[1]);",
            "\t}",
            "\tvt<bool> solve() {",
            "\t\tSCC scc; ",
            "\t\tscc.init(2 * n);",
            "\t\tfor(auto& e : edges) {",
            "\t\t\tscc.ae(e.f ^ 1, e.s);",
            "\t\t\tscc.ae(e.s ^ 1, e.f);",
            "\t\t}",
            "\t\tscc.gen(); ",
            "\t\treverse(all(scc.comps)); // reverse topo order",
            "\t\tfor (int i = 0; i < 2 * n; i += 2) ",
            "\t\t\tif (scc.comp[i] == scc.comp[i ^ 1]) return {};",
            "\t\tvt<int> tmp(2 * n); ",
            "\t\tfor (auto i : scc.comps) {",
            "\t\t\tif (!tmp[i]) tmp[i] = 1, tmp[scc.comp[i ^ 1]] = -1;",
            "\t\t}",
            "\t\tvt<bool> ans(n); ",
            "\t\tFOR (i, n) ans[i] = tmp[scc.comp[2 * i]] == 1;",
            "\t\treturn ans;",
            "\t}",
            "};"
        ]
    },
    "bellmanford": {
        "prefix": "bellmanford",
        "body": [
            "struct BellmanFord {",
            "\tint n;",
            "\tvt<pair<pl, int>> edges;",
            "\tvt<ll> dist;",
            "\tvoid ae(int u, int v, int w) { ",
            "\t\tedges.pb({{u, v}, w}); ",
            "\t}",
            "\t// returns if there is a negative cycle",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tn = _n; ",
            "\t\tdist.resize(n, INF);",
            "\t}",
            "\tbool gen(int s = 0) {",
            "\t\tdist[s] = 0;",
            "\t\tFOR (i, n) {",
            "\t\t\tfor (auto& a : edges) {",
            "\t\t\t\tif (dist[a.f.f] < INF) {",
            "\t\t\t\t\tdist[a.f.s] = min(dist[a.f.s], dist[a.f.f] + a.s);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (auto& a : edges) {",
            "\t\t\tif (dist[a.f.f] < INF && dist[a.f.s] > dist[a.f.f] + a.s) {",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "};"
        ]
    },
    "floydwarshall": {
        "prefix": "floydwarshall",
        "body": [
            "FOR (k, n) FOR (i, n) FOR (j, n) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);"
        ]
    },
    "floydwarshallsafe": {
        "prefix": "floydwarshallsafe",
        "body": [
            "void apsp(vt<vt<ll>> &m) {",
            "\tint n = size(m);",
            "\tFOR (i, n) m[i][i] = min(m[i][i], 0ll);",
            "\tFOR (k, n) FOR(i, n) FOR(j, n)",
            "\t\tif (m[i][k] != INF && m[k][j] != INF) {",
            "\t\t\tauto newDist = max(m[i][k] + m[k][j], -INF);",
            "\t\t\tm[i][j] = min(m[i][j], newDist);",
            "\t\t}",
            "\tFOR (k, n) if (m[k][k] < 0) FOR (i, n) FOR(j, n)",
            "\t\tif (m[i][k] != INF && m[k][j] != INF) m[i][j] = -INF;",
            "}"
        ]
    },
    "topsort": {
        "prefix": "topsort",
        "body": [
            "int n;",
            "vt<bool> seen;",
            "vt<int> top;",
            "",
            "void dfs(int u) {",
            "\tif (seen[u]) return;",
            "\tseen[u] = true;",
            "\tfor (int v : adj[u]) dfs(v);",
            "\ttop.pb(u);",
            "}",
            "",
            "void topsort() {",
            "\tseen.assign(n, 0);",
            "\tFOR (u, n) dfs(u);",
            "\treverse(all(top)); // reverse to make edges point to the right",
            "}"
        ]
    },
    "topsort": {
        "prefix": "topsort",
        "body": [
            "ll solve(int n, vt<vt<ll>>& cost) {",
            "\tvt<vt<ll>> dp(1 << n, vt<ll>(n, INF));",
            "",
            "\t// initialise starting states",
            "\tFOR (i, n) {",
            "\t\tdp[1 << i][i] = 0;",
            "\t}",
            "",
            "\t// iterative dp",
            "\tFOR (i, 1 << n) {",
            "\t\tFOR (j, n) {",
            "\t\t\tif (dp[i][j] == INF) continue; // skip infinity",
            "\t\t\tFOR (k, n) {",
            "\t\t\t\tif (i & (1 << k)) continue; // skip things already in bitmask",
            "\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + cost[j][k]); // push dp values",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// find minimum of all complete walks",
            "\tll ans = INF;",
            "\tFOR (i, n) {",
            "\t\tans = min(ans, dp[(1 << n) - 1][i]);",
            "\t}",
            "}"
        ]
    },
    "matrix": {
        "prefix": "matrix",
        "body": [
            "const ll MOD = 1e9 + 7;",
            "using Mat = vector<vector<ll>>;",
            "",
            "Mat make_mat(int r, int c) { return Mat(r, vector<ll>(c)); }",
            "Mat make_id(int n) { ",
            "\tMat m = make_mat(n, n); for (int i = 0; i < n; i++) m[i][i] = 1;",
            "\treturn m;",
            "}",
            "Mat operator*(const Mat& a, const Mat& b) {",
            "\tint x = size(a), y = size(a[0]), z = size(b[0]); ",
            "\tMat c = make_mat(x, z);",
            "\tfor (int i = 0; i < x; i++) for (int j = 0; j < y; j++) for (int k = 0; k < z; k++) c[i][k] = (c[i][k] + a[i][j] * b[j][k]) % MOD;",
            "\treturn c;",
            "}",
            "Mat& operator*=(Mat& a, const Mat& b) { return a = a * b; }",
            "Mat pow(Mat m, ll p) {",
            "\tint n = size(m); assert(n == size(m[0]) && p >= 0);",
            "\tMat res = make_id(n);",
            "\tfor (; p; p /= 2, m *= m) if (p & 1) res *= m;",
            "\treturn res;",
            "}",
            ""
        ]
    },
    "ntt": {
        "prefix": "ntt",
        "body": [
            "const ll mod = (119 << 23) + 1, root = 62; // = 998244353",
            "// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
            "// and 483 << 21 (same root). The last two are > 10^9.",
            "",
            "ll modpow(ll b, ll e) {",
            "\tll ans = 1;",
            "\tfor (; e; b = b * b % mod, e /= 2)",
            "\t\tif (e & 1) ans = ans * b % mod;",
            "\treturn ans;",
            "}",
            "",
            "template<class T>",
            "void ntt(vt<T> &a) {",
            "\tint n = size(a), L = 31 - __builtin_clz(n);",
            "\tstatic vt<ll> rt(2, 1);",
            "\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {",
            "\t\trt.resize(n);",
            "\t\tll z[] = {1, modpow(root, mod >> s)};",
            "\t\tFOR (i, k, 2 * k) rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "\t}",
            "\tvt<int> rev(n);",
            "\tFOR (i, 0, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\tFOR (i, 0, n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) FOR (j, 0, k) {",
            "\t\t\tT z = (ll) rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "\t\t\tai += (ai + z >= mod ? z - mod : z);",
            "\t\t}",
            "}",
            "",
            "template<class T>",
            "vt<T> conv(const vt<T> &a, const vt<T> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tint s = (int) size(a) + size(b) - 1, B = 32 - __builtin_clz(s),",
            "\t\tn = 1 << B;",
            "\tint inv = modpow(n, mod - 2);",
            "\tvt<T> L(a), R(b), out(n);",
            "\tL.resize(n), R.resize(n);",
            "\tntt(L), ntt(R);",
            "\tFOR (i, 0, n) out[-i & (n - 1)] = (ll) L[i] * R[i] % mod * inv % mod;",
            "\tntt(out);",
            "\treturn {out.begin(), out.begin() + s};",
            "}"
        ]
    },
    "fft": {
        "prefix": "fft",
        "body": [
            "// remember to add 0.5 before casting to int dumbass",
            "typedef complex<double> C;",
            "typedef vector<double> vd;",
            "void fft(vector<C>& a) {",
            "\tint n = size(a), L = 31 - __builtin_clz(n);",
            "\tstatic vector<complex<long double>> R(2, 1);",
            "\tstatic vector<C> rt(2, 1);  // (^ 10% faster if double) (wtf does this mean?)",
            "\tfor (static int k = 2; k < n; k *= 2) {",
            "\t\tR.resize(n); ",
            "\t\trt.resize(n);",
            "\t\tauto x = polar(1.0L, acos(-1.0L) / k);",
            "\t\tFOR (i, k, 2 * k) rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];",
            "\t}",
            "\tvi rev(n);",
            "\tFOR (i, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\tFOR (i, n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) FOR (j, 0, k) {",
            "\t\t\tauto x = (double *) &rt[j + k], y = (double *) &a[i + j + k];",
            "\t\t\tC z(x[0] * y[0] - x[1] * y[1], x[0] * y[1] + x[1] * y[0]);",
            "\t\t\ta[i + j + k] = a[i + j] - z;",
            "\t\t\ta[i + j] += z;",
            "\t\t}",
            "}",
            "",
            "vd conv(const vd& a, const vd& b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvd res(size(a) + size(b) - 1);",
            "\tint L = 32 - __builtin_clz(size(res)), n = 1 << L;",
            "\tvector<C> in(n), out(n);",
            "\tcopy(all(a), begin(in));",
            "\tFOR (i, size(b)) in[i].imag(b[i]);",
            "\tfft(in);",
            "\tfor (C &x : in) x *= x;",
            "\tFOR (i, n) out[i] = in[-i & (n - 1)] - conj(in[i]);",
            "\tfft(out);",
            "\tFOR (i, size(res)) res[i] = imag(out[i]) / (4 * n);",
            "\treturn res;",
            "}",
            "",
            "// inputs [0, mod)",
            "// N log_2(N) * mod < 8.6e14 (in practice 1e16+)",
            "template<ll mod, class T> vt<T> convMod(const vt<T> &a, const vt<T> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvt<T> res(size(a) + size(b) - 1);",
            "\tint B = 32 - __builtin_clz(size(res)), n = 1 << B, cut = int(sqrt(mod));",
            "\tvector<C> L(n), R(n), outs(n), outl(n);",
            "\tFOR (i, size(a)) L[i] = C((int) a[i] / cut, (int) a[i] % cut);",
            "\tFOR (i, size(b)) R[i] = C((int) b[i] / cut, (int) b[i] % cut);",
            "\tfft(L), fft(R);",
            "\tFOR (i, n) {",
            "\t\tint j = -i & (n - 1);",
            "\t\toutl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
            "\t\touts[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
            "\t}",
            "\tfft(outl), fft(outs);",
            "\tFOR (i, size(res)) {",
            "\t\tll av = ll(real(outl[i]) + 0.5), cv = ll(imag(outs[i]) + 0.5);",
            "\t\tll bv = ll(imag(outl[i]) + 0.5) + ll(real(outs[i]) + 0.5);",
            "\t\tres[i] = ((av % mod * cut + bv) % mod * cut + cv) % mod;",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "centroiddecomp": {
        "prefix": "centroiddecomp",
        "body": [
            "int n;",
            "vt<vt<ll>> adj;",
            "vt<bool> done;",
            "vt<vt<pl>> pars;",
            "vt<int> sz;",
            "",
            "int dfs_sz(int u, int p = -1) {",
            "\tsz[u] = 1;",
            "\tfor (int v : adj[u]) {",
            "\t\t\t\tif (v == p || done[v]) continue;",
            "\t\tsz[u] += dfs_sz(v, u);",
            "\t}",
            "\treturn sz[u];",
            "}",
            "",
            "int find_centroid(int u, int tsz, int p = -1) {",
            "\tfor (int v : adj[u]) {",
            "\t\tif (v == p || done[v]) continue;",
            "\t\tif (sz[v] * 2 > tsz) return find_centroid(v, tsz, u);",
            "\t}",
            "\treturn u;",
            "}",
            "",
            "// calculates {centroid, distance} pairs for each node",
            "void process(int u, int r, int d, int par = -1) {",
            "\tpars[u].pb({r, d});",
            "\tfor (int v : adj[u]) {",
            "\t\tif (v != par && !done[v]) process(v, r, d + 1, u);",
            "\t}",
            "}",
            "",
            "void decomp(int u = 0) {",
            "\tu = find_centroid(u, dfs_sz(u)); // keep in mind subtree sizes are not correct after this",
            "\t// do stuff",
            "\tprocess(u, u, 0);",
            "\t// end stuff",
            "\tdone[u] = true;",
            "\tfor (int v : adj[u]) {",
            "\t\tif (!done[v]) decomp(v);",
            "\t}",
            "}"
        ]
    },
    "hungarian": {
        "prefix": "hungarian",
        "body": [
            "// n^2 m",
            "// negate costs for max",
            "// returns {min_cost, match[]}",
            "pair<int, vi> hungarian(const vector<vi> &a) {",
            "\tif (a.empty()) return {0, {}};",
            "\tint n = size(a) + 1, m = size(a[0]) + 1;",
            "\tvi u(n), v(m), p(m), ans(n - 1);",
            "\tFOR (i, 1, n) {",
            "\t\tp[0] = i;",
            "\t\tint j0 = 0; // add \"dummy\" worker 0",
            "\t\tvi dist(m, INT_MAX), pre(m, -1);",
            "\t\tvector<bool> done(m + 1);",
            "\t\tdo { // dijkstra",
            "\t\t\tdone[j0] = true;",
            "\t\t\tint i0 = p[j0], j1, delta = INT_MAX;",
            "\t\t\tFOR (j, 1, m) if (!done[j]) {",
            "\t\t\t\tauto cur = a[i0 - 1][j - 1] - u[i0] - v[j];",
            "\t\t\t\tif (cur < dist[j]) dist[j] = cur, pre[j] = j0;",
            "\t\t\t\tif (dist[j] < delta) delta = dist[j], j1 = j;",
            "\t\t\t}",
            "\t\t\tFOR (j, m) {",
            "\t\t\t\tif (done[j]) u[p[j]] += delta, v[j] -= delta;",
            "\t\t\t\telse dist[j] -= delta;",
            "\t\t\t}",
            "\t\t\tj0 = j1;",
            "\t\t} while (p[j0]);",
            "\t\twhile (j0) { // update alternating path",
            "\t\t\tint j1 = pre[j0];",
            "\t\t\tp[j0] = p[j1], j0 = j1;",
            "\t\t}",
            "\t}",
            "\tFOR (j, 1, m) if (p[j]) ans[p[j] - 1] = j - 1;",
            "\treturn {-v[0], ans}; // min cost",
            "}"
        ]
    },
    "hld": {
        "prefix": "hld",
        "body": [
            "struct SegTree {",
            "\tint n;",
            "\tvt<int> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n);",
            "\t}",
            "\tint query(int i, int balls) {",
            "\t\tint sum = 0;",
            "\t\tfor (i += n; i > 0; i /= 2) sum += seg[i];",
            "\t\treturn sum;",
            "\t}",
            "\tvoid upd(int l, int r, int v) {",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) seg[l++] += v;",
            "\t\t\tif (r & 1) seg[--r] += v;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "template<bool in_edges> struct HLD {",
            "\tint n;",
            "\tvt<vt<int>> adj;",
            "\tvt<int> par, root, depth, size, pos;",
            "\tint time;",
            "\tSegTree tree;",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "\tvoid dfs_sz(int u) {",
            "\t\tsize[u] = 1;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\tpar[v] = u;",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs_sz(v);",
            "\t\t\tsize[u] += size[v];",
            "\t\t\tif (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfs_hld(int u) {",
            "\t\tpos[u] = time++;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\troot[v] = (v == adj[u][0] ? root[u] : v);",
            "\t\t\tdfs_hld(v);",
            "\t\t}",
            "\t}",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t\tpar = root = depth = size = pos = vt<int>(n);",
            "\t}",
            "\tvoid gen(int r = 0) {",
            "\t\tpar[r] = depth[r] = time = 0;",
            "\t\tdfs_sz(r);",
            "\t\troot[r] = r;",
            "\t\tdfs_hld(r);",
            "\t\ttree.init(n);",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "\ttemplate <class Op>",
            "\tvoid process(int u, int v, Op op) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\top(pos[root[v]], pos[v] + 1);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + in_edges, pos[v] + 1);",
            "\t}",
            "\tvoid upd(int u, int v, ll upd) {",
            "\t\tprocess(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });",
            "\t}",
            "\tll query(int u, int v) {",
            "\t\tll res = 0;",
            "\t\tprocess(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "lazyhld": {
        "prefix": "lazyhld",
        "body": [
            "struct Lazy {",
            "\tll v;",
            "\tbool inc;",
            "\tvoid operator+=(const Lazy &b) {",
            "\t\tif (b.inc) v += b.v;",
            "\t\telse v = b.v, inc = false;",
            "\t}",
            "};",
            " ",
            "struct Node {",
            "\tll mx, sum;",
            "\tNode operator+(const Node &b) {",
            "\t\treturn {max(mx, b.mx), sum + b.sum};",
            "\t}",
            "\tvoid upd(const Lazy &u, int l, int r) {",
            "\t\tif (!u.inc) mx = sum = 0;",
            "\t\tmx += u.v, sum += u.v * (r - l);",
            "\t}",
            "};",
            "",
            "const Lazy LID = {0, true};",
            "const Node NID = {-INF, 0};",
            " ",
            "struct LazySeg { ",
            "\tint n;",
            "\tvt<Node> seg;",
            "\tvt<Lazy> lazy;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n, NID);",
            "\t\tlazy.resize(2 * n, LID);",
            "\t}",
            "\tvoid pull(int i) {",
            "\t\tseg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tvoid push(int i, int l, int r) {",
            "\t\tseg[i].upd(lazy[i], l, r);",
            "\t\tif (r - l > 1) FOR (j, 2) lazy[2 * i + j] += lazy[i];",
            "\t\tlazy[i] = LID;",
            "\t}",
            "\tvoid build() {",
            "\t\tfor (int i = n - 1; i > 0; i--) pull(i);",
            "\t}",
            "\tvoid upd(int lo, int hi, Lazy val) { upd(lo, hi, val, 1, 0, n); }",
            "\tvoid upd(int lo, int hi, Lazy val, int i, int l, int r) {",
            "\t\tif (r == -1) r = n;",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy[i] += val;",
            "\t\t\tpush(i, l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tupd(lo, hi, val, 2 * i, l, m);",
            "\t\tupd(lo, hi, val, 2 * i + 1, m, r);",
            "\t\tpull(i);",
            "\t}",
            "\tNode query() { return query(0, n, 1, 0, n); }",
            "\tNode query(int lo, int hi) { return query(lo, hi, 1, 0, n); }",
            "\tNode query(int lo, int hi, int i, int l, int r) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return NID;",
            "\t\tif (lo <= l && r <= hi) return seg[i];",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m, r);",
            "\t}",
            "\tNode& operator[](int i) {",
            "\t\treturn seg[i + n];",
            "\t}",
            "};",
            "",
            "template<bool in_edges> struct HLD { ",
            "\tint n, time;",
            "\tvt<vt<int>> adj;",
            "\tvt<int> par, root, depth, sz, pos;",
            "\tLazySeg tree;",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "\tvoid dfs_sz(int u) {",
            "\t\tsz[u] = 1;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\tpar[v] = u;",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs_sz(v);",
            "\t\t\tsz[u] += sz[v];",
            "\t\t\tif (sz[v] > sz[adj[u][0]]) swap(v, adj[u][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfs_hld(int u) {",
            "\t\tpos[u] = time++;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\troot[v] = (v == adj[u][0] ? root[u] : v);",
            "\t\t\tdfs_hld(v);",
            "\t\t}",
            "\t}",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tint tsz;",
            "\t\tfor (tsz = 1; tsz < n; tsz *= 2);",
            "\t\ttree.init(tsz);",
            "\t\tadj.resize(n);",
            "\t\tpar = root = depth = sz = pos = vt<int>(n);",
            "\t}",
            "\tvoid gen(int r = 0) {",
            "\t\tpar[r] = depth[r] = time = 0;",
            "\t\tdfs_sz(r);",
            "\t\troot[r] = r;",
            "\t\tdfs_hld(r);",
            "\t\ttree.init(n);",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "",
            "\ttemplate <class Op>",
            "\tvoid process(int u, int v, Op op) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\top(pos[root[v]], pos[v] + 1);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + in_edges, pos[v] + 1);",
            "\t}",
            "\tvoid upd(int u, int v, Lazy upd) {",
            "\t\tprocess(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });",
            "\t}",
            "\tNode query(int u, int v) {",
            "\t\tNode res = NID;",
            "\t\tprocess(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });",
            "\t\treturn res;",
            "\t}",
            "\tvoid upd_subtree(int u, Lazy upd) {",
            "\t\ttree.upd(pos[u] + in_edges, pos[u] + sz[u], upd);",
            "\t}",
            "\tNode query_subtree(int u) {",
            "\t\treturn tree.query(pos[u] + in_edges, pos[u] + sz[u]);",
            "\t}",
            "};"
        ]
    },
    "liftlca": {
        "prefix": "liftlca",
        "body": [
            "struct BinaryLifting {",
            "\tint n, r; ",
            "\tvt<vt<int>> adj; ",
            "\tvt<int> par, jmp, depth;",
            "\tvoid init(int _n) {  ",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t\tpar = jmp = depth = vt<int>(n);",
            "\t}",
            "\tvoid ae(int u, int v, ll w = 1) { adj[u].pb(v), adj[v].pb(u); }",
            "\tvoid gen(int _r = 0) { r = _r, par[r] = jmp[r] = r; dfs(r); }",
            "\tvoid dfs(int u = 0) {",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tpar[v] = u;",
            "\t\t\tif (depth[jmp[jmp[u]]] + depth[u] == 2 * depth[jmp[u]]) jmp[v] = jmp[jmp[u]];",
            "\t\t\telse jmp[v] = u;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs(v);",
            "\t\t}",
            "\t}",
            "\tint lift(int u, int d) {",
            "\t\tif (d == 0) return r;",
            "\t\twhile (depth[par[u]] >= d) {",
            "\t\t\tif (depth[jmp[u]] >= d) u = jmp[u];",
            "\t\t\telse u = par[u];",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tif (depth[u] < depth[v]) swap(u, v);",
            "\t\tu = lift(u, depth[v]); ",
            "\t\tif (u == v) return u;",
            "\t\twhile (u != v) {",
            "\t\t\tif (jmp[u] != jmp[v]) u = jmp[u], v = jmp[v];",
            "\t\t\telse u = par[u], v = par[v];",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "\tint dist(int u, int v) { // # of edges on path",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};",
            ""
        ]
    },
    "rmqlca": {
        "prefix": "rmqlca",
        "body": [
            "template<class T> struct RMQ {",
            "\tvt<vt<T>> dp;",
            "\tvoid init(const vt<T>& v) {",
            "\t\tdp.resize(32 - __builtin_clz(size(v)), vt<T>(size(v)));",
            "\t\tcopy(all(v), begin(dp[0]));",
            "\t\tfor (int j = 1; 1 << j <= size(v); ++j) {",
            "\t\t\tFOR (i, size(v) - (1 << j) + 1) dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l + 1);",
            "\t\treturn min(dp[d][l], dp[d][r - (1 << d) + 1]); ",
            "\t}",
            "};",
            "",
            "struct LCA {",
            "\tint n; ",
            "\tvt<vt<int>> adj;",
            "\tvt<int> depth, pos, par; // rev is for compress",
            "\tvt<pl> tmp; ",
            "\tRMQ<pl> r;",
            "\tvoid init(int _n) { ",
            "\t\tn = _n; ",
            "\t\tadj.resize(n); ",
            "\t\tdepth = pos = par = vt<int>(n); ",
            "\t}",
            "\tvoid ae(int x, int y) { ",
            "\t\tadj[x].pb(y), adj[y].pb(x); ",
            "\t}",
            "\tvoid dfs(int x) {",
            "\t\tpos[x] = size(tmp); ",
            "\t\ttmp.pb({depth[x], x}); ",
            "\t\tfor(int y : adj[x]) ",
            "\t\t\tif (y != par[x]) {",
            "\t\t\t\tdepth[y] = depth[par[y] = x] + 1, dfs(y);",
            "\t\t\t\ttmp.pb({depth[x], x}); ",
            "\t\t\t}",
            "\t}",
            "\tvoid gen(int R = 0) { ",
            "\t\tpar[R] = R; ",
            "\t\tdfs(R); r.init(tmp); ",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tu = pos[u], v = pos[v]; ",
            "\t\tif (u > v) swap(u,v);",
            "\t\treturn r.query(u,v).s;",
            "\t}",
            "\tint dist(int u, int v) {",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};"
        ]
    },
    "virtualtree": {
        "prefix": "virtualtree",
        "body": [
            "// pos is dfs time",
            "vt<pl> virtual_tree(vt<ll>& nodes) { // pairs of {ancestor, child}",
            "\tauto cmp = [&] (ll u, ll v) { return pos[u] < pos[v]; };",
            "\tsort(all(nodes), cmp);",
            "\tint sz = size(nodes);",
            "\tFOR (i, sz - 1) nodes.pb(lca(nodes[i], nodes[i + 1]));",
            "\tsort(all(nodes), cmp);",
            "\tnodes.erase(unique(all(nodes)), nodes.end());",
            "\tvt<pl> res;",
            "\tFOR (i, (int) size(nodes) - 1) res.pb({lca(nodes[i], nodes[i + 1]), nodes[i + 1]});",
            "\treturn res;",
            "}"
        ]
    },
    "bit": {
        "prefix": "bit",
        "body": [
            "struct BIT {",
            "\tint n; vt<ll> arr;",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tarr.resize(n);",
            "\t}",
            "\t// 1-indexed",
            "\tll sum(int r) {",
            "\t\tll s = 0;",
            "\t\twhile (r) {",
            "\t\t\ts += arr[r - 1];",
            "\t\t\tr -= r & -r;",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "\t// public",
            "\tvoid add(int p, ll x) {",
            "\t\tfor (++p; p <= n; p += p & -p) arr[p - 1] += x;",
            "\t}",
            "\tll sum(int l, int r) { // inc exc",
            "\t\treturn sum(r) - sum(l);",
            "\t}",
            "\t\t// optional",
            "\tint lower_bound(ll sum) {",
            "\t\tif (sum <= 0) return -1;",
            "\t\tint pos = 0;",
            "\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {",
            "\t\t\tint npos = pos + pw;",
            "\t\t\tif (npos <= n && arr[npos - 1] < sum)",
            "\t\t\t\tpos = npos, sum -= arr[pos - 1];",
            "\t\t}",
            "\t\treturn pos;",
            "\t}",
            "};"
        ]
    },
    "treap": {
        "prefix": "treap",
        "body": [
            "// https://caterpillow.github.io/byot"
        ]
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "",
            "struct Sieve {",
            "\tvb is_prime;",
            "\tvi primes;",
            "\tvoid calc(int n) {",
            "\t\tis_prime.rsz(n, 1);",
            "\t\tis_prime[0] = is_prime[1] = 0;",
            "\t\tfor (int i = 4; i < n; i += 2) is_prime[i] = 0;",
            "\t\tfor (int i = 3; i * i < n; i += 2) {",
            "\t\t\tif (is_prime[i]) {",
            "\t\t\t\tfor (int j = i * i; j < n; j += i * 2) is_prime[j] = 0;",
            "\t\t\t}",
            "\t\t}",
            "\t\tFOR (i, n) if (is_prime[i]) primes.pb(i);",
            "\t}",
            "};"
        ]
    },
    "primefactor": {
        "prefix": "primefactor",
        "body": [
            "template<class T>",
            "vt<pair<T, int>> prime_factor(T x) {",
            "\tvt<pair<T, int>> ret;",
            "\tfor (T i = 2; i * i <= x; i++) {",
            "\t\tif (x % i == 0) {",
            "\t\t\tint p = 0;",
            "\t\t\twhile (x % i == 0) x /= i, p++;",
            "\t\t\tret.pb({i, p});",
            "\t\t}",
            "\t}",
            "\tif (x > 1) ret.eb(x, 1);",
            "\treturn ret;",
            "}"
        ]
    },
    "factor": {
        "prefix": "factor",
        "body": [
            "template<class T>",
            "vt<T> factor(T x) {",
            "\tvt<T> factors;",
            "\tfor (T i = 1; i * i <= x; i++) {",
            "\t\tif (x % i == 0) {",
            "\t\t\tfactors.pb(i);",
            "\t\t\tif (i * i != x) factors.pb(x / i);",
            "\t\t}",
            "\t}",
            "\treturn factors;",
            "}"
        ]
    },
    "pollard": {
        "prefix": "pollard",
        "body": [
            "using ul = unsigned long long;",
            "",
            "ul mod_mul(ul a, ul b, const ul mod) {",
            "\tll ret = a * b - mod * (ul) ((db) a * b / mod);",
            "\treturn ret + ((ret < 0) - (ret >= (ll) mod)) * mod; ",
            "}",
            "ul mod_pow(ul a, ul b, const ul mod) {",
            "\tif (b == 0) return 1;",
            "\tul res = mod_pow(a, b / 2, mod); ",
            "\tres = mod_mul(res, res, mod);",
            "\treturn b & 1 ? mod_mul(res, a,mod) : res;",
            "}",
            " ",
            "bool prime(ul n) { // not ll!",
            "\tif (n < 2 || n % 6 % 4 != 1) return n - 2 < 2;",
            "\tul A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},",
            "\t\ts = __builtin_ctzll(n - 1), d = n >> s;",
            "\tfor (auto a : A) {   // ^ count trailing zeroes",
            "\t\tul p = mod_pow(a, d, n), i = s;",
            "\t\twhile (p != 1 && p != n - 1 && a % n && i--) p = mod_mul(p, p, n);",
            "\t\tif (p != n - 1 && i != s) return 0;",
            "\t}",
            "\treturn 1;",
            "}",
            " ",
            "ul pollard(ul n) { // return some nontrivial factor of n",
            "\tif (n % 2 == 0) return 2;",
            "\tauto f = [n](ul x) { return mod_mul(x, x, n) + 1; };",
            "\tul x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
            "\twhile (t++ % 40 || gcd(prd, n) == 1) { /// speedup: don't take gcd every it",
            "\t\tif (x == y) x = ++i, y = f(x);",
            "\t\tif ((q = mod_mul(prd, max(x,y) - min(x, y), n))) prd = q;",
            "\t\tx = f(x), y = f(f(y));",
            "\t}",
            "\treturn gcd(prd, n);",
            "}",
            "",
            "void factor_rec(ul n, map<ul, int>& cnt) {",
            "\tif (n == 1) return;",
            "\tif (prime(n)) { ++cnt[n]; return; }",
            "\tul u = pollard(n);",
            "\tfactor_rec(u, cnt), factor_rec(n / u,cnt);",
            "}"
        ]
    },
    "euclid": {
        "prefix": "euclid",
        "body": [
            "// finds two integers x and y, such that ax + by = gcd(a, b)",
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a / b * x, d;",
            "}"
        ]
    },
    "xorbasis": {
        "prefix": "xorbasis",
        "body": [
            "ll reduce(vl& b, ll x) { ",
            "\teach(t, b) chmin(x, x ^ t);",
            "\treturn x; ",
            "}",
            "",
            "bool add(vl& b, ll x) {",
            "\tif (!(x = reduce(b, x))) return 0;",
            "\tint ind = 0; ",
            "\twhile (ind < size(b) && b[ind] > x) ind++;",
            "\tb.insert(begin(b) + ind, x); ",
            "\treturn 1;",
            "}"
        ]
    },
    "tmpbasic": {
        "prefix": "tmpbasic",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t",
            "\t$0",
            "}"
        ]
    },
    "tmpbasiccf": {
        "prefix": "tmpbasiccf",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t",
            "\tint t;",
            "\tcin >> t;",
            "\twhile (t--) solve();",
            "}"
        ]
    },
    "linsieve": {
        "prefix": "linseive",
        "body": [
            "struct Sieve {",
            "\tvi lp, primes;",
            "\tvoid calc(int n) {",
            "\t\tlp.rsz(n);",
            "\t\tFOR (i, 2, n) { ",
            "\t\t\tif (lp[i] == 0) lp[i] = i, primes.pb(i); ",
            "\t\t\tfor (int p : primes) {",
            "\t\t\t\tif (p > lp[i] || i * p >= n) break;",
            "\t\t\t\tlp[i * p] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid pfact(int x, vpi& out) {",
            "\t\tif (x == 1) return;",
            "\t\tif (out.empty() || out.back().f != lp[x]) out.eb(lp[x], 1);",
            "\t\telse out.back().s++;",
            "\t\tpfact(x / lp[x], out);",
            "\t}",
            "};"
        ]
    },
    "factorn": {
        "prefix": "factorn",
        "body": [
            "struct FactorN {",
            "\tvvi facts;",
            "\tvoid calc(int n) {",
            "\t\tfacts.resize(n, {1});",
            "\t\tfor (int i = 2; i < n; i++) {",
            "\t\t\tfor (int j = 1; i * j < n; j++) {",
            "\t\t\t\tfacts[i * j].pb(i);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ]
    },
    "bigint": {
        "prefix": "bigint",
        "body": [
            "const int base = 1e9, base_digits = 9;",
            "struct bigint { // value == 0 is represented by empty z",
            "\tvi z; // digits",
            "\tint sign; // sign == 1 <==> value >= 0",
            "\tbigint() : sign(1) {} // sign == -1 <==> value < 0",
            "\tbigint(ll v) { *this = v; }",
            "\tbigint &operator=(ll v) {",
            "\t\tsign = v < 0 ? -1 : 1; v *= sign; // make v positive",
            "\t\tz.clear(); ",
            "\t\tfor (; v; v /= base) z.pb(v % base);",
            "\t\treturn *this;",
            "\t}",
            "\tbigint(const str &s) { read(s); } // add char by char",
            "",
            "\tbigint &operator+=(const bigint &other) {",
            "\t\t//dbg(\"ADDING\",*this,other,sign,other.sign);",
            "\t\tif (sign == other.sign) {",
            "\t\t\tfor (int i = 0, carry = 0; i < size(other.z) || carry; ++i) {",
            "\t\t\t\tif (i == size(z)) z.pb(0);",
            "\t\t\t\tz[i] += carry + (i < size(other.z) ? other.z[i] : 0);",
            "\t\t\t\tcarry = z[i] >= base; if (carry) z[i] -= base;",
            "\t\t\t}",
            "\t\t} else if (other != 0 /* prevent infinite loop */) *this -= -other;",
            "\t\treturn *this;",
            "\t}",
            "\tfriend bigint operator+(bigint a, const bigint &b) { return a += b; }",
            "\tbigint &operator-=(const bigint &other) {",
            "\t\tif (sign == other.sign) {",
            "\t\t\tif ((sign == 1 && *this >= other) || (sign == -1 && *this <= other)) {",
            "\t\t\t\tfor (int i = 0, carry = 0; i < size(other.z) || carry; ++i) {",
            "\t\t\t\t\tz[i] -= carry + (i < size(other.z) ? other.z[i] : 0);",
            "\t\t\t\t\tcarry = z[i] < 0; if (carry) z[i] += base;",
            "\t\t\t\t}",
            "\t\t\t\ttrim();",
            "\t\t\t} else { // result will change sign",
            "\t\t\t\t*this = other - *this;",
            "\t\t\t\tthis->sign = -this->sign;",
            "\t\t\t}",
            "\t\t} else *this += -other;",
            "\t\treturn *this;",
            "\t}",
            "\tfriend bigint operator-(bigint a, const bigint &b) { return a -= b; }",
            "",
            "\tbigint &operator*=(int v) { // oops make sure not to multiply by ll ...",
            "\t\tif (v < 0) sign = -sign, v = -v;",
            "\t\tfor (int i = 0, carry = 0; i < size(z) || carry; ++i) {",
            "\t\t\tif (i == size(z)) z.pb(0);",
            "\t\t\tll cur = (ll) z[i] * v + carry;",
            "\t\t\tcarry = cur / base; z[i] = cur % base;",
            "\t\t}",
            "\t\ttrim(); return *this;",
            "\t}",
            "\tbigint operator*(int v) const { return bigint(*this) *= v; }",
            "\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
            "\t\tint norm = base / (b1.z.bk + 1);",
            "\t\tbigint a = a1.abs() * norm, b = b1.abs() * norm, q, r; // make last element of b big",
            "\t\tq.z.rsize(size(a.z));",
            "\t\tROF (i, size(a.z)) {",
            "\t\t\tr *= base; r += a.z[i];",
            "\t\t\tint s1 = size(b.z) < size(r.z) ? r.z[size(b.z)] : 0;",
            "\t\t\tint s2 = size(b.z) - 1 < size(r.z) ? r.z[size(b.z) - 1] : 0;",
            "\t\t\tint d = ((ll) s1 * base + s2) / b.z.bk; // best approximation",
            "\t\t\tr -= b * d; while (r < 0) r += b, --d;",
            "\t\t\tq.z[i] = d;",
            "\t\t}",
            "\t\tq.sign = a1.sign * b1.sign; r.sign = a1.sign;",
            "\t\tq.trim(); r.trim(); return {q, r / norm};",
            "\t}",
            "\tfriend bigint sqrt(const bigint &a1) {",
            "\t\tbigint a = a1; while (!size(a.z) || size(a.z) & 1) a.z.pb(0);",
            "\t\tint n = size(a.z), firstDigit = ::sqrt((db) a.z[n - 1] * base + a.z[n - 2]);",
            "\t\tint norm = base/(firstDigit+1); a *= norm; a *= norm;",
            "\t\twhile (!size(a.z) || size(a.z) & 1) a.z.pb(0);",
            "\t\tbigint r = (ll) a.z[n - 1] * base + a.z[n - 2];",
            "\t\tfirstDigit = (int)::sqrt((db) a.z[n - 1] * base + a.z[n - 2]);",
            "\t\tint q = firstDigit; bigint res;",
            "\t\tROF  (j, n / 2) {",
            "\t\t\tfor (;; --q) {",
            "\t\t\t\tbigint r1 = (r - (res * 2 * base + q) * q) * base * base +",
            "\t\t\t\t\t\t\t(j > 0 ? (ll) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);",
            "\t\t\t\tif (r1 >= 0) { r = r1; break; }",
            "\t\t\t}",
            "\t\t\tres *= base; res += q; // add a bit to sqrt",
            "\t\t\tif (j > 0) {",
            "\t\t\t\tint d1 = size(res.z) + 2 < size(r.z) ? r.z[size(res.z) + 2] : 0; // always 0/1?",
            "\t\t\t\tint d2 = size(res.z) + 1 < size(r.z) ? r.z[size(res.z) + 1] : 0;",
            "\t\t\t\tint d3 = size(res.z) < size(r.z) ? r.z[size(res.z)] : 0;",
            "\t\t\t\tq = ((ll) d1 * base * base + (ll) d2 * base + d3) / (firstDigit * 2);",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.trim(); return res / norm;",
            "\t}",
            "\tbigint operator/(const bigint &v) const { return divmod(*this, v).f; }",
            "\tbigint operator%(const bigint &v) const { return divmod(*this, v).s; }",
            "\tbigint &operator/=(int v) {",
            "\t\tif (v < 0) sign = -sign, v = -v;",
            "\t\tfor (int i = size(z) - 1, rem = 0; i >= 0; --i) {",
            "\t\t\tll cur = z[i] + rem * (ll) base;",
            "\t\t\tz[i] = cur / v; rem = cur %  v;",
            "\t\t}",
            "\t\ttrim(); return *this;",
            "\t}",
            "\tbigint operator/(int v) const { return bigint(*this) /= v; }",
            "\tint operator%(int v) const {",
            "\t\tif (v < 0) v = -v;",
            "\t\tint m = 0; ROF (i, size(z)) m = (z[i] + m * (ll) base) % v;",
            "\t\treturn m * sign; ",
            "\t}",
            "\tbigint &operator*=(const bigint &v) { return *this = *this * v; }",
            "\tbigint &operator/=(const bigint &v) { return *this = *this / v; }",
            "",
            "\tbool operator<(const bigint &v) const {",
            "\t\tif (sign != v.sign) return sign < v.sign;",
            "\t\tif (size(z) != size(v.z)) return size(z) * sign < size(v.z) * v.sign;",
            "\t\tROF (i, size(z)) if (z[i] != v.z[i]) return z[i] * sign < v.z[i] * sign;",
            "\t\treturn 0; // equal",
            "\t}",
            "\tbool operator>(const bigint &v) const { return v < *this; }",
            "\tbool operator<=(const bigint &v) const { return !(v < *this); }",
            "\tbool operator>=(const bigint &v) const { return !(*this < v); }",
            "\tbool operator==(const bigint &v) const { return !(*this < v) && !(v < *this); }",
            "\tbool operator!=(const bigint &v) const { return *this < v || v < *this; }",
            "\tvoid trim() {",
            "\t\twhile (size(z) && z.bk == 0) z.pop_back();",
            "\t\tif (!size(z)) sign = 1; // don't output -0",
            "\t}",
            "\tbool isizeero() const { return !size(z); }",
            "\tfriend bigint operator-(bigint v) {",
            "\t\tif (size(v.z)) v.sign = -v.sign;",
            "\t\treturn v; ",
            "\t}",
            "\tbigint abs() const { return sign == 1 ? *this : -*this; }",
            "\tll longValue() const {",
            "\t\tll res = 0; ROF (i, size(z)) res = res * base + z[i];",
            "\t\treturn res * sign; ",
            "\t}",
            "\tfriend bigint gcd(const bigint &a, const bigint &b) {",
            "\t\treturn b.isizeero() ? a : gcd(b, a % b); ",
            "\t} // euclidean algo",
            "\tfriend bigint lcm(const bigint &a, const bigint &b) {",
            "\t\treturn a/gcd(a, b) * b; ",
            "\t}",
            "\tvoid read(const str &s) {",
            "\t\tsign = 1; z.clear(); int pos = 0;",
            "\t\twhile (pos < size(s) && (s[pos] == '-' || s[pos] == '+')) {",
            "\t\t\tif (s[pos] == '-') sign = -sign;",
            "\t\t\t++pos; } // account for sign",
            "\t\tfor (int i = size(s) - 1; i >= pos; i -= base_digits) {",
            "\t\t\tint x = 0;",
            "\t\t\tfor (int j = max(pos, i - base_digits+1); j <= i; j++)",
            "\t\t\t\tx = x * 10 + s[j] - '0';",
            "\t\t\tz.pb(x);",
            "\t\t}",
            "\t\ttrim();",
            "\t}",
            "\tfriend istream &operator>>(istream &is, bigint &v) {",
            "\t\tstr s; is >> s; v.read(s); return is; }",
            "\tfriend ostream &operator<<(ostream &os, const bigint &v) {",
            "\t\tif (v.sign == -1) os << '-';",
            "\t\tos << (!size(v.z) ? 0 : v.z.bk);",
            "\t\tROF (i, size(v.z) - 1) os << setw(base_digits) << setfill('0') << v.z[i];",
            "\t\treturn os; // pad with zeroes",
            "\t}",
            "\tstatic vi convert_base(const vi &a, int old_digits, int new_digits) {",
            "\t\tvl p(max(old_digits, new_digits) + 1); // blocks of 10^{old} -> 10^{new}",
            "\t\tp[0] = 1; FOR (i, 1, size(p)) p[i] = p[i - 1] *  10;",
            "\t\tvi res; ll cur = 0; int cur_digits = 0;",
            "\t\tfor (int v : a) {",
            "\t\t\tcur += v * p[cur_digits]; cur_digits += old_digits;",
            "\t\t\twhile (cur_digits >= new_digits) {",
            "\t\t\t\tres.pb(cur % p[new_digits]);",
            "\t\t\t\tcur /= p[new_digits]; cur_digits -= new_digits;",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.pb(cur); while (size(res) && res.bk == 0) res.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tstatic vl karatMul(const vl &a, const vl &b) { // karatsuba",
            "\t\tint n = size(a); vl res(2 *  n);",
            "\t\tif (n <= 32) { // naive multiply",
            "\t\t\tFOR (i, n) FOR (j, n) res[i + j] += a[i] * b[j];",
            "\t\t\treturn res; ",
            "\t\t}",
            "\t\tint k = n / 2;",
            "\t\tvl a1(begin(a), begin(a) + k), a2(k + all(a));",
            "\t\tvl b1(begin(b), begin(b)+k), b2(k+all(b));",
            "\t\tvl a1b1 = karatMul(a1, b1), a2b2 = karatMul(a2, b2);",
            "\t\tFOR (i, k) a2[i] += a1[i], b2[i] += b1[i];",
            "\t\tvl r = karatMul(a2, b2); // three instead of four products",
            "\t\tFOR (i, size(a1b1)) r[i] -= a1b1[i];",
            "\t\tFOR (i, size(a2b2)) r[i] -= a2b2[i];",
            "\t\tFOR (i, size(r)) res[i + k] += r[i];",
            "\t\tFOR (i, size(a1b1)) res[i] += a1b1[i];",
            "\t\tFOR (i, size(a2b2)) res[i + n] += a2b2[i];",
            "\t\treturn res;",
            "\t}",
            "\tbigint operator*(const bigint &v) const {",
            "\t\tif (min(size(z),size(v.z)) < 150) return mul_simple(v);",
            "\t\tbigint res; res.sign = sign * v.sign; // should work as long as # of digits isn't too large (> LLONG_MAX/10^{12})",
            "\t\tvi a6 = convert_base(this->z, base_digits, 6); // blocks of 10^6 instead of 10^9",
            "\t\tvi b6 = convert_base(v.z, base_digits, 6);",
            "\t\tvl a(all(a6)), b(all(b6));",
            "\t\twhile (size(a) < size(b)) a.pb(0);",
            "\t\twhile (size(b) < size(a)) b.pb(0);",
            "\t\twhile (size(a) & (size(a) - 1)) a.pb(0), b.pb(0); // make size power of 2",
            "\t\tvl c = karatMul(a, b);",
            "\t\tll cur = 0; ",
            "\t\tFOR (i, size(c)) { // process carries",
            "\t\t\tcur += c[i]; res.z.pb(cur % 1000000); cur /= 1000000; ",
            "\t\t}",
            "\t\tres.z = convert_base(res.z, 6, base_digits); ",
            "\t\tres.trim(); return res;",
            "\t}",
            "\tbigint mul_simple(const bigint &v) const {",
            "\t\tbigint res; res.sign = sign * v.sign;",
            "\t\tres.z.rsize(size(z) + size(v.z));",
            "\t\tFOR (i, size(z)) if (z[i]) {",
            "\t\t\tll cur = 0; for (int j = 0; j < size(v.z) || cur; ++j) {",
            "\t\t\t\tcur += res.z[i + j] + (ll) z[i] * (j < size(v.z) ? v.z[j] : 0);",
            "\t\t\t\tres.z[i + j] = cur % base; cur /= base;",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.trim(); return res;",
            "\t}",
            "\tfriend str ts(const bigint& v) {",
            "\t\tstringstream ss; ss << v;",
            "\t\tstr s; ss >> s; return s; }",
            "};"
        ]
    },
    "bigint2": {
        "prefix": "bigint2",
        "body": [
            "using cpx = complex<double>;",
            "const double PI = acos(-1);",
            "vector<cpx> roots = {{0, 0}, {1, 0}};",
            "",
            "void ensure_capacity(int min_capacity) {",
            "\tfor (int len = size(roots); len < min_capacity; len *= 2) {",
            "\t\tfor (int i = len >> 1; i < len; i++) {",
            "\t\t\troots.emplace_back(roots[i]);",
            "\t\t\tdouble angle = 2 * PI * (2 * i + 1 - len) / (len * 2);",
            "\t\t\troots.emplace_back(cos(angle), sin(angle));",
            "\t\t}",
            "\t}",
            "}",
            "",
            "void fft(vector<cpx> &z, bool inverse) {",
            "\tint n = size(z);",
            "\tassert((n & (n - 1)) == 0);",
            "\tensure_capacity(n);",
            "\tfor (unsigned i = 1, j = 0; i < n; i++) {",
            "\t\tint bit = n >> 1;",
            "\t\tfor (; j >= bit; bit >>= 1)",
            "\t\t\tj -= bit;",
            "\t\tj += bit;",
            "\t\tif (i < j)",
            "\t\t\tswap(z[i], z[j]);",
            "\t}",
            "\tfor (int len = 1; len < n; len <<= 1) {",
            "\t\tfor (int i = 0; i < n; i += len * 2) {",
            "\t\t\tfor (int j = 0; j < len; j++) {",
            "\t\t\t\tcpx root = inverse ? conj(roots[j + len]) : roots[j + len];",
            "\t\t\t\tcpx u = z[i + j];",
            "\t\t\t\tcpx v = z[i + j + len] * root;",
            "\t\t\t\tz[i + j] = u + v;",
            "\t\t\t\tz[i + j + len] = u - v;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif (inverse)",
            "\t\tfor (int i = 0; i < n; i++)",
            "\t\t\tz[i] /= n;",
            "}",
            "",
            "vector<int> multiply_bigint(const vector<int> &a, const vector<int> &b, int base) {",
            "\tint need = size(a) + size(b);",
            "\tint n = 1;",
            "\twhile (n < need)",
            "\t\tn <<= 1;",
            "\tvector<cpx> p(n);",
            "\tfor (size_t i = 0; i < n; i++) {",
            "\t\tp[i] = cpx(i < size(a) ? a[i] : 0, i < size(b) ? b[i] : 0);",
            "\t}",
            "\tfft(p, false);",
            "\t// a[w[k]] = (p[w[k]] + conj(p[w[n-k]])) / 2",
            "\t// b[w[k]] = (p[w[k]] - conj(p[w[n-k]])) / (2*i)",
            "\tvector<cpx> ab(n);",
            "\tcpx r(0, -0.25);",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tint j = (n - i) & (n - 1);",
            "\t\tab[i] = (p[i] * p[i] - conj(p[j] * p[j])) * r;",
            "\t}",
            "\tfft(ab, true);",
            "\tvector<int> result(need);",
            "\tlong long carry = 0;",
            "\tfor (int i = 0; i < need; i++) {",
            "\t\tlong long d = (long long)(ab[i].real() + 0.5) + carry;",
            "\t\tcarry = d / base;",
            "\t\tresult[i] = d % base;",
            "\t}",
            "\treturn result;",
            "}",
            "",
            "vector<int> multiply_mod(const vector<int> &a, const vector<int> &b, int m) {",
            "\tint need = size(a) + size(b) - 1;",
            "\tint n = 1;",
            "\twhile (n < need)",
            "\t\tn <<= 1;",
            "\tvector<cpx> A(n);",
            "\tfor (size_t i = 0; i < size(a); i++) {",
            "\t\tint x = (a[i] % m + m) % m;",
            "\t\tA[i] = cpx(x & ((1 << 15) - 1), x >> 15);",
            "\t}",
            "\tfft(A, false);",
            "",
            "\tvector<cpx> B(n);",
            "\tfor (size_t i = 0; i < size(b); i++) {",
            "\t\tint x = (b[i] % m + m) % m;",
            "\t\tB[i] = cpx(x & ((1 << 15) - 1), x >> 15);",
            "\t}",
            "\tfft(B, false);",
            "",
            "\tvector<cpx> fa(n);",
            "\tvector<cpx> fb(n);",
            "\tfor (int i = 0, j = 0; i < n; i++, j = n - i) {",
            "\t\tcpx a1 = (A[i] + conj(A[j])) * cpx(0.5, 0);",
            "\t\tcpx a2 = (A[i] - conj(A[j])) * cpx(0, -0.5);",
            "\t\tcpx b1 = (B[i] + conj(B[j])) * cpx(0.5, 0);",
            "\t\tcpx b2 = (B[i] - conj(B[j])) * cpx(0, -0.5);",
            "\t\tfa[i] = a1 * b1 + a2 * b2 * cpx(0, 1);",
            "\t\tfb[i] = a1 * b2 + a2 * b1;",
            "\t}",
            "",
            "\tfft(fa, true);",
            "\tfft(fb, true);",
            "\tvector<int> res(need);",
            "\tfor (int i = 0; i < need; i++) {",
            "\t\tlong long aa = (long long)(fa[i].real() + 0.5);",
            "\t\tlong long bb = (long long)(fb[i].real() + 0.5);",
            "\t\tlong long cc = (long long)(fa[i].imag() + 0.5);",
            "\t\tres[i] = (aa % m + (bb % m << 15) + (cc % m << 30)) % m;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "constexpr int digits(int base) noexcept {",
            "\treturn base <= 1 ? 0 : 1 + digits(base / 10);",
            "}",
            "",
            "constexpr int base = 1000'000'000;",
            "constexpr int base_digits = digits(base);",
            "",
            "constexpr int fft_base = 10'000;  // fft_base^2 * n / fft_base_digits <= 10^15 for double",
            "constexpr int fft_base_digits = digits(fft_base);",
            "",
            "struct bigint {",
            "\t// value == 0 is represented by empty z",
            "\tvector<int> z;  // digits",
            "",
            "\t// sign == 1 <==> value >= 0",
            "\t// sign == -1 <==> value < 0",
            "\tint sign;",
            "",
            "\tbigint(long long v = 0) { *this = v; }",
            "",
            "\tbigint &operator=(long long v) {",
            "\t\tsign = v < 0 ? -1 : 1;",
            "\t\tv *= sign;",
            "\t\tz.clear();",
            "\t\tfor (; v > 0; v = v / base)",
            "\t\t\tz.push_back((int)(v % base));",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbigint(const string &s) { read(s); }",
            "",
            "\tbigint &operator+=(const bigint &other) {",
            "\t\tif (sign == other.sign) {",
            "\t\t\tfor (int i = 0, carry = 0; i < size(other.z) || carry; ++i) {",
            "\t\t\t\tif (i == size(z))",
            "\t\t\t\t\tz.push_back(0);",
            "\t\t\t\tz[i] += carry + (i < size(other.z) ? other.z[i] : 0);",
            "\t\t\t\tcarry = z[i] >= base;",
            "\t\t\t\tif (carry)",
            "\t\t\t\t\tz[i] -= base;",
            "\t\t\t}",
            "\t\t} else if (other != 0 /* prevent infinite loop */) {",
            "\t\t\t*this -= -other;",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tfriend bigint operator+(bigint a, const bigint &b) {",
            "\t\ta += b;",
            "\t\treturn a;",
            "\t}",
            "",
            "\tbigint &operator-=(const bigint &other) {",
            "\t\tif (sign == other.sign) {",
            "\t\t\tif ((sign == 1 && *this >= other) || (sign == -1 && *this <= other)) {",
            "\t\t\t\tfor (int i = 0, carry = 0; i < size(other.z) || carry; ++i) {",
            "\t\t\t\t\tz[i] -= carry + (i < size(other.z) ? other.z[i] : 0);",
            "\t\t\t\t\tcarry = z[i] < 0;",
            "\t\t\t\t\tif (carry)",
            "\t\t\t\t\t\tz[i] += base;",
            "\t\t\t\t}",
            "\t\t\t\ttrim();",
            "\t\t\t} else {",
            "\t\t\t\t*this = other - *this;",
            "\t\t\t\tthis->sign = -this->sign;",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\t*this += -other;",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tfriend bigint operator-(bigint a, const bigint &b) {",
            "\t\ta -= b;",
            "\t\treturn a;",
            "\t}",
            "",
            "\tbigint &operator*=(int v) {",
            "\t\tif (v < 0)",
            "\t\t\tsign = -sign, v = -v;",
            "\t\tfor (int i = 0, carry = 0; i < size(z) || carry; ++i) {",
            "\t\t\tif (i == size(z))",
            "\t\t\t\tz.push_back(0);",
            "\t\t\tlong long cur = (long long)z[i] * v + carry;",
            "\t\t\tcarry = (int)(cur / base);",
            "\t\t\tz[i] = (int)(cur % base);",
            "\t\t}",
            "\t\ttrim();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbigint operator*(int v) const { return bigint(*this) *= v; }",
            "",
            "\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
            "\t\tint norm = base / (b1.z.back() + 1);",
            "\t\tbigint a = a1.abs() * norm;",
            "\t\tbigint b = b1.abs() * norm;",
            "\t\tbigint q, r;",
            "\t\tq.z.resize(size(a.z));",
            "",
            "\t\tfor (int i = (int)size(a.z) - 1; i >= 0; i--) {",
            "\t\t\tr *= base;",
            "\t\t\tr += a.z[i];",
            "\t\t\tint s1 = size(b.z) < size(r.z) ? r.z[size(b.z)] : 0;",
            "\t\t\tint s2 = size(b.z) - 1 < size(r.z) ? r.z[size(b.z) - 1] : 0;",
            "\t\t\tint d = (int)(((long long)s1 * base + s2) / b.z.back());",
            "\t\t\tr -= b * d;",
            "\t\t\twhile (r < 0)",
            "\t\t\t\tr += b, --d;",
            "\t\t\tq.z[i] = d;",
            "\t\t}",
            "",
            "\t\tq.sign = a1.sign * b1.sign;",
            "\t\tr.sign = a1.sign;",
            "\t\tq.trim();",
            "\t\tr.trim();",
            "\t\treturn {q, r / norm};",
            "\t}",
            "",
            "\tfriend bigint sqrt(const bigint &a1) {",
            "\t\tbigint a = a1;",
            "\t\twhile (a.z.empty() || size(a.z) % 2 == 1)",
            "\t\t\ta.z.push_back(0);",
            "",
            "\t\tint n = size(a.z);",
            "",
            "\t\tint firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);",
            "\t\tint norm = base / (firstDigit + 1);",
            "\t\ta *= norm;",
            "\t\ta *= norm;",
            "\t\twhile (a.z.empty() || size(a.z) % 2 == 1)",
            "\t\t\ta.z.push_back(0);",
            "",
            "\t\tbigint r = (long long)a.z[n - 1] * base + a.z[n - 2];",
            "\t\tfirstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);",
            "\t\tint q = firstDigit;",
            "\t\tbigint res;",
            "",
            "\t\tfor (int j = n / 2 - 1; j >= 0; j--) {",
            "\t\t\tfor (;; --q) {",
            "\t\t\t\tbigint r1 = (r - (res * 2 * base + q) * q) * base * base +",
            "\t\t\t\t\t\t\t(j > 0 ? (long long)a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);",
            "\t\t\t\tif (r1 >= 0) {",
            "\t\t\t\t\tr = r1;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tres *= base;",
            "\t\t\tres += q;",
            "",
            "\t\t\tif (j > 0) {",
            "\t\t\t\tint d1 = size(res.z) + 2 < size(r.z) ? r.z[size(res.z) + 2] : 0;",
            "\t\t\t\tint d2 = size(res.z) + 1 < size(r.z) ? r.z[size(res.z) + 1] : 0;",
            "\t\t\t\tint d3 = size(res.z) < size(r.z) ? r.z[size(res.z)] : 0;",
            "\t\t\t\tq = (int)(((long long)d1 * base * base + (long long)d2 * base + d3) / (firstDigit * 2));",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tres.trim();",
            "\t\treturn res / norm;",
            "\t}",
            "",
            "\tbigint operator/(const bigint &v) const { return divmod(*this, v).first; }",
            "",
            "\tbigint operator%(const bigint &v) const { return divmod(*this, v).second; }",
            "",
            "\tbigint &operator/=(int v) {",
            "\t\tif (v < 0)",
            "\t\t\tsign = -sign, v = -v;",
            "\t\tfor (int i = size(z) - 1, rem = 0; i >= 0; --i) {",
            "\t\t\tlong long cur = z[i] + rem * (long long)base;",
            "\t\t\tz[i] = (int)(cur / v);",
            "\t\t\trem = (int)(cur % v);",
            "\t\t}",
            "\t\ttrim();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbigint operator/(int v) const { return bigint(*this) /= v; }",
            "",
            "\tint operator%(int v) const {",
            "\t\tif (v < 0)",
            "\t\t\tv = -v;",
            "\t\tint m = 0;",
            "\t\tfor (int i = size(z) - 1; i >= 0; --i)",
            "\t\t\tm = (int)((z[i] + m * (long long)base) % v);",
            "\t\treturn m * sign;",
            "\t}",
            "",
            "\tbigint &operator*=(const bigint &v) {",
            "\t\t*this = *this * v;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbigint &operator/=(const bigint &v) {",
            "\t\t*this = *this / v;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbigint &operator%=(const bigint &v) {",
            "\t\t*this = *this % v;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tbool operator<(const bigint &v) const {",
            "\t\tif (sign != v.sign)",
            "\t\t\treturn sign < v.sign;",
            "\t\tif (size(z) != size(v.z))",
            "\t\t\treturn size(z) * sign < size(v.z) * v.sign;",
            "\t\tfor (int i = size(z) - 1; i >= 0; i--)",
            "\t\t\tif (z[i] != v.z[i])",
            "\t\t\t\treturn z[i] * sign < v.z[i] * sign;",
            "\t\treturn false;",
            "\t}",
            "",
            "\tbool operator>(const bigint &v) const { return v < *this; }",
            "",
            "\tbool operator<=(const bigint &v) const { return !(v < *this); }",
            "",
            "\tbool operator>=(const bigint &v) const { return !(*this < v); }",
            "",
            "\tbool operator==(const bigint &v) const { return sign == v.sign && z == v.z; }",
            "",
            "\tbool operator!=(const bigint &v) const { return !(*this == v); }",
            "",
            "\tvoid trim() {",
            "\t\twhile (!z.empty() && z.back() == 0)",
            "\t\t\tz.pop_back();",
            "\t\tif (z.empty())",
            "\t\t\tsign = 1;",
            "\t}",
            "",
            "\tbool isZero() const { return z.empty(); }",
            "",
            "\tfriend bigint operator-(bigint v) {",
            "\t\tif (!v.z.empty())",
            "\t\t\tv.sign = -v.sign;",
            "\t\treturn v;",
            "\t}",
            "",
            "\tbigint abs() const { return sign == 1 ? *this : -*this; }",
            "",
            "\tlong long longValue() const {",
            "\t\tlong long res = 0;",
            "\t\tfor (int i = size(z) - 1; i >= 0; i--)",
            "\t\t\tres = res * base + z[i];",
            "\t\treturn res * sign;",
            "\t}",
            "",
            "\tfriend bigint gcd(const bigint &a, const bigint &b) { return b.isZero() ? a : gcd(b, a % b); }",
            "",
            "\tfriend bigint lcm(const bigint &a, const bigint &b) { return a / gcd(a, b) * b; }",
            "",
            "\tvoid read(const string &s) {",
            "\t\tsign = 1;",
            "\t\tz.clear();",
            "\t\tint pos = 0;",
            "\t\twhile (pos < size(s) && (s[pos] == '-' || s[pos] == '+')) {",
            "\t\t\tif (s[pos] == '-')",
            "\t\t\t\tsign = -sign;",
            "\t\t\t++pos;",
            "\t\t}",
            "\t\tfor (int i = size(s) - 1; i >= pos; i -= base_digits) {",
            "\t\t\tint x = 0;",
            "\t\t\tfor (int j = max(pos, i - base_digits + 1); j <= i; j++)",
            "\t\t\t\tx = x * 10 + s[j] - '0';",
            "\t\t\tz.push_back(x);",
            "\t\t}",
            "\t\ttrim();",
            "\t}",
            "",
            "\tfriend istream &operator>>(istream &stream, bigint &v) {",
            "\t\tstring s;",
            "\t\tstream >> s;",
            "\t\tv.read(s);",
            "\t\treturn stream;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &stream, const bigint &v) {",
            "\t\tif (v.sign == -1)",
            "\t\t\tstream << '-';",
            "\t\tstream << (v.z.empty() ? 0 : v.z.back());",
            "\t\tfor (int i = size(v.z) - 2; i >= 0; --i)",
            "\t\t\tstream << setw(base_digits) << setfill('0') << v.z[i];",
            "\t\treturn stream;",
            "\t}",
            "",
            "\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
            "\t\tvector<long long> p(max(old_digits, new_digits) + 1);",
            "\t\tp[0] = 1;",
            "\t\tfor (int i = 1; i < size(p); i++)",
            "\t\t\tp[i] = p[i - 1] * 10;",
            "\t\tvector<int> res;",
            "\t\tlong long cur = 0;",
            "\t\tint cur_digits = 0;",
            "\t\tfor (int v : a) {",
            "\t\t\tcur += v * p[cur_digits];",
            "\t\t\tcur_digits += old_digits;",
            "\t\t\twhile (cur_digits >= new_digits) {",
            "\t\t\t\tres.push_back(int(cur % p[new_digits]));",
            "\t\t\t\tcur /= p[new_digits];",
            "\t\t\t\tcur_digits -= new_digits;",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.push_back((int)cur);",
            "\t\twhile (!res.empty() && res.back() == 0)",
            "\t\t\tres.pop_back();",
            "\t\treturn res;",
            "\t}",
            "",
            "\tbigint operator*(const bigint &v) const {",
            "\t\tif (min(size(z), size(v.z)) < 150)",
            "\t\t\treturn mul_simple(v);",
            "\t\tbigint res;",
            "\t\tres.sign = sign * v.sign;",
            "\t\tres.z = multiply_bigint(convert_base(z, base_digits, fft_base_digits),",
            "\t\t\t\t\t\t\t\tconvert_base(v.z, base_digits, fft_base_digits), fft_base);",
            "\t\tres.z = convert_base(res.z, fft_base_digits, base_digits);",
            "\t\tres.trim();",
            "\t\treturn res;",
            "\t}",
            "",
            "\tbigint mul_simple(const bigint &v) const {",
            "\t\tbigint res;",
            "\t\tres.sign = sign * v.sign;",
            "\t\tres.z.resize(size(z) + size(v.z));",
            "\t\tfor (int i = 0; i < size(z); ++i)",
            "\t\t\tif (z[i])",
            "\t\t\t\tfor (int j = 0, carry = 0; j < size(v.z) || carry; ++j) {",
            "\t\t\t\t\tlong long cur = res.z[i + j] + (long long)z[i] * (j < size(v.z) ? v.z[j] : 0) + carry;",
            "\t\t\t\t\tcarry = (int)(cur / base);",
            "\t\t\t\t\tres.z[i + j] = (int)(cur % base);",
            "\t\t\t\t}",
            "\t\tres.trim();",
            "\t\treturn res;",
            "\t}",
            "}"
        ]
    },
    "fastmod": {
        "prefix": "fastmod",
        "body": [
            "using ul = uint64_t; using L = __uint128_t;",
            "struct FastMod {",
            "\tul b, m; ",
            "\tFastMod(ul b) : b(b), m(-1ULL / b) {}",
            "\tul operator()(ul a) {",
            "\t\tul q = (ul)((__uint128_t(m) * a) >> 64), r = a - q * b;",
            "\t\treturn r - (r >= b) * b; ",
            "\t}",
            "};"
        ]
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a / b * x, d;",
            "}",
            "",
            "template<class T, ll mod>",
            "struct ModInt {",
            "\tT x;",
            "\tModInt() { x = 0; }",
            "\tModInt(int _x) : x(_x) {",
            "\t\tx %= mod;",
            "\t\tif (x < 0) x += mod;",
            "\t}",
            "\tModInt(ll _x) : x(_x) {",
            "\t\tx %= mod;",
            "\t\tif (x < 0) x += mod;",
            "\t} ",
            "\tModInt& operator++() { x = (x + 1 == mod ? 0 : x + 1); return *this; } ",
            "\tModInt operator+(ModInt b) { return {x + b.x}; }",
            "\tModInt& operator+=(ModInt b) { x = (x + b.x) % mod; return *this; }",
            "\tModInt& operator--() { x = (x ? x - 1 : mod - 1); return *this; }",
            "\tModInt operator-(ModInt b) { return {x - b.x}; }",
            "\tModInt& operator-=(ModInt b) { x = (x - b.x + mod) % mod; return *this; }",
            "\tModInt operator*(ModInt b) { return {1ll * x * b.x}; }",
            "\tModInt& operator*=(ModInt b) { x = (1ll * x * b.x) % mod; return *this; }",
            "\tModInt operator/(ModInt b) { return 1ll * *this * invert(b); }",
            "\tModInt& operator/=(ModInt b) { x = (1ll * x * invert(b)) % mod; return *this; } ",
            "\tModInt invert(ModInt a) {",
            "\t\tll x, y, g = euclid(a.x, mod, x, y);",
            "\t\treturn ModInt((x + mod) % mod);",
            "\t}",
            "\tModInt operator^(ll e) {",
            "\t\tif (!e) return ModInt(1);",
            "\t\tModInt r = *this ^ (e / 2); r = r * r;",
            "\t\treturn e & 1 ? *this * r : r;",
            "\t}",
            "\tT val() { return x; }",
            "};",
            "using mint = ModInt<int, mod>;"
        ]
    },
    "rangequery": {
        "prefix": "rangequery",
        "body": [
            "template<class T> struct RangeQuery {",
            "\t#define comb(a, b) (a) + (b)",
            "\t#define id 0",
            "\tint lg, n;",
            "\tvt<vt<T>> stor;",
            "\tvt<T> a;",
            "\tvoid fill(int l, int r, int ind) {",
            "\t\tif (ind < 0) return;",
            "\t\tint m = (l + r) / 2;",
            "\t\tT prod = id; ",
            "\t\tFOR (i, m, r) stor[i][ind] = prod = comb(prod, a[i]);",
            "\t\tprod = id; ",
            "\t\tROF (i, l, m) stor[i][ind] = prod = comb(a[i], prod);",
            "\t\tfill(l, m, ind - 1); ",
            "\t\tfill(m, r, ind - 1);",
            "\t}",
            "\ttemplate <typename It>",
            "\tvoid build(It l, It r) {",
            "\t\tlg = 1;",
            "\t\twhile ((1 << lg) < r - l) lg++;",
            "\t\tn = 1 << lg;",
            "\t\ta.resize(n, id);",
            "\t\tfor (It i = l; i != r; i++) a[i - l] = *i;",
            "\t\tstor.resize(n, vt<T>(32 - __builtin_clz(n)));",
            "\t\tfill(0, n, lg - 1);",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tif (l == r) return a[l];",
            "\t\tint t = 31 - __builtin_clz(r ^ l);",
            "\t\treturn comb(stor[l][t], stor[r][t]);",
            "\t}",
            "\t#undef id",
            "\t#undef comb",
            "};"
        ]
    },
    "simanneal": {
        "prefix": "simanneal",
        "body": [
            "#include <bits/extc++.h>",
            "#include <sys/time.h>",
            "",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "// #pragma GCC optimize(\"O3,unroll-loops\")",
            "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "const long long mod = 1e9 + 7;",
            "// const long long mod = 998244353;",
            "const int precision = 24;",
            "using db = long double;",
            "",
            "template<class T> using vt = vector<T>;",
            "using str = string;",
            "using ll = long long;",
            "using pi = pair<int, int>;",
            "using pl = pair<ll, ll>;",
            "using pd = pair<db, db>;",
            "using vi = vt<int>;",
            "using vl = vt<ll>;",
            "using vb = vt<bool>;",
            "using vvi = vt<vt<int>>;",
            "using vvl = vt<vt<ll>>;",
            "using vvb = vt<vt<bool>>;",
            "using vpi = vt<pi>;",
            "using vpl = vt<pl>;",
            "",
            "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
            "",
            "struct chash { // large odd number for C",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
            "\tll operator()(ll x) const { return __builtin_bswap64((x ^ RANDOM) * C); }",
            "};",
            "",
            "#define gptable gp_hash_table",
            "template<class K, class V, class hash> gptable<K, V, hash> make_gptable() {",
            "\treturn gptable<K, V, hash>({}, {}, {}, {}, {1 << 16});",
            "}",
            "",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define bg(x) begin(x)",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define size(x) ((int) (x).size())",
            "#define sq(x) ((x) * (x))",
            "#define rsz resize",
            "#define ins insert",
            "#define ft front()",
            "#define bk back()",
            "#ifndef LOCAL",
            "#define endl '\\n'",
            "#endif",
            "",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "template<class T> int lwb(vt<T>& a, const T& b) { return int(lb(all(a), b) - bg(a)); }",
            "template<class T> int upb(vt<T>& a, const T& b) { return int(ub(all(a), b) - bg(a)); }",
            "template<class T> void rem_dup(vt<T>& v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "#define contains(a, x) find(all(x), a) == end(x)",
            "",
            "#define cmp(exp) [&] (const auto& x, const auto& y) { return exp; }",
            "",
            "#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())",
            "#define __NARG_I_(...) __ARG_N(__VA_ARGS__)",
            "#define __ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N",
            "#define __RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
            "",
            "#define _VFUNC_(name, n) name##n",
            "#define _VFUNC(name, n) _VFUNC_(name, n)",
            "#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)",
            "",
            "#define FOR2(i, b) for (int i = 0; i < (b); i++)",
            "#define FOR3(i, a, b) for (int i = (a); i < (b); i++)",
            "#define ROF2(i, b) for (int i = (b) - 1; i >= 0; i--)",
            "#define ROF3(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "#define rep(x) FOR (_, x)",
            "",
            "#define each2(a, x) for (auto& a : x)",
            "#define each3(a, b, x) for (auto& [a, b] : x)",
            "#define each4(a, b, c, x) for (auto& [a, b, c] : x)",
            "",
            "#define enum3(i, a, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& a = *it; 1)",
            "#define enum4(i, a, b, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b] = *it; 1)",
            "#define enum5(i, a, b, c, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define FOR(...) VFUNC(FOR, __VA_ARGS__)",
            "#define ROF(...) VFUNC(ROF, __VA_ARGS__)",
            "#define each(...) VFUNC(each, __VA_ARGS__)",
            "#define enum(...) VFUNC(enum, __VA_ARGS__)",
            "",
            "#define lam1(x) [&] () { return x; }",
            "#define lam2(x, y) [&] (x) { return y;}",
            "#define lam3(x, y, z) [&] (x, y) { return z; }",
            "#define lam4(w, x, y, z) [&] (w, x, y) { return z; }",
            "",
            "#define lam(...) VFUNC(lam, __VA_ARGS__)",
            "",
            "__gnu_cxx::sfmt19937 mt((uint32_t) chrono::steady_clock::now().time_since_epoch().count());",
            "ll mpow(ll x, ll y = mod - 2) {",
            "\tll res = 1;",
            "\tfor (; y; x = (x * x) % mod, y >>= 1) if (y & 1) res = (res * x) % mod;",
            "\treturn res;",
            "}",
            "ll gen(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(mt); }",
            "",
            "int rs, cs;",
            "const int dr[5] {0, -1, 0, 1, 0}, dc[5] {1, 0, -1, 0, 0};",
            "bool valid(int r, int c) { return r >= 0 && c >= 0 && r < rs && c < cs; }",
            "vpi get_adj(int r, int c) {",
            "\tvpi ret(4);",
            "\tFOR (i, 4) ret[i] = {r + dr[i], c + dc[i]};",
            "\treturn ret;",
            "}",
            "vpi get_valid_adj(int r, int c) {",
            "\tvpi ret;",
            "\tFOR (i, 4) {",
            "\t\tint nr = r + dr[i];",
            "\t\tint nc = c + dc[i];",
            "\t\tif (valid(nr, nc)) ret.eb(nr, nc);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); }",
            "constexpr int pctl(ll x) { return __builtin_popcountll(x); }",
            "// 2 ^ bits(n) is the largest power of 2 <= n",
            "constexpr int bits(int x) { return x ? 31 - __builtin_clz(x) : 0; }",
            "constexpr int bits(ll x) { return x ? 63 - __builtin_clzll(x) : 0; }",
            "constexpr int p2(int x) { return 1 << x; }",
            "constexpr ll p2l(int x) { return 1ll << x; }",
            "constexpr int msk2(int x) { return p2(x) - 1; }",
            "constexpr ll msk2l(int x) { return p2l(x) - 1; }",
            "",
            "ll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }",
            "",
            "namespace IO {",
            "#ifndef LOCAL",
            "\tconst int BSZ = 1 << 15;",
            "\tchar ibuf[BSZ]; int ipos, ilen;",
            "\tchar _next_char() {",
            "\t\tif (ipos == ilen) {",
            "\t\t\tipos = 0;",
            "\t\t\tilen = fread(ibuf, 1, BSZ, stdin);",
            "\t\t\tif (!ilen) return EOF;",
            "\t\t}",
            "\t\treturn ibuf[ipos++];",
            "\t}",
            "\tchar _nc() {",
            "\t\tchar ch;",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t\treturn ch;",
            "\t}",
            "\tvoid _rc(char& ch) {",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t}",
            "\tstring _ns() {",
            "\t\tstring x;",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t\treturn x;",
            "\t}",
            "\tvoid _rs(string& x) {",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t}",
            "\tint _ni() {",
            "\t\tint x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\tll _nl() {",
            "\t\tll x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\ttemplate<class T> void _ri(T& x) {",
            "\t\tchar ch;",
            "\t\tint sgn = 1;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\tx *= sgn;",
            "\t}",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { _ri(t); _ri(ts...); }",
            "\tchar obuf[BSZ], numBuf[100]; int opos;",
            "\tvoid flushOut() {",
            "\t\tfwrite(obuf, 1, opos, stdout); opos = 0;",
            "\t}",
            "\tvoid _wc(char c) {",
            "\t\tif (opos == BSZ) flushOut();",
            "\t\tobuf[opos++] = c;",
            "\t}",
            "\tvoid _ws(string s) { for (char& c : s) _wc(c); }",
            "\ttemplate<class T> void _wi(T x) {",
            "\t\tif (x < 0) _wc('-'), x *= -1;",
            "\t\tint len = 0;",
            "\t\tfor (; x >= 10; x /= 10) numBuf[len++] = '0' + (x % 10);",
            "\t\t_wc('0' + x);",
            "\t\tfor (int i = len - 1; i >= 0; i--) _wc(numBuf[i]);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) {",
            "\t\tstr in; _rs(in); x = stold(in);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) {",
            "\t\tostringstream sout;",
            "\t\tsout << std::fixed << std::setprecision(precision) << x;",
            "\t\tstr out = sout.str();",
            "\t\teach(c, out) _wc(c);",
            "\t}",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { assert(atexit(flushOut) == 0); }",
            "#else",
            "\tchar _nc() { char ch; cin >> ch; return ch; }",
            "\tvoid _rc(char& ch) { cin >> ch; }",
            "\tstring _ns() { string x; cin >> x; return x; }",
            "\tvoid _rs(string& x) { cin >> x; }",
            "\tint _ni() { int x; cin >> x; return x; }",
            "\tll _nl() { ll x; cin >> x; return x; }",
            "\ttemplate<class T> void _ri(T& x) { cin >> x; }",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { ri(t); ri(ts...); }",
            "\tvoid _wc(char c) {",
            "\t\tif (c == '\\n') cout << endl;",
            "\t\telse cout << c;",
            "\t}",
            "\tvoid _ws(string s) { cout << s; }",
            "\ttemplate<class T> void _wi(T x) { cout << x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) { cin >> x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) { cout << std::fixed << std::setprecision(precision) << x; }",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { cin.tie(0)->sync_with_stdio(0); }",
            "#endif",
            "}",
            "",
            "void setfileaio(string name) {",
            "#ifndef LOCAL",
            "\tif (name == \"\") return;",
            "\tfreopen((name + \"in.txt\").c_str(), \"r\", stdin);",
            "\tfreopen((name + \"out.txt\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "void setfile(string pfx) {",
            "#ifndef LOCAL",
            "\tif (pfx == \"\") return;",
            "\tfreopen((pfx + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((pfx + \".out\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "template<typename... Args> // tuples",
            "ostream& operator<<(ostream& os, tuple<Args...> t) {",
            "\tapply([&](Args... args) { string dlm = \"{\"; ((os << dlm << args, dlm = \", \"), ...); }, t);",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<typename T, typename V> // pairs",
            "ostream& operator<<(ostream& os, pair<T, V> p) { return os << \"{\" << p.f << \", \" << p.s << \"}\"; }",
            "",
            "template<typename T, typename V>",
            "istream& operator>>(istream& os, pair<T, V> p) { return os >> p.f >> p.s; }",
            "",
            "template<class T, class = decltype(begin(declval<T>()))> // iterables",
            "typename enable_if<!is_same<T, string>::value, ostream&>::type operator<<(ostream& os, const T& v) {",
            "\tos << \"{\";",
            "\tstring dlm = \"\";",
            "\tfor (auto i : v) os << dlm << i, dlm = \", \";",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value, istream&>::type operator>>(istream& os, T& v) {",
            "\tfor (auto& i : v) os >> i;",
            "\treturn os;",
            "}",
            "",
            "void read(char& x) { x = IO::_nc(); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type read(T& x) { IO::_ri(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type read(T &x) { IO::_rf(x); }",
            "void read(bool& x) { char c; read(c); x = (c == '1'); }",
            "void read(string& x) { IO::_rs(x); }",
            "template<class T, class U> void read(pair<T, U>& x) { read(x.f); read(x.s); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type read(T& v) { for (auto& i : v) read(i); }",
            "template<class T, class... Ts> void read(T& t, Ts&... ts) { read(t); read(ts...); }",
            "",
            "void _print(const char& c) { IO::_wc(c); }",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type _print(T x) { IO::_wi(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type _print(T& x) { IO::_wf(x); }",
            "void _print(const bool& x) { IO::_wi(x); }",
            "void _print(const string& x) { IO::_ws(x); }",
            "void _print(const char* x) { IO::_ws(x); }",
            "template<class T, class U>",
            "void _print(const pair<T, U>& x) { _print(x.first); _print(' '); _print(x.second); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type _print(const T& v) { each(i, v) _print(i), _print(' '); }",
            "template<class T> void print(const T& t) { _print(t); _print(' '); }",
            "template<class T, class... Ts> void print(const T& t, const Ts&... ts) { _print(t); _print(' '); print(ts...); }",
            "template <typename T>",
            "void print(initializer_list<T> args) { each(e, args) _print(e); }",
            "void println() { _print('\\n'); }",
            "template<class T> void println(const T& t) { _print(t); _print('\\n'); }",
            "template<class T, class... Ts> void println(const T& t, const Ts&... ts) { _print(t); _print(' '); println(ts...); }",
            "template<class T>",
            "void println(initializer_list<T> args) { each(e, args) _print(e); _print('\\n'); }",
            "",
            "int nxti() { return IO::_ni(); }",
            "ll nxtl() { return IO::_nl(); }",
            "char nxtc() { return IO::_nc(); }",
            "",
            "#define ri1(a) int a = IO::_ni()",
            "#define ri2(a, b) int a = IO::_ni(); int b = IO::_ni()",
            "#define ri3(a, b, c) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni()",
            "#define ri4(a, b, c, d) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni(); int d = IO::_ni()",
            "#define rid1(a) int a = IO::_ni() - 1",
            "#define rid2(a, b) int a = IO::_ni() - 1; int b = IO::_ni() - 1",
            "#define rid3(a, b, c) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1",
            "#define rid4(a, b, c, d) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1; int d = IO::_ni() - 1",
            "#define rl1(a) ll a = IO::_nl()",
            "#define rl2(a, b) ll a = IO::_nl(); ll b = IO::_nl()",
            "#define rl3(a, b, c) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl()",
            "#define rl4(a, b, c, d) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl(); ll d = IO::_nl()",
            "#define rd1(a) db a = IO::_nf()",
            "#define rd2(a, b) db a = IO::_nf(); db b = IO::_nf()",
            "#define rd3(a, b, c) a = IO::_nf(); b = IO::_nf(); c = IO::_nf()",
            "#define rd4(a, b, c, d) a = IO::_nf(); b = IO::_nf(); c = IO::_nf(), d = IO::_nf()",
            "#define rc1(a) char a = IO::_nc()",
            "#define rc2(a, b) char a = IO::_nc(); char b = IO::_nc()",
            "#define rc3(a, b, c) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc()",
            "#define rc4(a, b, c, d) char a = IO::_nc(); char b = IO::_nc(); char c = IO::_nc(); char d = IO::_nc()",
            "#define rs1(a) string a = IO::_ns()",
            "#define rs2(a, b) string a = IO::_ns(); string b = IO::_ns()",
            "#define rvi(a, n) vi a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvid(a, n) vi a(n); FOR (i, n) IO::_ri(a[i]), a[i]--;",
            "#define rvl(a, n) vl a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvb(a, n) vb a(n); FOR (i, n) a[i] = (nxtc() == '1')",
            "",
            "#define ri(...) VFUNC(ri, __VA_ARGS__)",
            "#define rid(...) VFUNC(rid, __VA_ARGS__)",
            "#define rl(...) VFUNC(rl, __VA_ARGS__)",
            "#define rd(...) VFUNC(rd, __VA_ARGS__)",
            "#define rc(...) VFUNC(rc, __VA_ARGS__)",
            "#define rs(...) VFUNC(rs, __VA_ARGS__)",
            "",
            "const int inf = 1e9;",
            "const ll INF = 1e18;",
            "const db eps = 1e-9;",
            "",
            "vi make_perm(int n) { vi ret(n); iota(all(ret), 0); return ret; }",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "#ifdef LOCAL",
            "template <typename T, typename... V>",
            "void printer(string pfx, const char *names, T&& head, V&& ...tail) {",
            "\tint i = 0, brackets = 0;",
            "\twhile (names[i] && (names[i] != ',' || brackets)) {",
            "\t\tif (names[i] == '(' || names[i] == '{') brackets++;",
            "\t\tif (names[i] == ')' || names[i] == '}') brackets--;",
            "\t\ti++;",
            "\t}",
            "\tconstexpr bool is_str = is_same_v<decay_t<T>, const char*>;",
            "\tif (is_str) cerr << \" \" << head;",
            "\telse cerr << pfx, cerr.write(names, i) << \" = \" << head; ",
            "\tif constexpr (sizeof...(tail)) printer(is_str ? \"\" : \",\", names + i + 1, tail...);",
            "\telse cerr << endl;",
            "}",
            "",
            "#define dbg(...) printer(to_string(__LINE__) + \": \", #__VA_ARGS__, __VA_ARGS__)",
            "#else",
            "#define dbg(x...)",
            "#define cerr if (0) std::cerr",
            "#endif",
            "",
            "#define uid uniform_int_distribution",
            "#define urd uniform_real_distribution",
            "",
            "double get_time() { timeval tv; gettimeofday(&tv, NULL); return tv.tv_sec + tv.tv_usec * 1e-6; }",
            "double start_time;",
            "double elapsed() { return get_time() - start_time; }",
            "",
            "uniform_real_distribution<db> rdist(0, 1);",
            "inline db next_double() { return rdist(mt); }",
            "",
            "// start and end temperatures (dependant on cost function)",
            "db t0 = 1e9;",
            "const db tn = 0.0001;",
            "const db maximise_score = 1; // 1 = maximise, -1 = mininise",
            "const db MAX_TIME = 0.995; // seconds",
            "",
            "ifstream fin;",
            "ofstream fout;",
            " ",
            "// stuff",
            "",
            "$0",
            "",
            "// end stuff",
            " ",
            "struct State {",
            "\tdb value;",
            "",
            "\tdb calc_value() {",
            "\t\tdb tot = 0;",
            "",
            " ",
            "\t\treturn value = tot;",
            "\t}",
            " ",
            "\tvoid get_neighbour() { // modify current state into some neighbour state",
            "",
            "\t}",
            " ",
            "\tvoid print_state() {",
            "\t\tcerr << \"cost: \" << value;",
            "\t}",
            " ",
            "\tdb comp(const State& b) { // positive if a < b (b is better than a) ",
            "\t\treturn value - b.value;",
            "\t}",
            "};",
            " ",
            "State best;",
            "",
            "void solve(int test_case) {",
            "",
            "\tcerr << \"\\nsolving test case \" << test_case << endl;",
            "",
            "\tfin = ifstream(\"\" + to_string(test_case) + \".in\");",
            "\tfout = ofstream(\"\" + to_string(test_case) + \".out\");",
            "",
            "\tstart_time = get_time();",
            "",
            "\tState cur {};",
            "",
            "\t// input (and set cur state)",
            "",
            "",
            "",
            "\t// end input",
            " ",
            "\tint its = 0;",
            "",
            "\tcur.calc_value();",
            "\tbest = cur;",
            "",
            "\t// t0 = cur.value;",
            "",
            "\twhile (true) {",
            "\t\tits++;",
            "\t\tdb time_passed = elapsed() / MAX_TIME;",
            "\t\tif (time_passed > 1) break;",
            "\t\t",
            "\t\tState neighbour = cur;",
            "\t\tneighbour.get_neighbour();",
            "\t\tneighbour.calc_value();",
            "",
            "\t\tdb temp = t0 * pow(tn / t0, time_passed);",
            "",
            "\t\tif ((neighbour.value - cur.value) * maximise_score >= 0 || next_double() < exp(((neighbour.value - cur.value) * maximise_score) / temp)) { ",
            "\t\t\tcur = neighbour;",
            "\t\t}",
            " ",
            "\t\tif ((cur.value - best.value) * maximise_score > 0) {",
            "\t\t\tbest = cur;",
            "\t\t}",
            "\t}",
            " ",
            "\tcerr << \"Time elapsed: \" << elapsed() << endl;",
            "\tcerr << \"States checked: \" << its << endl;",
            "\tbest.print_state();",
            "} ",
            "",
            "main() {",
            "\tIO::initO();",
            "\tvt<int> cases = {1};",
            "",
            "\tfor (int i : cases) {",
            "\t\tsolve(i);",
            "\t}",
            "}"
        ]
    },
    "stt": {
        "prefix": "stt",
        "body": [
            "struct Path { };",
            "struct Child { };",
            "",
            "// merge path clusters a and b, with b being closer to the root",
            "Path merge_paths(const Path& a, const Path& b) {",
            "\treturn {};",
            "}",
            "",
            "// attach child cluster b to unit path cluster a",
            "Path attach_child(const Path& a, const Child& b) {",
            "\treturn {};",
            "}",
            "",
            "Child merge_children(const Child& a, const Child& b) {",
            "\treturn {};",
            "}",
            "",
            "Child make_child(const Path& a) {",
            "\treturn {};",
            "}",
            "",
            "enum Type { MakeVertex, MergePaths, AttachChild, MergeChildren, MakeChild };",
            "",
            "struct StaticTopTree {",
            "\tint n;",
            "\tvector<vector<int>> adj;",
            "\tint root, stt_root;",
            "\tvector<int> par, lc, rc;",
            "\tvector<Type> type;",
            "\tint nxt;",
            "",
            "\tvector<Path> path;",
            "\tvector<Child> child;",
            "\tfunction<Path(int)> make_vertex;",
            "",
            "\tvoid init(int _n, vector<vector<int>>& _adj, function<Path(int)> _make_vertex, int _root = 0) {",
            "\t\tn = _n;",
            "\t\tadj = _adj;",
            "\t\tmake_vertex = _make_vertex;",
            "\t\troot = _root;",
            "\t\ttype.resize(4 * n);",
            "\t\tpar = lc = rc = vector<int>(4 * n, -1);",
            "\t\tpath.resize(4 * n);",
            "\t\tchild.resize(4 * n);",
            "\t\tnxt = n;",
            "\t\tbuild_stt();",
            "\t\tbuild(stt_root);",
            "\t}",
            "",
            "\tvoid build(int u = -2) {",
            "\t\tif (u == -1) return;",
            "\t\tbuild(lc[u]);",
            "\t\tbuild(rc[u]);",
            "\t\tpull(u);",
            "\t}",
            "",
            "\tvoid update(int u) {",
            "\t\twhile (u != -1) pull(u), u = par[u];",
            "\t}",
            "",
            "\tPath query() {",
            "\t\treturn path[stt_root];",
            "\t}",
            "",
            "\tPath query(int u) {",
            "\t\tPath res = path[u];",
            "\t\twhile (true) {",
            "\t\t\tint p = par[u];",
            "\t\t\tif (p == -1 || type[p] != MergePaths) break;",
            "\t\t\tif (rc[p] == u) res = merge_paths(path[lc[p]], res);",
            "\t\t\tu = p;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvoid print_stt(int u = -2) {",
            "\t\tif (u == -2) {",
            "\t\t\tu = stt_root;",
            "\t\t\tfor (int i = 0; i <= stt_root; i++) {",
            "\t\t\t\tcerr << i << \": \";",
            "\t\t\t\tswitch (type[i]) {",
            "\t\t\t\t\tcase MakeVertex:",
            "\t\t\t\t\t\tcerr << \"MakeVertex\";",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t\tcase MergePaths:",
            "\t\t\t\t\t\tcerr << \"MergePaths\";",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t\tcase AttachChild:",
            "\t\t\t\t\t\tcerr << \"AttachChild\";",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t\tcase MergeChildren:",
            "\t\t\t\t\t\tcerr << \"MergeChildren\";",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t\tcase MakeChild:",
            "\t\t\t\t\t\tcerr << \"MakeChild\";",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tcerr << endl;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (u == -1) return;",
            "\t\tprint_stt(lc[u]);",
            "\t\tprint_stt(rc[u]);",
            "\t\tif (~lc[u]) cerr << lc[u] << \" \" << u << endl;",
            "\t\tif (~rc[u]) cerr << rc[u] << \" \" << u << endl;",
            "\t}",
            "",
            "\tprivate:",
            "\tint dfs(int u) {",
            "\t\tint sz = 1, mx = 0;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\tadj[v].erase(find(adj[v].begin(), adj[v].end(), u));",
            "\t\t\tint res = dfs(v);",
            "\t\t\tsz += res;",
            "\t\t\tif (res > mx) mx = res, swap(v, adj[u][0]);",
            "\t\t}",
            "\t\treturn sz;",
            "\t}",
            "",
            "\tint add(int u, int l, int r, Type t) {",
            "\t\tif (u == -1) u = nxt++;",
            "\t\tpar[u] = -1, lc[u] = l, rc[u] = r, type[u] = t;",
            "\t\tif (l != -1) par[l] = u;",
            "\t\tif (r != -1) par[r] = u;",
            "\t\treturn u;",
            "\t}",
            "",
            "\tpair<int, int> merge(const vector<pair<int, int>>& nodes, Type t) {",
            "\t\tif (size(nodes) == 1) return nodes[0];",
            "\t\tint totsz = 0;",
            "\t\tfor (auto& [_, sz] : nodes) totsz += sz;",
            "\t\tvector<pair<int, int>> lhs, rhs;",
            "\t\tfor (auto& [i, sz] : nodes) (totsz > sz ? lhs : rhs).emplace_back(i, sz), totsz -= sz * 2;",
            "\t\tauto [l, szl] = merge(lhs, t);",
            "\t\tauto [r, szr] = merge(rhs, t);",
            "\t\treturn {add(-1, l, r, t), szl + szr};",
            "\t}",
            "",
            "\tpair<int, int> _merge_path(int u) {",
            "\t\tvector<pair<int, int>> nodes {_attach_child(u)};",
            "\t\twhile (!adj[u].empty()) nodes.push_back(_attach_child(u = adj[u][0]));",
            "\t\treverse(nodes.begin(), nodes.end());",
            "\t\treturn merge(nodes, Type::MergePaths);",
            "\t}",
            "",
            "\tpair<int, int> _merge_children(int u) {",
            "\t\tvector<pair<int, int>> nodes;",
            "\t\tfor (int j = 1; j < size(adj[u]); j++) nodes.push_back(_make_child(adj[u][j]));",
            "\t\treturn nodes.empty() ? make_pair(-1, 0) : merge(nodes, Type::MergeChildren);",
            "\t}",
            "",
            "\tpair<int, int> _make_child(int u) {",
            "\t\tauto [v, szv] = _merge_path(u);",
            "\t\treturn {add(-1, v, -1, Type::MakeChild), szv};",
            "\t}",
            "",
            "\tpair<int, int> _attach_child(int u) {",
            "\t\tauto [v, szv] = _merge_children(u);",
            "\t\treturn {add(u, -1, v, v == -1 ? Type::MakeVertex : Type::AttachChild), szv + 1};",
            "\t}",
            "",
            "\tvoid pull(int u) {",
            "\t\tswitch (type[u]) {",
            "\t\t\tcase MakeVertex:",
            "\t\t\t\tpath[u] = make_vertex(u);",
            "\t\t\tbreak;",
            "\t\t\tcase MergePaths:",
            "\t\t\t\tpath[u] = merge_paths(path[lc[u]], path[rc[u]]);",
            "\t\t\tbreak;",
            "\t\t\tcase AttachChild:",
            "\t\t\t\tpath[u] = attach_child(make_vertex(u), child[rc[u]]);",
            "\t\t\tbreak;",
            "\t\t\tcase MergeChildren:",
            "\t\t\t\tchild[u] = merge_children(child[lc[u]], child[rc[u]]);",
            "\t\t\tbreak;",
            "\t\t\tcase MakeChild:",
            "\t\t\t\tchild[u] = make_child(path[lc[u]]);",
            "\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tvoid build_stt() {",
            "\t\tdfs(root);",
            "\t\tauto [i, n] = _merge_path(root);",
            "\t\tstt_root = i;",
            "\t}",
            "};"
        ]
    },
    "sparsetable": {
        "prefix": "sparsetable",
        "body": [
            "template<class T> struct RMQ {",
            "\t#define func min",
            "\tvector<vector<T>> dp;",
            "\tvoid init(const vector<T>& v) {",
            "\t\tdp.resize(32 - __builtin_clz(size(v)), vector<T>(size(v)));",
            "\t\tcopy(v.begin(), v.end(), begin(dp[0]));",
            "\t\tfor (int j = 1; 1 << j <= size(v); ++j) {",
            "\t\t\tfor (int i = 0; i < size(v) - (1 << j) + 1; i++) dp[j][i] = func(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l);",
            "\t\treturn func(dp[d][l], dp[d][r - (1 << d)]); ",
            "\t}",
            "\t#undef func",
            "};"
        ]
    },
    "lazyseg": {
        "prefix": "lazyseg",
        "body": [
            "struct Lazy {",
            "\tll v;",
            "\tbool inc;",
            "\tvoid operator+=(const Lazy &b) {",
            "\t\tif (b.inc) v += b.v;",
            "\t\telse v = b.v, inc = false;",
            "\t}",
            "};",
            " ",
            "struct Node {",
            "\tll mx, sum;",
            "\tNode operator+(const Node &b) {",
            "\t\treturn {max(mx, b.mx), sum + b.sum};",
            "\t}",
            "\tvoid upd(const Lazy &u, int l, int r) {",
            "\t\tif (!u.inc) mx = sum = 0;",
            "\t\tmx += u.v, sum += u.v * (r - l);",
            "\t}",
            "};",
            "",
            "const Lazy LID = {0, true};",
            "const Node NID = {-INF, 0};",
            " ",
            "struct LazySeg { ",
            "\tint n;",
            "\tvt<Node> seg;",
            "\tvt<Lazy> lazy;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n, NID);",
            "\t\tlazy.resize(2 * n, LID);",
            "\t}",
            "\tvoid pull(int i) {",
            "\t\tseg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tvoid push(int i, int l, int r) {",
            "\t\tseg[i].upd(lazy[i], l, r);",
            "\t\tif (r - l > 1) FOR (j, 2) lazy[2 * i + j] += lazy[i];",
            "\t\tlazy[i] = LID;",
            "\t}",
            "\tvoid build() {",
            "\t\tfor (int i = n - 1; i > 0; i--) pull(i);",
            "\t}",
            "\tvoid upd(int lo, int hi, Lazy val) { upd(lo, hi, val, 1, 0, n); }",
            "\tvoid upd(int lo, int hi, Lazy val, int i, int l, int r) {",
            "\t\tif (r == -1) r = n;",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy[i] += val;",
            "\t\t\tpush(i, l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tupd(lo, hi, val, 2 * i, l, m);",
            "\t\tupd(lo, hi, val, 2 * i + 1, m, r);",
            "\t\tpull(i);",
            "\t}",
            "\tNode query() { return query(0, n, 1, 0, n); }",
            "\tNode query(int lo, int hi) { return query(lo, hi, 1, 0, n); }",
            "\tNode query(int lo, int hi, int i, int l, int r) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return NID;",
            "\t\tif (lo <= l && r <= hi) return seg[i];",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m, r);",
            "\t}",
            "\tNode& operator[](int i) {",
            "\t\treturn seg[i + n];",
            "\t}",
            "};"
        ]
    },
}