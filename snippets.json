{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"tmpaio": {
        "prefix": "tmpaio",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "using ll = long long;",
            "#define all(x) (x).begin(), (x).end()",
            "",
            "main() {",
            "\t#ifndef LOCAL",
            "\tfreopen(\"in.txt\", \"r\", stdin);",
            "\tfreopen(\"out.txt\", \"w\", stdout);",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t#endif",
            "",
            "\t$0",
            "}",
            "",
            ""
        ]
    },
    "tmpcf": {
        "prefix": "tmpcf",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <ext/random>",
            "",
            "using namespace std;",
            "",
            "// #pragma GCC optimize(\"O3,unroll-loops\")",
            "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "const int precision = 24;",
            "using db = long double;",
            "",
            "template<class T> using vt = vector<T>;",
            "using str = string;",
            "using ll = long long;",
            "using pi = pair<int, int>;",
            "using pl = pair<ll, ll>;",
            "using pd = pair<db, db>;",
            "using vi = vt<int>;",
            "using vl = vt<ll>;",
            "using vb = vt<bool>;",
            "using vvi = vt<vt<int>>;",
            "using vvl = vt<vt<ll>>;",
            "using vvb = vt<vt<bool>>;",
            "using vpi = vt<pi>;",
            "using vpl = vt<pl>;",
            "",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define bg(x) begin(x)",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define size(x) ((int) (x).size())",
            "#define sq(x) ((x) * (x))",
            "#define rsz resize",
            "#define ins insert",
            "#define ft front()",
            "#define bk back()",
            "#ifndef LOCAL",
            "#define endl '\\n'",
            "#endif",
            "",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "template<class T> int lwb(vt<T>& a, const T& b) { return int(lb(all(a), b) - bg(a)); }",
            "template<class T> int upb(vt<T>& a, const T& b) { return int(ub(all(a), b) - bg(a)); }",
            "template<class T> void rem_dup(vt<T>& v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "#define cmp(exp) [&] (const auto& x, const auto& y) { return exp; }",
            "",
            "#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())",
            "#define __NARG_I_(...) __ARG_N(__VA_ARGS__)",
            "#define __ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N",
            "#define __RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
            "",
            "#define _VFUNC_(name, n) name##n",
            "#define _VFUNC(name, n) _VFUNC_(name, n)",
            "#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)",
            "",
            "#define FOR3(i, a, b) for (int i = (a); i < (b); i++)",
            "#define FOR2(i, b) for (int i = 0; i < (b); i++)",
            "#define ROF3(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "#define ROF2(i, b) for (int i = (b) - 1; i >= 0; i--)",
            "#define rep(x) FOR (_, x)",
            "",
            "#define each2(a, x) for (auto& a : x)",
            "#define each3(a, b, x) for (auto& [a, b] : x)",
            "#define each4(a, b, c, x) for (auto& [a, b, c] : x)",
            "",
            "#define enum3(i, a, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& a = *it; 1)",
            "#define enum4(i, a, b, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b] = *it; 1)",
            "#define enum5(i, a, b, c, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define FOR(...) VFUNC(FOR, __VA_ARGS__)",
            "#define ROF(...) VFUNC(ROF, __VA_ARGS__)",
            "#define each(...) VFUNC(each, __VA_ARGS__)",
            "#define enum(...) VFUNC(enum, __VA_ARGS__)",
            "",
            "__gnu_cxx::sfmt19937 mt((uint32_t) chrono::steady_clock::now().time_since_epoch().count());",
            "const ll mod = 1e9 + 7;",
            "ll mpow(ll x, ll y = mod - 2) {",
            "\tll res = 1;",
            "\tfor (; y; x = (x * x) % mod, y >>= 1) if (y & 1) res = (res * x) % mod;",
            "\treturn res;",
            "}",
            "ll gen(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(mt); }",
            "",
            "int rs, cs;",
            "const int dr[5] {0, -1, 0, 1, 0}, dc[5] {1, 0, -1, 0, 0};",
            "bool valid(int r, int c) { return r >= 0 && c >= 0 && r < rs && c < cs; }",
            "vpi get_adj(int r, int c) {",
            "\tvpi ret(4);",
            "\tFOR (i, 4) ret[i] = {r + dr[i], c + dc[i]};",
            "\treturn ret;",
            "}",
            "vpi get_valid_adj(int r, int c) {",
            "\tvpi ret;",
            "\tFOR (i, 4) {",
            "\t\tint nr = r + dr[i];",
            "\t\tint nc = c + dc[i];",
            "\t\tif (valid(nr, nc)) ret.eb(nr, nc);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); }",
            "constexpr int pct(ll x) { return __builtin_popcountll(x); }",
            "constexpr int p2(int x) { return 1 << x; }",
            "constexpr int msk2(int x) { return p2(x) - 1; }",
            "",
            "ll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }",
            "",
            "namespace IO {",
            "#ifndef LOCAL",
            "\tconst int BSZ = 1 << 15;",
            "\tchar ibuf[BSZ]; int ipos, ilen;",
            "\tchar _next_char() {",
            "\t\tif (ipos == ilen) {",
            "\t\t\tipos = 0;",
            "\t\t\tilen = fread(ibuf, 1, BSZ, stdin);",
            "\t\t\tif (!ilen) return EOF;",
            "\t\t}",
            "\t\treturn ibuf[ipos++];",
            "\t}",
            "\tchar _nc() {",
            "\t\tchar ch;",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t\treturn ch;",
            "\t}",
            "\tvoid _rc(char& ch) {",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t}",
            "\tstring _ns() {",
            "\t\tstring x;",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t\treturn x;",
            "\t}",
            "\tvoid _rs(string& x) {",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t}",
            "\tint _ni() {",
            "\t\tint x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\tll _nl() {",
            "\t\tll x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\ttemplate<class T> void _ri(T& x) {",
            "\t\tchar ch;",
            "\t\tint sgn = 1;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\tx *= sgn;",
            "\t}",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { _ri(t); _ri(ts...); }",
            "\tchar obuf[BSZ], numBuf[100]; int opos;",
            "\tvoid flushOut() {",
            "\t\tfwrite(obuf, 1, opos, stdout); opos = 0;",
            "\t}",
            "\tvoid _wc(char c) {",
            "\t\tif (opos == BSZ) flushOut();",
            "\t\tobuf[opos++] = c;",
            "\t}",
            "\tvoid _ws(string s) { for (char& c : s) _wc(c); }",
            "\ttemplate<class T> void _wi(T x) {",
            "\t\tif (x < 0) _wc('-'), x *= -1;",
            "\t\tint len = 0;",
            "\t\tfor (; x >= 10; x /= 10) numBuf[len++] = '0' + (x % 10);",
            "\t\t_wc('0' + x);",
            "\t\tfor (int i = len - 1; i >= 0; i--) _wc(numBuf[i]);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) {",
            "\t\tstr in; _rs(in); x = stold(in);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) {",
            "\t\tostringstream sout;",
            "\t\tsout << std::fixed << std::setprecision(precision) << x;",
            "\t\tstr out = sout.str();",
            "\t\teach(c, out) _wc(c);",
            "\t}",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { assert(atexit(flushOut) == 0); }",
            "#else",
            "\tchar _nc() { char ch; cin >> ch; return ch; }",
            "\tvoid _rc(char& ch) { cin >> ch; }",
            "\tstring _ns() { string x; cin >> x; return x; }",
            "\tvoid _rs(string& x) { cin >> x; }",
            "\tint _ni() { int x; cin >> x; return x; }",
            "\tll _nl() { ll x; cin >> x; return x; }",
            "\ttemplate<class T> void _ri(T& x) { cin >> x; }",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { ri(t); ri(ts...); }",
            "\tvoid _wc(char c) {",
            "\t\tif (c == '\\n') cout << endl;",
            "\t\telse cout << c;",
            "\t}",
            "\tvoid _ws(string s) { cout << s; }",
            "\ttemplate<class T> void _wi(T x) { cout << x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) { cin >> x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) { cout << std::fixed << std::setprecision(precision) << x; }",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { cin.tie(0)->sync_with_stdio(0); }",
            "#endif",
            "}",
            "",
            "void setfileaio(string name) {",
            "#ifndef LOCAL",
            "\tif (name == \"\") return;",
            "\tfreopen((name + \"in.txt\").c_str(), \"r\", stdin);",
            "\tfreopen((name + \"out.txt\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "void setfile(string pfx) {",
            "#ifndef LOCAL",
            "\tif (pfx == \"\") return;",
            "\tfreopen((pfx + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((pfx + \".out\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "template<typename... Args> // tuples",
            "ostream& operator<<(ostream& os, tuple<Args...> t) {",
            "\tapply([&](Args... args) { string dlm = \"{\"; ((os << dlm << args, dlm = \", \"), ...); }, t);",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<typename T, typename V> // pairs",
            "ostream& operator<<(ostream& os, pair<T, V> p) { return os << \"{\" << p.f << \", \" << p.s << \"}\"; }",
            "",
            "template<typename T, typename V>",
            "istream& operator>>(istream& os, pair<T, V> p) { return os >> p.f >> p.s; }",
            "",
            "template<class T, class = decltype(begin(declval<T>()))> // iterables",
            "typename enable_if<!is_same<T, string>::value, ostream&>::type operator<<(ostream& os, const T& v) {",
            "\tos << \"{\";",
            "\tstring dlm = \"\";",
            "\tfor (auto i : v) os << dlm << i, dlm = \", \";",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value, istream&>::type operator>>(istream& os, T& v) {",
            "\tfor (auto& i : v) os >> i;",
            "\treturn os;",
            "}",
            "",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type read(T& x) { IO::_ri(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type read(T &x) { IO::_rf(x); }",
            "void read(bool& x) { char c; read(c); x = (c == '1'); }",
            "void read(string& x) { IO::_rs(x); }",
            "template<class T, class U> void read(pair<T, U>& x) { read(x.f); read(x.s); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type read(T& v) { for (auto& i : v) read(i); }",
            "template<class T, class... Ts> void read(T& t, Ts&... ts) { read(t); read(ts...); }",
            "",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type _print(T x) { IO::_wi(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type _print(T& x) { IO::_wf(x); }",
            "void _print(const bool& x) { IO::_wi(x); }",
            "void _print(const char& c) { IO::_wc(c); }",
            "void _print(const string& x) { IO::_ws(x); }",
            "void _print(const char* x) { IO::_ws(x); }",
            "template<class T, class U>",
            "void _print(const pair<T, U>& x) { _print(x.first); _print(' '); _print(x.second); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type _print(const T& v) { each(i, v) _print(i), _print(' '); }",
            "template<class T> void print(const T& t) { _print(t); _print(' '); }",
            "template<class T, class... Ts> void print(const T& t, const Ts&... ts) { _print(t); _print(' '); print(ts...); }",
            "template <typename T>",
            "void print(initializer_list<T> args) { each(e, args) _print(e); }",
            "void println() { _print('\\n'); }",
            "template<class T> void println(const T& t) { _print(t); _print('\\n'); }",
            "template<class T, class... Ts> void println(const T& t, const Ts&... ts) { _print(t); _print(' '); println(ts...); }",
            "template<class T>",
            "void println(initializer_list<T> args) { each(e, args) _print(e); _print('\\n'); }",
            "",
            "int nxti() { return IO::_ni(); }",
            "ll nxtl() { return IO::_nl(); }",
            "char nxtc() { return IO::_nc(); }",
            "",
            "#define ri1(a) int a = IO::_ni()",
            "#define ri2(a, b) int a = IO::_ni(); int b = IO::_ni()",
            "#define ri3(a, b, c) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni()",
            "#define ri4(a, b, c, d) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni(); int d = IO::_ni()",
            "#define rid1(a) int a = IO::_ni() - 1",
            "#define rid2(a, b) int a = IO::_ni() - 1; int b = IO::_ni() - 1",
            "#define rid3(a, b, c) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1",
            "#define rid4(a, b, c, d) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1; int d = IO::_ni() - 1",
            "#define rl1(a) ll a = IO::_nl()",
            "#define rl2(a, b) ll a = IO::_nl(); ll b = IO::_nl()",
            "#define rl3(a, b, c) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl()",
            "#define rl4(a, b, c, d) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl(); ll d = IO::_nl()",
            "#define rd1(a) db a = IO::_nf()",
            "#define rd2(a, b) db a = IO::_nf(); db b = IO::_nf()",
            "#define rd3(a, b, c) a = IO::_nf(); b = IO::_nf(); c = IO::_nf()",
            "#define rd4(a, b, c, d) a = IO::_nf(); b = IO::_nf(); c = IO::_nf(), d = IO::_nf()",
            "#define rc(a) char a = IO::_nc()",
            "#define rs1(a) string a = IO::_ns()",
            "#define rs2(a, b) string a = IO::_ns(); string b = IO::_ns()",
            "#define rvi(a, n) vi a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvid(a, n) vi a(n); FOR (i, n) IO::_ri(a[i]), a[i]--;",
            "#define rvl(a, n) vl a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvb(a, n) vb a(n); FOR (i, n) a[i] = (nxtc() == '1')",
            "",
            "#define ri(...) VFUNC(ri, __VA_ARGS__)",
            "#define rid(...) VFUNC(rid, __VA_ARGS__)",
            "#define rl(...) VFUNC(rl, __VA_ARGS__)",
            "#define rd(...) VFUNC(rd, __VA_ARGS__)",
            "#define rs(...) VFUNC(rs, __VA_ARGS__)",
            "",
            "const int inf = 1e9;",
            "const ll INF = 1e18;",
            "const db eps = 1e-9;",
            "",
            "vi make_perm(int n) { vi ret(n); iota(all(ret), 0); return ret; }",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "/*",
            "",
            "",
            "",
            "*/",
            "",
            "struct Solver {",
            "",
            "\tvoid sovle() {",
            "\t\t$0",
            "\t}",
            "};",
            "",
            "main() {",
            "\tsetfileaio(\"\");",
            "\tsetfile(\"\");",
            "\tIO::initO();",
            "",
            "\tri(t); FOR (i, t)",
            "\t{",
            "\t\tSolver solver {}; solver.sovle();",
            "\t}",
            "}"
        ]
    },
	"tmpioi": {
        "prefix": "tmpioi",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "using ll = long long;",
            "#define vt vector",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define all(x) x.begin(), x.end() ",
            "#define size(x) ((int) (x).size())",
            "#define FOR(i, a, b) for (int i = (a); i < (b); i++)",
            "#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "#define F0R(i, b) FOR (i, 0, b)",
            "#define endl '\\n'",
            "const ll INF = 1e18;",
            "",
            "main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\t",
            "\t$0",
            "}"
        ]
    },	
	"tmp": {
        "prefix": "tmp",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <ext/random>",
            "",
            "using namespace std;",
            "",
            "// #pragma GCC optimize(\"O3,unroll-loops\")",
            "// #pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
            "",
            "const int precision = 24;",
            "using db = long double;",
            "",
            "template<class T> using vt = vector<T>;",
            "using str = string;",
            "using ll = long long;",
            "using pi = pair<int, int>;",
            "using pl = pair<ll, ll>;",
            "using pd = pair<db, db>;",
            "using vi = vt<int>;",
            "using vl = vt<ll>;",
            "using vb = vt<bool>;",
            "using vvi = vt<vt<int>>;",
            "using vvl = vt<vt<ll>>;",
            "using vvb = vt<vt<bool>>;",
            "using vpi = vt<pi>;",
            "using vpl = vt<pl>;",
            "",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define bg(x) begin(x)",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define size(x) ((int) (x).size())",
            "#define sq(x) ((x) * (x))",
            "#define rsz resize",
            "#define ins insert",
            "#define ft front()",
            "#define bk back()",
            "#ifndef LOCAL",
            "#define endl '\\n'",
            "#endif",
            "",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "template<class T> int lwb(vt<T>& a, const T& b) { return int(lb(all(a), b) - bg(a)); }",
            "template<class T> int upb(vt<T>& a, const T& b) { return int(ub(all(a), b) - bg(a)); }",
            "template<class T> void rem_dup(vt<T>& v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "#define cmp(exp) [&] (const auto& x, const auto& y) { return exp; }",
            "",
            "#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())",
            "#define __NARG_I_(...) __ARG_N(__VA_ARGS__)",
            "#define __ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N",
            "#define __RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
            "",
            "#define _VFUNC_(name, n) name##n",
            "#define _VFUNC(name, n) _VFUNC_(name, n)",
            "#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)",
            "",
            "#define FOR3(i, a, b) for (int i = (a); i < (b); i++)",
            "#define FOR2(i, b) for (int i = 0; i < (b); i++)",
            "#define ROF3(i, a, b) for (int i = (b) - 1; i >= (a); i--)",
            "#define ROF2(i, b) for (int i = (b) - 1; i >= 0; i--)",
            "#define rep(x) FOR (_, x)",
            "",
            "#define each2(a, x) for (auto& a : x)",
            "#define each3(a, b, x) for (auto& [a, b] : x)",
            "#define each4(a, b, c, x) for (auto& [a, b, c] : x)",
            "",
            "#define enum3(i, a, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& a = *it; 1)",
            "#define enum4(i, a, b, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b] = *it; 1)",
            "#define enum5(i, a, b, c, x) if (int i = 0; 1) for (auto it = begin(x); it != end(x); it++, i++) if (auto& [a, b, c] = *it; 1)",
            "",
            "#define FOR(...) VFUNC(FOR, __VA_ARGS__)",
            "#define ROF(...) VFUNC(ROF, __VA_ARGS__)",
            "#define each(...) VFUNC(each, __VA_ARGS__)",
            "#define enum(...) VFUNC(enum, __VA_ARGS__)",
            "",
            "__gnu_cxx::sfmt19937 mt((uint32_t) chrono::steady_clock::now().time_since_epoch().count());",
            "const ll mod = 1e9 + 7;",
            "ll mpow(ll x, ll y = mod - 2) {",
            "\tll res = 1;",
            "\tfor (; y; x = (x * x) % mod, y >>= 1) if (y & 1) res = (res * x) % mod;",
            "\treturn res;",
            "}",
            "ll gen(ll l, ll r) { return uniform_int_distribution<ll>(l, r)(mt); }",
            "",
            "int rs, cs;",
            "const int dr[5] {0, -1, 0, 1, 0}, dc[5] {1, 0, -1, 0, 0};",
            "bool valid(int r, int c) { return r >= 0 && c >= 0 && r < rs && c < cs; }",
            "vpi get_adj(int r, int c) {",
            "\tvpi ret(4);",
            "\tFOR (i, 4) ret[i] = {r + dr[i], c + dc[i]};",
            "\treturn ret;",
            "}",
            "vpi get_valid_adj(int r, int c) {",
            "\tvpi ret;",
            "\tFOR (i, 4) {",
            "\t\tint nr = r + dr[i];",
            "\t\tint nc = c + dc[i];",
            "\t\tif (valid(nr, nc)) ret.eb(nr, nc);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); }",
            "constexpr int pct(ll x) { return __builtin_popcountll(x); }",
            "constexpr int p2(int x) { return 1 << x; }",
            "constexpr int msk2(int x) { return p2(x) - 1; }",
            "",
            "ll cdiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }",
            "",
            "namespace IO {",
            "#ifndef LOCAL",
            "\tconst int BSZ = 1 << 15;",
            "\tchar ibuf[BSZ]; int ipos, ilen;",
            "\tchar _next_char() {",
            "\t\tif (ipos == ilen) {",
            "\t\t\tipos = 0;",
            "\t\t\tilen = fread(ibuf, 1, BSZ, stdin);",
            "\t\t\tif (!ilen) return EOF;",
            "\t\t}",
            "\t\treturn ibuf[ipos++];",
            "\t}",
            "\tchar _nc() {",
            "\t\tchar ch;",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t\treturn ch;",
            "\t}",
            "\tvoid _rc(char& ch) {",
            "\t\twhile (isspace(ch = _next_char()));",
            "\t}",
            "\tstring _ns() {",
            "\t\tstring x;",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t\treturn x;",
            "\t}",
            "\tvoid _rs(string& x) {",
            "\t\tchar ch; while (isspace(ch = _next_char()));",
            "\t\tdo { x += ch; } while (!isspace(ch = _next_char()) && ch != EOF);",
            "\t}",
            "\tint _ni() {",
            "\t\tint x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\tll _nl() {",
            "\t\tll x, sgn = 1;",
            "\t\tchar ch;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\treturn x * sgn;",
            "\t}",
            "\ttemplate<class T> void _ri(T& x) {",
            "\t\tchar ch;",
            "\t\tint sgn = 1;",
            "\t\twhile (!isdigit(ch = _next_char())) if (ch == '-') sgn *= -1;",
            "\t\tx = ch - '0';",
            "\t\twhile (isdigit(ch = _next_char())) x = x * 10 + (ch - '0');",
            "\t\tx *= sgn;",
            "\t}",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { _ri(t); _ri(ts...); }",
            "\tchar obuf[BSZ], numBuf[100]; int opos;",
            "\tvoid flushOut() {",
            "\t\tfwrite(obuf, 1, opos, stdout); opos = 0;",
            "\t}",
            "\tvoid _wc(char c) {",
            "\t\tif (opos == BSZ) flushOut();",
            "\t\tobuf[opos++] = c;",
            "\t}",
            "\tvoid _ws(string s) { for (char& c : s) _wc(c); }",
            "\ttemplate<class T> void _wi(T x) {",
            "\t\tif (x < 0) _wc('-'), x *= -1;",
            "\t\tint len = 0;",
            "\t\tfor (; x >= 10; x /= 10) numBuf[len++] = '0' + (x % 10);",
            "\t\t_wc('0' + x);",
            "\t\tfor (int i = len - 1; i >= 0; i--) _wc(numBuf[i]);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) {",
            "\t\tstr in; _rs(in); x = stold(in);",
            "\t}",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) {",
            "\t\tostringstream sout;",
            "\t\tsout << std::fixed << std::setprecision(precision) << x;",
            "\t\tstr out = sout.str();",
            "\t\teach(c, out) _wc(c);",
            "\t}",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { assert(atexit(flushOut) == 0); }",
            "#else",
            "\tchar _nc() { char ch; cin >> ch; return ch; }",
            "\tvoid _rc(char& ch) { cin >> ch; }",
            "\tstring _ns() { string x; cin >> x; return x; }",
            "\tvoid _rs(string& x) { cin >> x; }",
            "\tint _ni() { int x; cin >> x; return x; }",
            "\tll _nl() { ll x; cin >> x; return x; }",
            "\ttemplate<class T> void _ri(T& x) { cin >> x; }",
            "\ttemplate<class T, class... Ts> void _ri(T& t, Ts&... ts) { ri(t); ri(ts...); }",
            "\tvoid _wc(char c) {",
            "\t\tif (c == '\\n') cout << endl;",
            "\t\telse cout << c;",
            "\t}",
            "\tvoid _ws(string s) { cout << s; }",
            "\ttemplate<class T> void _wi(T x) { cout << x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _rf(T &x) { cin >> x; }",
            "\ttemplate <typename T>",
            "\ttypename std::enable_if<std::is_floating_point<T>::value>::type _wf(T& x) { cout << std::fixed << std::setprecision(precision) << x; }",
            "\tlong double _nf() { long double x; _rf(x); return x; }",
            "\tvoid initO() { cin.tie(0)->sync_with_stdio(0); }",
            "#endif",
            "}",
            "",
            "void setfileaio(string name) {",
            "#ifndef LOCAL",
            "\tif (name == \"\") return;",
            "\tfreopen((name + \"in.txt\").c_str(), \"r\", stdin);",
            "\tfreopen((name + \"out.txt\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "void setfile(string pfx) {",
            "#ifndef LOCAL",
            "\tif (pfx == \"\") return;",
            "\tfreopen((pfx + \".in\").c_str(), \"r\", stdin);",
            "\tfreopen((pfx + \".out\").c_str(), \"w\", stdout);",
            "#endif",
            "}",
            "",
            "template<typename... Args> // tuples",
            "ostream& operator<<(ostream& os, tuple<Args...> t) {",
            "\tapply([&](Args... args) { string dlm = \"{\"; ((os << dlm << args, dlm = \", \"), ...); }, t);",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<typename T, typename V> // pairs",
            "ostream& operator<<(ostream& os, pair<T, V> p) { return os << \"{\" << p.f << \", \" << p.s << \"}\"; }",
            "",
            "template<typename T, typename V>",
            "istream& operator>>(istream& os, pair<T, V> p) { return os >> p.f >> p.s; }",
            "",
            "template<class T, class = decltype(begin(declval<T>()))> // iterables",
            "typename enable_if<!is_same<T, string>::value, ostream&>::type operator<<(ostream& os, const T& v) {",
            "\tos << \"{\";",
            "\tstring dlm = \"\";",
            "\tfor (auto i : v) os << dlm << i, dlm = \", \";",
            "\treturn os << \"}\";",
            "}",
            "",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value, istream&>::type operator>>(istream& os, T& v) {",
            "\tfor (auto& i : v) os >> i;",
            "\treturn os;",
            "}",
            "",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type read(T& x) { IO::_ri(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type read(T &x) { IO::_rf(x); }",
            "void read(bool& x) { char c; read(c); x = (c == '1'); }",
            "void read(string& x) { IO::_rs(x); }",
            "template<class T, class U> void read(pair<T, U>& x) { read(x.f); read(x.s); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type read(T& v) { for (auto& i : v) read(i); }",
            "template<class T, class... Ts> void read(T& t, Ts&... ts) { read(t); read(ts...); }",
            "",
            "template<typename T>",
            "typename enable_if<is_integral<T>::value>::type _print(T x) { IO::_wi(x); }",
            "template <typename T>",
            "typename std::enable_if<std::is_floating_point<T>::value>::type _print(T& x) { IO::_wf(x); }",
            "void _print(const bool& x) { IO::_wi(x); }",
            "void _print(const char& c) { IO::_wc(c); }",
            "void _print(const string& x) { IO::_ws(x); }",
            "void _print(const char* x) { IO::_ws(x); }",
            "template<class T, class U>",
            "void _print(const pair<T, U>& x) { _print(x.first); _print(' '); _print(x.second); }",
            "template<class T, class = decltype(begin(declval<T>()))>",
            "typename enable_if<!is_same<T, string>::value>::type _print(const T& v) { each(i, v) _print(i), _print(' '); }",
            "template<class T> void print(const T& t) { _print(t); _print(' '); }",
            "template<class T, class... Ts> void print(const T& t, const Ts&... ts) { _print(t); _print(' '); print(ts...); }",
            "template <typename T>",
            "void print(initializer_list<T> args) { each(e, args) _print(e); }",
            "void println() { _print('\\n'); }",
            "template<class T> void println(const T& t) { _print(t); _print('\\n'); }",
            "template<class T, class... Ts> void println(const T& t, const Ts&... ts) { _print(t); _print(' '); println(ts...); }",
            "template<class T>",
            "void println(initializer_list<T> args) { each(e, args) _print(e); _print('\\n'); }",
            "",
            "int nxti() { return IO::_ni(); }",
            "ll nxtl() { return IO::_nl(); }",
            "char nxtc() { return IO::_nc(); }",
            "",
            "#define ri1(a) int a = IO::_ni()",
            "#define ri2(a, b) int a = IO::_ni(); int b = IO::_ni()",
            "#define ri3(a, b, c) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni()",
            "#define ri4(a, b, c, d) int a = IO::_ni(); int b = IO::_ni(); int c = IO::_ni(); int d = IO::_ni()",
            "#define rid1(a) int a = IO::_ni() - 1",
            "#define rid2(a, b) int a = IO::_ni() - 1; int b = IO::_ni() - 1",
            "#define rid3(a, b, c) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1",
            "#define rid4(a, b, c, d) int a = IO::_ni() - 1; int b = IO::_ni() - 1; int c = IO::_ni() - 1; int d = IO::_ni() - 1",
            "#define rl1(a) ll a = IO::_nl()",
            "#define rl2(a, b) ll a = IO::_nl(); ll b = IO::_nl()",
            "#define rl3(a, b, c) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl()",
            "#define rl4(a, b, c, d) ll a = IO::_nl(); ll b = IO::_nl(); ll c = IO::_nl(); ll d = IO::_nl()",
            "#define rd1(a) db a = IO::_nf()",
            "#define rd2(a, b) db a = IO::_nf(); db b = IO::_nf()",
            "#define rd3(a, b, c) a = IO::_nf(); b = IO::_nf(); c = IO::_nf()",
            "#define rd4(a, b, c, d) a = IO::_nf(); b = IO::_nf(); c = IO::_nf(), d = IO::_nf()",
            "#define rc(a) char a = IO::_nc()",
            "#define rs1(a) string a = IO::_ns()",
            "#define rs2(a, b) string a = IO::_ns(); string b = IO::_ns()",
            "#define rvi(a, n) vi a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvid(a, n) vi a(n); FOR (i, n) IO::_ri(a[i]), a[i]--;",
            "#define rvl(a, n) vl a(n); FOR (i, n) IO::_ri(a[i])",
            "#define rvb(a, n) vb a(n); FOR (i, n) a[i] = (nxtc() == '1')",
            "",
            "#define ri(...) VFUNC(ri, __VA_ARGS__)",
            "#define rid(...) VFUNC(rid, __VA_ARGS__)",
            "#define rl(...) VFUNC(rl, __VA_ARGS__)",
            "#define rd(...) VFUNC(rd, __VA_ARGS__)",
            "#define rs(...) VFUNC(rs, __VA_ARGS__)",
            "",
            "const int inf = 1e9;",
            "const ll INF = 1e18;",
            "const db eps = 1e-9;",
            "",
            "vi make_perm(int n) { vi ret(n); iota(all(ret), 0); return ret; }",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "/*",
            "",
            "",
            "",
            "*/",
            "",
            "main() {",
            "\tsetfileaio(\"\");",
            "\tsetfile(\"\");",
            "\tIO::initO();",
            "",
            "\t$0",
            "}"
        ]
    },
    "lichao": {
        "prefix": "lichao",
        "body": [
            "struct Line {",
            "\tll m, c;",
            "\tll operator()(ll x) {",
            "\t\treturn m * x + c;",
            "\t}",
            "};",
            "",
            "const ll sz = 1ll << 30;",
            "",
            "using ptr = struct Node*;",
            "struct Node {",
            "\tptr lc, rc;",
            "\tLine line;",
            "",
            "\tNode(Line _line) {",
            "\t\tline = _line;",
            "\t\tlc = rc = 0;",
            "\t}",
            "};",
            "",
            "// min tree (flip signs for max)",
            "void add(ptr& n, Line loser, ll l = 0, ll r = sz) {",
            "\tif (n ? 0 : n = new Node(loser)) return;",
            "\tll m = (l + r) / 2;",
            "\tif (loser(m) < n->line(m)) swap(loser, n->line);",
            "\tif (r - l == 1) return;",
            "\tif (loser(l) < n->line(l)) add(n->lc, loser, l, m);",
            "\telse add(n->rc, loser, m, r);",
            "}",
            "",
            "ll query(ptr n, ll x, ll l = 0, ll r = sz) {",
            "\tif (!n) return sz;",
            "\tll m = (l + r) / 2;",
            "\tif (x < m) return min(n->line(x), query(n->lc, x, l, m));",
            "\telse return min(n->line(x), query(n->rc, x, m, r));",
            "}"
        ]
    },
    "moncht": {
        "prefix": "moncht",
        "body": [
            "// u can usually just get away with a / b",
            "ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down",
            "",
            "struct Line {",
            "\tll m, c;",
            " ",
            "\tll inter(Line& oth) {",
            "\t\treturn (c - oth.c) / (oth.m - m);",
            "\t}",
            " ",
            "\tll operator()(ll x) {",
            "\t\treturn x * m + c;",
            "\t}",
            "};",
            " ",
            "struct CHT {",
            "\t\t// always draw out the hull on paper just to be safe",
            "\tdeque<Line> hull;",
            " ",
            "\t// dependent on query",
            "\t// compare new line with first, and first with second",
            "\tvoid add(Line l) {",
            "\t\twhile (size(hull) >= 2 && hull[0].inter(l) <= hull[1].inter(hull[0])) hull.pop_front();",
            "\t\thull.push_front(l);",
            "\t}",
            " ",
            "\tll query(ll x) {",
            "\t\twhile (size(hull) >= 2 && hull.end()[-1](x) >= hull.end()[-2](x)) hull.pop_back();",
            "\t\treturn hull.back()(x);",
            "\t}",
            "};"
        ]
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct DSU {",
            "\tvt<int> e; ",
            "\tvoid init(int n) { ",
            "\t\te.resize(n, -1);",
            "\t}",
            "\tint find(int x) { ",
            "\t\treturn e[x] < 0 ? x : e[x] = find(e[x]); ",
            "\t}   ",
            "\tbool unite(int x, int y) {",
            "\t\tx = find(x), y = find(y); ",
            "\t\tif (x == y) return 0;",
            "\t\tif (e[x] > e[y]) swap(x,y);",
            "\t\te[x] += e[y]; ",
            "\t\te[y] = x; ",
            "\t\treturn 1;",
            "\t}",
            "\t// optional",
            "\tbool sameSet(int a, int b) { ",
            "\t\treturn find(a) == find(b); ",
            "\t}",
            "\tint sz(int x) {",
            "\t\treturn -e[find(x)]; ",
            "\t}",
            "};"
        ]
    },
    "dsurb": {
        "prefix": "dsurbh",
        "body": [
            "struct DSU {",
            "\tint n;",
            "\tvt<int> e;",
            "\tvt<vt<pi>> stk; ",
            "\tvoid init(int _n) { n = _n; e.resize(n + 1, -1); e[n] = n; }",
            "\tvoid push() { stk.pb({}); }",
            "\tvoid pop() { ",
            "\t\treverse(all(stk.back()));",
            "\t\tfor (auto [i, v] : stk.back()) e[i] = v;",
            "\t\tstk.pop_back();",
            "\t}",
            "\tvoid upd(int i, int v) { stk.back().pb({i, e[i]}); e[i] = v; }",
            "\tint find(int x) { return e[x] < 0 ? x : find(e[x]); }",
            "\tvoid unite(int x, int y) {",
            "\t\tx = find(x), y = find(y);",
            "\t\tif (x == y) return;",
            "\t\tif (e[x] < e[y]) swap(x, y);",
            "\t\tupd(y, e[x] + e[y]);",
            "\t\tupd(x, y);",
            "\t\tupd(n, e[n] - 1);",
            "\t}",
            "\tint comps() { return e[n]; }",
            "};"
        ]
    },
    "dynacon": {
        "prefix": "dynacon",
        "body": [
            "struct DynaCon {",
            "\tint n, q, t = 0;",
            "\tvt<vt<pi>> seg;",
            "\tmap<pi, int> eds;",
            "\tDSU dsu;",
            "\tvoid init(int _n, int _q) {",
            "\t\tfor (q = 1; q < _q; q *= 2);",
            "\t\tseg.resize(2 * q);",
            "\t\tdsu.init(n = _n);",
            "\t}",
            "\tvoid toggle(int u, int v, bool erase = true) {",
            "\t\tif (u > v) swap(u, v);",
            "\t\tif (eds.count({u, v})) {",
            "\t\t\tfor (int l = eds[{u, v}] + q, r = min(++t + q, 2 * q); l < r; l /= 2, r /= 2) {",
            "\t\t\t\tif (l & 1) seg[l++].pb({u, v});",
            "\t\t\t\tif (r & 1) seg[--r].pb({u, v});",
            "\t\t\t}",
            "\t\t\tif (erase) eds.erase({u, v});",
            "\t\t} else eds[{u, v}] = t++;",
            "\t}",
            "\tvoid query() { seg[q + t++].pb({-1, -1}); }",
            "\tvoid dfs(int i, vt<int>& ans) {",
            "\t\tdsu.push();",
            "\t\tfor (auto [u, v] : seg[i]) {",
            "\t\t\tif (u == -1) ans.pb(dsu.comps());",
            "\t\t\telse dsu.unite(u, v);",
            "\t\t}",
            "\t\tif (i < q) dfs(2 * i, ans), dfs(2 * i + 1, ans);",
            "\t\tdsu.pop();",
            "\t}",
            "\tvt<int> ans() {",
            "\t\tfor (auto [u, v] : eds) toggle(u.f, u.s, false);",
            "\t\tvt<int> res;",
            "\t\tdfs(1, res);",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "genseg": {
        "prefix": "genseg",
        "body": [
            "template<class T> struct SegTree {",
            "\tT ID;",
            "\tint n; ",
            "\tvt<T> seg;",
            "\tvoid init(int _n, T _ID) {",
            "\t\tID = _ID;",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.assign(2 * n, ID);",
            "\t}",
            "\tvoid upd(int i, T val) {",
            "\t\tseg[i += n] = val;",
            "\t\twhile (i /= 2) seg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tT query(int l, int r) { // inc exc",
            "\t\tT a = ID, b = ID;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) a = a + seg[l++];",
            "\t\t\tif (r & 1) b = seg[--r] + b;",
            "\t\t}",
            "\t\treturn a + b;",
            "\t}",
            "\tT& operator[](int i) {",
            "\t\treturn seg[i + n];",
            "\t}",
            "};"
        ]
    },
    "minseg": {
        "prefix": "minseg",
        "body": [
            "struct SegTree {",
            "\t#define func min",
            "\t// dont forget to change identity too",
            "\tint n;",
            "\tvt<ll> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n, INF);",
            "\t}",
            "\tvoid upd(int i, ll v) {",
            "\t\tseg[i += n] = v;",
            "\t\twhile (i /= 2) seg[i] = func(seg[2 * i], seg[2 * i + 1]);",
            "\t}",
            "\tll query(int l, int r) { // inc exc ",
            "\t\tll res = INF;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) res = func(res, seg[l++]);",
            "\t\t\tif (r & 1) res = func(seg[--r], res);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t#undef func",
            "};"
        ]
    },
    "sumseg": {
        "prefix": "sumseg",
        "body": [
            "struct SegTree {",
            "\tint n;",
            "\tvt<ll> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n);",
            "\t}",
            "\tvoid upd(int i, ll v) {",
            "\t\tseg[i += n] = v;",
            "\t\twhile (i /= 2) seg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tll query(int l, int r) { // inc exc",
            "\t\tll res = 0;",
            "\t\tfor (l += n, r += n; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) res += seg[l++];",
            "\t\t\tif (r & 1) res += seg[--r];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "sparseseg": {
        "prefix": "sparseseg",
        "body": [
            "using ptr = struct Node*;",
            "const int sz = 1 << 30;",
            "struct Node {",
            "\tint val;",
            "\tptr lc, rc;",
            "",
            "\tptr get(ptr& p) { return p ? p : p = new Node {inf}; }",
            "",
            "\tint query(int lo, int hi, int l = 0, int r = sz) {",
            "\t\tif (lo >= r || hi <= l) return inf;",
            "\t\tif (lo <= l && r <= hi) return val;",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn min(get(lc)->query(lo, hi, l, m), get(rc)->query(lo, hi, m, r));",
            "\t}",
            "",
            "\tint upd(int i, int nval, int l = 0, int r = sz) {",
            "\t\tif (l == r) return val = nval;",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) get(lc)->upd(i, nval, l, m);",
            "\t\telse get(rc)->upd(i, nval, m, r);",
            "\t\treturn val = min(get(lc)->val, get(rc)->val);",
            "\t}",
            "};"
        ]
    },
    "pseg": {
        "prefix": "pseg",
        "body": [
            "using ptr = struct Node*;",
            "const int sz = 1 << 18;",
            " ",
            "struct Node {",
            "\tint v;",
            "\tptr lc, rc;",
            " ",
            "\tptr pull(ptr lc, ptr rc) {",
            "\t\treturn new Node {min(lc->v, rc->v), lc, rc};",
            "\t}",
            " ",
            "\tptr upd(int i, int nv, int l = 0, int r = sz) {",
            "\t\tif (l == r) return new Node {nv};",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) return pull(lc->upd(i, nv, l, m), rc);",
            "\t\telse return pull(lc, rc->upd(i, nv, m, r));",
            "\t}",
            " ",
            "\tint query(int lo, int hi, int l = 0, int r = sz) {",
            "\t\tif (lo > r || hi < l) return 1e9;",
            "\t\tif (lo <= l && r <= hi) return v;",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn min(lc->query(lo, hi, l, m), rc->query(lo, hi, m, r)); ",
            "\t}",
            "};"
        ]
    },
    "lazyseg": {
        "prefix": "lazyseg",
        "body": [
            "struct Lazy {",
            "\tll v;",
            "\tbool inc;",
            "\tvoid operator+=(const Lazy &b) {",
            "\t\tif (b.inc) v += b.v;",
            "\t\telse v = b.v, inc = false;",
            "\t}",
            "};",
            " ",
            "struct Node {",
            "\tll mx, sum;",
            "\tNode operator+(const Node &b) {",
            "\t\treturn {max(mx, b.mx), sum + b.sum};",
            "\t}",
            "\tvoid upd(const Lazy &u, int l, int r) {",
            "\t\tif (!u.inc) mx = sum = 0;",
            "\t\tmx += u.v, sum += u.v * (r - l);",
            "\t}",
            "};",
            "",
            "const Lazy LID = {0, true};",
            "const Node NID = {-INF, 0};",
            " ",
            "const int sz = 1 << 17;",
            "struct LazySeg { ",
            "\tvt<Node> seg;",
            "\tvt<Lazy> lazy;",
            "\tvoid init() {",
            "\t\tseg.resize(2 * sz, NID);",
            "\t\tlazy.resize(2 * sz, LID);",
            "\t}",
            "\tvoid pull(int i) {",
            "\t\tseg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tvoid push(int i, int l, int r) {",
            "\t\tseg[i].upd(lazy[i], l, r);",
            "\t\tif (r - l > 1) FOR (j, 2) lazy[2 * i + j] += lazy[i];",
            "\t\tlazy[i] = LID;",
            "\t}",
            "\tvoid build() {",
            "\t\tfor (int i = sz - 1; i > 0; i--) pull(i);",
            "\t}",
            "\tvoid upd(int lo, int hi, Lazy val, int i = 1, int l = 0, int r = sz) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy[i] += val;",
            "\t\t\tpush(i, l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tupd(lo, hi, val, 2 * i, l, m);",
            "\t\tupd(lo, hi, val, 2 * i + 1, m, r);",
            "\t\tpull(i);",
            "\t}",
            "\tNode query(int lo = 0, int hi = sz, int i = 1, int l = 0, int r = sz) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r <= lo || l >= hi) return NID;",
            "\t\tif (lo <= l && r <= hi) return seg[i];",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m, r);",
            "\t}",
            "\tNode& operator[](int i) {",
            "\t\treturn seg[i + sz];",
            "\t}",
            "};"
        ]
    },
    "lazysparseseg": {
        "prefix": "lazysparseseg",
        "body": [
            "struct Lazy {",
            "\tint v;",
            "\tbool inc;",
            "",
            "\tvoid operator+=(const Lazy& oth) {",
            "\t\tif (!oth.inc) v = 0, inc = 0;",
            "\t\tv += oth.v;",
            "\t}",
            "};",
            "",
            "struct Val {",
            "\tll sum;",
            "\tint mx;",
            "",
            "\tVal operator+(const Val& oth) const {",
            "\t\treturn {sum + oth.sum, max(mx, oth.mx)};",
            "\t}",
            "",
            "\tvoid upd(Lazy& lazy, ll l, ll r) {",
            "\t\tif (!lazy.inc) sum = mx = 0;",
            "\t\tsum += lazy.v * (r - l);",
            "\t\tmx += lazy.v;",
            "\t}",
            "};",
            "",
            "const Lazy lid = {0, 1};",
            "const Val vid = {0, -inf};",
            "",
            "using ptr = struct Node*;",
            "const int sz = 1 << 30;",
            "struct Node {",
            "\tVal val;",
            "\tLazy lazy;",
            "\tptr lc, rc;",
            "",
            "\tptr get(ptr& p) { return p ? p : p = new Node {vid, lid}; }",
            "",
            "\tvoid push(ll l, ll r) {",
            "\t\tval.upd(lazy, l, r);",
            "\t\tif (r - l > 1) get(lc)->lazy += lazy, get(rc)->lazy += lazy;",
            "\t\tlazy = lid;",
            "\t}",
            "",
            "\tVal query(ll lo, ll hi, ll l = 0, ll r = sz) {",
            "\t\tpush(l, r);",
            "\t\tif (lo >= r || hi <= l) return vid;",
            "\t\tif (lo <= l && r <= hi) return val;",
            "\t\tll m = (l + r) / 2;",
            "\t\treturn get(lc)->query(lo, hi, l, m) + get(rc)->query(lo, hi, m, r);",
            "\t}",
            "",
            "\tvoid upd(ll lo, ll hi, Lazy v, ll l = 0, ll r = sz) {",
            "\t\tpush(l, r);",
            "\t\tif (lo >= r || hi <= l) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy += v;",
            "\t\t\tpush(l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tll m = (l + r) / 2;",
            "\t\tget(lc)->upd(lo, hi, v, l, m);",
            "\t\tget(rc)->upd(lo, hi, v, m, r);",
            "\t\tval = get(lc)->val + get(rc)->val;",
            "\t}",
            "};"
        ]
    },
    "kthmin": {
        "prefix": "kthmin",
        "body": [
            "using ptr = struct Node*;",
            "const ll sz = 1 << 30;",
            " ",
            "struct Node {",
            "\tint cnt;",
            "\tptr lc, rc;",
            " ",
            "\tptr pull(ptr lc, ptr rc) {",
            "\t\treturn new Node {lc->cnt + rc->cnt, lc, rc};",
            "\t}",
            " ",
            "\tptr upd(int i, int l = 0, int r = sz) {",
            "\t\tif (r - l == 1) return new Node {cnt + 1};",
            "\t\tint m = (l + r) / 2;",
            "\t\tif (i < m) return pull(lc->upd(i, l, m), rc);",
            "\t\telse return pull(lc, rc->upd(i, m, r));",
            "\t}",
            "};",
            "",
            "int walk(ptr lo, ptr hi, int k, int l = 0, int r = sz) {",
            "\tif (r - l == 1) return l;",
            "\tint m = (l + r) / 2;",
            "\tint lhs = hi->lc->cnt - lo->lc->cnt;",
            "\tif (lhs >= k) return walk(lo->lc, hi->lc, k, l, m);",
            "\telse return walk(lo->rc, hi->rc, k - lhs, m, r);",
            "}"
        ]
    },
    "caterpillowtree": {
        "prefix": "caterpillowtree",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "\t",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tROF (d, 0, depth) {",
            "\t\t\tseg[d][x >> 6] |= 1ull << (x & 63);",
            "\t\t\tx >>= 6;",
            "\t\t}",
            "\t} ",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tROF (d, 0, depth) {",
            "\t\t\tseg[d][x >> 6] &= ~(1ull << (x & 63));",
            "\t\t\tseg[d][x >> 6] |= b << (x & 63);",
            "\t\t\tx >>= 6;",
            "\t\t\tb = bool(seg[d][x]);",
            "\t\t}",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tx = std::max(x, 0);",
            "\t\tint d = depth - 1;",
            "\t\twhile (true) {",
            "\t\t\tif (ull m = seg[d][x >> 6] >> (x & 63)) {",
            "\t\t\t\tx += __builtin_ctzll(m);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tx = (x >> 6) + 1;",
            "\t\t\tif (d == 0 || x >= (1 << (6 * d))) return sz;",
            "\t\t\td--;",
            "\t\t}",
            "\t\twhile (++d < depth) {",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[d][x]);",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "\t\tx = std::min(x, sz - 1);",
            "\t\tint d = depth - 1;",
            "\t\twhile (true) {",
            "\t\t\tif (ull m = seg[d][x >> 6] << (63 - (x & 63))) {",
            "\t\t\t\tx -= __builtin_clzll(m);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tx = (x >> 6) - 1;",
            "\t\t\tif (d == 0 || x == -1) return -1;",
            "\t\t\td--;",
            "\t\t}",
            "\t\twhile (++d < depth) {",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[d][x]);",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "",
            "\tint min() {",
            "\t\tif (empty()) return sz;",
            "\t\tint ans = 0;",
            "\t\tFOR (d, depth) {",
            "\t\t\tans <<= 6;",
            "\t\t\tans += __builtin_ctzll(seg[d][ans >> 6]);",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "",
            "\tint max() {",
            "\t\tif (empty()) return -1;",
            "\t\tint ans = 0;",
            "\t\tFOR (d, depth) {",
            "\t\t\tans <<= 6;",
            "\t\t\tans += 63 - __builtin_clzll(seg[d][ans >> 6]);",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "",
            "\tinline bool empty() { return !seg[0][0]; }",
            "\tinline int operator[](int i) { return 1 & (seg[depth - 1][i >> 6] >> (i & 63)); }",
            "};"
        ]
    },
    "caterpillowtreeunrolled": {
        "prefix": "caterpillowtreeunrolled",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tseg[2][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[1][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[0][x >> 6] |= 1ull << (x & 63);",
            "\t}",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tseg[2][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[2][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[2][x];",
            "\t\tseg[1][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[1][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[1][x];",
            "\t\tseg[0][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[0][x >> 6] |= b << (x & 63);",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tif (ull m = seg[2][x >> 6] >> (x & 63)) return x + __builtin_ctzll(m);",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << (12))) return sz;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << 6)) return sz;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn sz;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "",
            "\t\tif (ull m = seg[2][x >> 6] << (63 - (x & 63))) return x - __builtin_clzll(m);",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "};"
        ]
    },    "caterpillowtreeunrolled": {
        "prefix": "caterpillowtreeunrolled",
        "body": [
            "using ull = unsigned long long;",
            "const int depth = 3;",
            "const int sz = 1 << (depth * 6);",
            "",
            "struct Tree {",
            "\tvt<ull> seg[depth];",
            "",
            "\tTree() {",
            "\t\tFOR (i, depth) seg[i].resize(1 << (6 * i));",
            "\t}",
            "",
            "\tvoid insert(int x) {",
            "\t\tseg[2][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[1][x >> 6] |= 1ull << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tseg[0][x >> 6] |= 1ull << (x & 63);",
            "\t}",
            "",
            "\tvoid erase(int x) {",
            "\t\tull b = 0;",
            "\t\tseg[2][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[2][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[2][x];",
            "\t\tseg[1][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[1][x >> 6] |= b << (x & 63);",
            "\t\tx >>= 6;",
            "\t\tb = !!seg[1][x];",
            "\t\tseg[0][x >> 6] &= ~(1ull << (x & 63));",
            "\t\tseg[0][x >> 6] |= b << (x & 63);",
            "\t}",
            "",
            "\tint next(int x) {",
            "\t\tif (x >= sz) return sz;",
            "\t\tif (ull m = seg[2][x >> 6] >> (x & 63)) return x + __builtin_ctzll(m);",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << (12))) return sz;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) + 1;",
            "\t\tif (x >= (1 << 6)) return sz;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] >> (x & 63)) {",
            "\t\t\tx += __builtin_ctzll(m);",
            "\t\t\tx = (x << 6) + __builtin_ctzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + __builtin_ctzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn sz;",
            "\t}",
            "",
            "\tint prev(int x) {",
            "\t\tif (x < 0) return -1;",
            "",
            "\t\tif (ull m = seg[2][x >> 6] << (63 - (x & 63))) return x - __builtin_clzll(m);",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[1][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\tx = (x >> 6) - 1;",
            "\t\tif (x == -1) return -1;",
            "",
            "\t\tif (ull m = seg[0][x >> 6] << (63 - (x & 63))) {",
            "\t\t\tx -= __builtin_clzll(m);",
            "\t\t\tx = (x << 6) + 63 - __builtin_clzll(seg[1][x]);",
            "\t\t\treturn (x << 6) + 63 - __builtin_clzll(seg[2][x]);",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "};"
        ]
    },
    "bcc": {
        "prefix": "bcc",
        "body": [
            "struct BCC { ",
            "\tint n, t; ",
            "\tvt<vt<int>> adj, comps;",
            "\tvt<int> tin, low, stk;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "",
            "\tvoid dfs(int u) {",
            "\t\ttin[u] = low[u] = ++t;",
            "\t\tstk.pb(u);   ",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tif (tin[v]) low[u] = min(low[u], tin[v]);",
            "\t\t\telse {",
            "\t\t\t\tdfs(v);",
            "\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\tif (low[v] == tin[u]) {",
            "\t\t\t\t\tcomps.pb({u});",
            "\t\t\t\t\tfor (int w = -1; w != v;) {",
            "\t\t\t\t\t\tcomps.back().pb(w = stk.back());",
            "\t\t\t\t\t\tstk.pop_back();",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid gen() {",
            "\t\tt = 0;",
            "\t\ttin = low = vt<int>(n);",
            "\t\tFOR (u, n) if (!tin[u]) dfs(u); ",
            "\t\tFOR (u, n) if (!size(adj[u])) comps.pb({u});   ",
            "\t}",
            "};"
        ]
    },
    "bct": {
        "prefix": "bct",
        "body": [
            "struct BCT { ",
            "\tint n, t = 0; ",
            "\tvt<vt<int>> adj, comps;",
            "\tvt<int> tin, low, stk, is_art;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "",
            "\tvoid dfs(int u) {",
            "\t\ttin[u] = low[u] = ++t;",
            "\t\tstk.pb(u);   ",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tif (tin[v]) low[u] = min(low[u], tin[v]);",
            "\t\t\telse {",
            "\t\t\t\tdfs(v);",
            "\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\tif (low[v] == tin[u]) {",
            "\t\t\t\t\tis_art[u] = (u != stk[0]) || tin[v] > tin[u] + 1;",
            "\t\t\t\t\tcomps.pb({u});",
            "\t\t\t\t\tfor (int w = -1; w != v;) {",
            "\t\t\t\t\t\tcomps.back().pb(w = stk.back());",
            "\t\t\t\t\t\tstk.pop_back();",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// make sure the graph is connected!",
            "\tvoid gen(int& n0, vt<vt<int>>& adj0, vt<int>& id) {",
            "\t\tt = 0;",
            "\t\ttin = low = is_art = vt<int>(n);",
            "\t\tFOR (u, n) if (!tin[u]) dfs(u); ",
            "\t\tFOR (u, n) if (!size(adj[u])) comps.pb({u});   ",
            "",
            "\t\tid.resize(n);   ",
            "\t\tFOR (u, n) {",
            "\t\t\tif (is_art[u]) {",
            "\t\t\t\tid[u] = n0++;",
            "\t\t\t\tadj0.pb({});",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfor (auto& comp : comps) {",
            "\t\t\tadj0.pb({});",
            "\t\t\tfor (int u : comp) {",
            "\t\t\t\tif (is_art[u]) {",
            "\t\t\t\t\tadj0[n0].pb(id[u]);",
            "\t\t\t\t\tadj0[id[u]].pb(n0);",
            "\t\t\t\t} else id[u] = n0;",
            "\t\t\t}",
            "\t\t\tn0++;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "template<class T> struct RMQ {",
            "\tvt<vt<T>> dp;",
            "\tvoid init(const vt<T>& v) {",
            "\t\tdp.resize(32 - __builtin_clz(size(v)), vt<T>(size(v)));",
            "\t\tcopy(all(v), begin(dp[0]));",
            "\t\tfor (int j = 1; 1 << j <= size(v); ++j) {",
            "\t\t\tFOR (i, size(v) - (1 << j) + 1) dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l + 1);",
            "\t\treturn min(dp[d][l], dp[d][r - (1 << d) + 1]); ",
            "\t}",
            "};",
            "",
            "struct LCA {",
            "\tint n; ",
            "\tvt<vt<int>> adj;",
            "\tvt<int> depth, pos, par, id;",
            "\tvt<pl> tmp; ",
            "\tRMQ<pl> rmq;",
            "\tvoid init(BCT& bct) { ",
            "\t\tn = 0;",
            "\t\tbct.gen(n, adj, id);",
            "\t\tdepth = pos = par = vt<int>(n); ",
            "\t}",
            "\tvoid dfs(int x) {",
            "\t\tpos[x] = size(tmp); ",
            "\t\ttmp.pb({depth[x], x}); ",
            "\t\tfor(int y : adj[x]) {",
            "\t\t\tif (y != par[x]) {",
            "\t\t\t\tdepth[y] = depth[par[y] = x] + 1, dfs(y);",
            "\t\t\t\ttmp.pb({depth[x], x}); ",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid gen(int rt = 0) { ",
            "\t\tpar[rt] = rt; ",
            "\t\tdfs(rt); ",
            "\t\trmq.init(tmp); ",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tu = pos[u], v = pos[v]; ",
            "\t\tif (u > v) swap(u,v);",
            "\t\treturn rmq.query(u,v).s;",
            "\t}",
            "\tint dist(int u, int v) {",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};"
        ]
    },
    "scc": {
        "prefix": "scc",
        "body": [
            "struct SCC {",
            "\tll n; ",
            "\tvt<vt<ll>> adj, radj;",
            "\tvt<ll> todo, comp, comps; ",
            "\tvt<bool> seen;",
            "\tvoid init(ll _n) { ",
            "\t\tn = _n; ",
            "\t\tadj.resize(n);",
            "\t\tradj.resize(n);",
            "\t\tcomp = vt<ll>(n, -1);",
            "\t\tseen.resize(n); ",
            "\t}",
            "\tvoid ae(ll x, ll y) { adj[x].pb(y), radj[y].pb(x); }",
            "\tvoid dfs(ll x) {",
            "\t\tseen[x] = 1; ",
            "\t\tfor(ll y : adj[x]) if (!seen[y]) dfs(y);",
            "\t\ttodo.pb(x); ",
            "\t}",
            "\tvoid dfs2(ll x, ll v) {",
            "\t\tcomp[x] = v; ",
            "\t\tfor (ll y : radj[x]) if (comp[y] == -1) dfs2(y, v); ",
            "\t}",
            "\tvoid gen() {",
            "\t\tFOR (i, n) if (!seen[i]) dfs(i);",
            "\t\treverse(all(todo)); ",
            "\t\tfor (ll x : todo) if (comp[x] == -1) dfs2(x, x), comps.pb(x);",
            "\t}",
            "};"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "// O(VE log U)",
            "",
            "struct Dinic {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tll c, oc;",
            "\t\tll flow() { return max(oc - c, 0LL); } // if you need flows",
            "\t};",
            "\tvt<int> lvl, ptr, q;",
            "\tvt<vt<Edge>> adj;",
            "",
            "\tvoid init(int n) {",
            "\t\tlvl = ptr = q = vt<int>(n);",
            "\t\tadj.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int a, int b, ll c, ll rcap = 0) {",
            "\t\tadj[a].push_back({b, size(adj[b]), c, c});",
            "\t\tadj[b].push_back({a, size(adj[a]) - 1, rcap, rcap});",
            "\t}",
            "\tll dfs(int v, int t, ll f) {",
            "\t\tif (v == t || !f) return f;",
            "\t\tfor (int& i = ptr[v]; i < size(adj[v]); i++) {",
            "\t\t\tEdge& e = adj[v][i];",
            "\t\t\tif (lvl[e.to] == lvl[v] + 1)",
            "\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {",
            "\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;",
            "\t\t\t\t\treturn p;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tll flow = 0; q[0] = s;",
            "\t\tFOR (L, 0, 31) do { // 'int L=30' maybe faster for random data",
            "\t\t\tlvl = ptr = vt<int>(size(q));",
            "\t\t\tint qi = 0, qe = lvl[s] = 1;",
            "\t\t\twhile (qi < qe && !lvl[t]) {",
            "\t\t\t\tint v = q[qi++];",
            "\t\t\t\tfor (Edge e : adj[v])",
            "\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))",
            "\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
            "\t\t\t}",
            "\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
            "\t\t} while (lvl[t]);",
            "\t\treturn flow;",
            "\t}",
            "\tbool leftOfMinCut(int a) { return lvl[a] != 0; }",
            "};"
        ]
    },
    "pushrelabel": {
        "prefix": "pushrelabel",
        "body": [
            "// O(VE sqrt E)",
            "",
            "template<typename flow_t = long long>",
            "struct PushRelabel {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tflow_t f, c;",
            "\t};",
            "\tvt<vt<Edge> > g;",
            "\tvt<flow_t> ec;",
            "\tvt<Edge*> cur;",
            "\tvt<vt<int> > hs;",
            "\tvt<int> h;",
            "",
            "\tvoid init(int n) {",
            "\t\tg.resize(n);",
            "\t\tec.resize(n);",
            "\t\tcur.resize(n);",
            "\t\ths.resize(2 * n);",
            "\t\th.resize(n);",
            "\t}",
            "",
            "\tvoid ae(int s, int t, flow_t cap, flow_t rcap = 0) {",
            "\t\tif (s == t) return;",
            "\t\tEdge a = {t, size(g[t]), 0, cap};",
            "\t\tEdge b = {s, size(g[s]), 0, rcap};",
            "\t\tg[s].push_back(a);",
            "\t\tg[t].push_back(b);",
            "\t}",
            "\tvoid add_flow(Edge& e, flow_t f) {",
            "\t\tEdge &back = g[e.to][e.rev];",
            "\t\tif (!ec[e.to] && f)",
            "\t\t\ths[h[e.to]].push_back(e.to);",
            "\t\te.f += f; e.c -= f;",
            "\t\tec[e.to] += f;",
            "\t\tback.f -= f; back.c += f;",
            "\t\tec[back.to] -= f;",
            "\t}",
            "\tflow_t calc(int s, int t) {",
            "\t\tint v = size(g);",
            "\t\th[s] = v;",
            "\t\tec[t] = 1;",
            "\t\tvt<int> co(2 * v);",
            "\t\tco[0] = v - 1;",
            "\t\tfor(int i=0;i<v;++i) cur[i] = g[i].data();",
            "\t\tfor(auto &e:g[s]) add_flow(e, e.c);",
            "\t\tif(size(hs[0]))",
            "\t\tfor (int hi = 0; hi>=0; ) {",
            "\t\t\tint u = hs[hi].back();",
            "\t\t\ths[hi].pop_back();",
            "\t\t\twhile (ec[u] > 0) // discharge u",
            "\t\t\t\tif (cur[u] == g[u].data() + size(g[u])) {",
            "\t\t\t\t\th[u] = 1e9;",
            "\t\t\t\t\tfor(auto &e : g[u])",
            "\t\t\t\t\t\tif (e.c && h[u] > h[e.to] + 1)",
            "\t\t\t\t\t\t\th[u] = h[e.to] + 1, cur[u] = &e;",
            "\t\t\t\t\tif (++co[h[u]], !--co[hi] && hi < v)",
            "\t\t\t\t\t\tfor (int i=0; i<v; ++i)",
            "\t\t\t\t\t\t\tif (hi < h[i] && h[i] < v){",
            "\t\t\t\t\t\t\t\t--co[h[i]];",
            "\t\t\t\t\t\t\t\th[i] = v + 1;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\thi = h[u];",
            "\t\t\t\t} else if (cur[u]->c && h[u] == h[cur[u]->to] + 1)",
            "\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));",
            "\t\t\t\telse ++cur[u];",
            "\t\t\twhile (hi>=0 && hs[hi].empty()) --hi;",
            "\t\t}",
            "\t\treturn -ec[s];",
            "\t}",
            "\tbool leftOfMinCut(int a) { return h[a] >= sz(g); }",
            "};"
        ]
    },
    "mcmf": {
        "prefix": "mcmf",
        "body": [
            "struct MCMF {",
            "\tstruct edge {",
            "\t\tint from, to, rev;",
            "\t\tll cap, cost, flow;",
            "\t};",
            "\tint N;",
            "\tvt<vt<edge>> ed;",
            "\tvt<int> seen;",
            "\tvt<ll> dist, pi;",
            "\tvt<edge*> par;",
            "",
            "\tMCMF(int N) : N(N), ed(N), seen(N), dist(N), pi(N), par(N) {}",
            "",
            "\tvoid ae(int from, int to, ll cap, ll cost) {",
            "\t\tif (from == to) return;",
            "\t\ted[from].push_back(edge{ from, to, size(ed[to]), cap,cost,  0 });",
            "\t\ted[to].push_back(edge{ to,  from, size(ed[from]) - 1,  0, -cost, 0 });",
            "\t}",
            "",
            "\tvoid path(int s) {",
            "\t\tfill(all(seen), 0);",
            "\t\tfill(all(dist), INF);",
            "\t\tdist[s] = 0; ll di;",
            "",
            "\t\t__gnu_pbds::priority_queue<pair<ll, int>> q;",
            "\t\tvt<decltype(q)::point_iterator> its(N);",
            "\t\tq.push({ 0, s });",
            "",
            "\t\twhile (!q.empty()) {",
            "\t\t\ts = q.top().second; q.pop();",
            "\t\t\tseen[s] = 1; di = dist[s] + pi[s];",
            "\t\t\tfor (edge& e : ed[s]) if (!seen[e.to]) {",
            "\t\t\t\tll val = di - pi[e.to] + e.cost;",
            "\t\t\t\tif (e.cap - e.flow > 0 && val < dist[e.to]) {",
            "\t\t\t\t\tdist[e.to] = val;",
            "\t\t\t\t\tpar[e.to] = &e;",
            "\t\t\t\t\tif (its[e.to] == q.end())",
            "\t\t\t\t\t\tits[e.to] = q.push({ -dist[e.to], e.to });",
            "\t\t\t\t\telse",
            "\t\t\t\t\t\tq.modify(its[e.to], { -dist[e.to], e.to });",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tFOR (i, N) pi[i] = min(pi[i] + dist[i], INF);",
            "\t}",
            "",
            "\tpair<ll, ll> maxflow(int s, int t) {",
            "\t\tll totflow = 0, totcost = 0;",
            "\t\twhile (path(s), seen[t]) {",
            "\t\t\tll fl = INF;",
            "\t\t\tfor (edge* x = par[t]; x; x = par[x->from])",
            "\t\t\t\tfl = min(fl, x->cap - x->flow);",
            "",
            "\t\t\ttotflow += fl;",
            "\t\t\tfor (edge* x = par[t]; x; x = par[x->from]) {",
            "\t\t\t\tx->flow += fl;",
            "\t\t\t\ted[x->to][x->rev].flow -= fl;",
            "\t\t\t}",
            "\t\t}",
            "\t\tFOR (i, N) for(edge& e : ed[i]) totcost += e.cost * e.flow;",
            "\t\treturn {totflow, totcost/2};",
            "\t}",
            "",
            "\t// If some costs can be negative, call this before maxflow:",
            "\tvoid setpi(int s) { // (otherwise, leave this out)",
            "\t\tfill(all(pi), INF); pi[s] = 0;",
            "\t\tint it = N, ch = 1; ll v;",
            "\t\twhile (ch-- && it--)",
            "\t\t\tFOR (i, N) if (pi[i] != INF)",
            "\t\t\t\tfor (edge& e : ed[i]) if (e.cap)",
            "\t\t\t\t\tif ((v = pi[i] + e.cost) < pi[e.to])",
            "\t\t\t\t\t\tpi[e.to] = v, ch = 1;",
            "\t\tassert(it >= 0); // negative cost cycle",
            "\t}",
            "};"
        ]
    },
    "kuhns": {
        "prefix": "kuhns",
        "body": [
            "int a, b; // # of nodes on left/right side respectively",
            "vt<vt<int>> adj;",
            "// add directed edges from lhs to rhs",
            " ",
            "vt<int> matched;",
            "vt<bool> seen;",
            " ",
            "int dfs(int cur) {",
            "\tif (seen[cur]) return false; ",
            "\tseen[cur] = true;",
            "\tfor (int nxt : adj[cur]){",
            "\t\tif (matched[nxt] == -1 || dfs(matched[nxt])) {",
            "\t\t\tmatched[nxt] = cur;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "\treturn false;",
            "}",
            " ",
            "int solve() {",
            "\tint flow = 0;",
            "\tmatched.assign(b, -1);",
            "\tFOR (i, a){",
            "\t\tseen.assign(a, false);",
            "\t\tflow += dfs(i);",
            "\t}",
            "\treturn flow;",
            "}"
        ]
    },
    "randmatching": {
        "prefix": "randmatching",
        "body": [
            "random_device rd;",
            "mt19937 rng(rd());",
            "",
            "struct MCM {",
            "\tint n, t = 0;",
            "\tvt<vt<int>> adj;",
            "\tvt<int> mate, last_seen;",
            "",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t\tmate.resize(n + 1, n);",
            "\t\tlast_seen.resize(n + 1);",
            "\t}",
            "",
            "\tint dfs(int u) {",
            "\t\tlast_seen[u] = t;",
            "\t\tshuffle(all(adj[u]), rng);",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tint m = mate[v];",
            "\t\t\tif (last_seen[m] != t) {",
            "\t\t\t\tmate[u] = v, mate[v] = u, mate[m] = n;",
            "\t\t\t\tif (m == n || dfs(m)) return 1;",
            "\t\t\t\tmate[v] = m, mate[m] = v, mate[u] = n;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tif (u == v) return;",
            "\t\tadj[u].push_back(v);",
            "\t\tadj[v].push_back(u);",
            "\t}",
            "",
            "\tconst int MAGIC = 1; // make bigger if wa",
            "\tvt<pi> calc() {",
            "\t\tFOR (bad, MAGIC) {",
            "\t\t\tint found = 0;",
            "\t\t\tFOR (u, n) if (mate[u] == n) t++, found |= dfs(u);",
            "\t\t\tif (found) bad = 0;",
            "\t\t}",
            "\t\tvt<pi> out;",
            "\t\tFOR (i, n) {",
            "\t\t\tif (mate[i] < i) out.pb({mate[i], i});",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "};"
        ]
    },
    "2sat": {
        "prefix": "2sat",
        "body": [
            "struct SCC {",
            "\tll n; ",
            "\tvt<vt<ll>> adj, radj;",
            "\tvt<ll> todo, comp, comps; ",
            "\tvt<bool> seen;",
            "\tvoid init(ll _n) { ",
            "\t\tn = _n; ",
            "\t\tadj.resize(n);",
            "\t\tradj.resize(n);",
            "\t\tcomp = vt<ll>(n, -1);",
            "\t\tseen.resize(n); ",
            "\t}",
            "\tvoid ae(ll x, ll y) { adj[x].pb(y), radj[y].pb(x); }",
            "\tvoid dfs(ll x) {",
            "\t\tseen[x] = 1; ",
            "\t\tfor(ll y : adj[x]) if (!seen[y]) dfs(y);",
            "\t\ttodo.pb(x); ",
            "\t}",
            "\tvoid dfs2(ll x, ll v) {",
            "\t\tcomp[x] = v; ",
            "\t\tfor (ll y : radj[x]) if (comp[y] == -1) dfs2(y, v); ",
            "\t}",
            "\tvoid gen() {",
            "\t\tFOR (i, n) if (!seen[i]) dfs(i);",
            "\t\treverse(all(todo)); ",
            "\t\tfor (ll x : todo) if (comp[x] == -1) dfs2(x, x), comps.pb(x);",
            "\t}",
            "};",
            "",
            "using pi = pair<int, int>;",
            "",
            "struct TwoSAT {",
            "\tint n = 0; ",
            "\tvt<pi> edges;",
            "\tvoid init(int _n) { n = _n; }",
            "\tint add() { return n++; }",
            "\tvoid either(int x, int y) { // x | y",
            "\t\tx = max(2 * x, -1 - 2 * x); // ~(2 * x)",
            "\t\ty = max(2 * y, -1 - 2 * y); // ~(2 * y)",
            "\t\tedges.pb({x, y}); ",
            "\t}",
            "\tvoid implies(int x, int y) { either(~x, y); } // x -> y",
            "\tvoid force(int x) { either(x, x); } // x = true",
            "\tvoid exactly_one(int x, int y) { either(x, y), either(~x, ~y); } // xor",
            "\tvoid tie(int x, int y) { implies(x, y), implies(~x, ~y); } // x and y have the same value",
            "\tvoid nand(int x, int y ) { either(~x, ~y); } // x and y are not both true",
            "\tvoid at_most_one(const vt<int>& li) { // at most one of li is true",
            "\t\tif (size(li) <= 1) return;",
            "\t\tint cur = ~li[0];",
            "\t\tFOR (i, 2, size(li)) {",
            "\t\t\tint next = add();",
            "\t\t\teither(cur, ~li[i]); ",
            "\t\t\teither(cur,next);",
            "\t\t\teither(~li[i], next); ",
            "\t\t\tcur = ~next;",
            "\t\t}",
            "\t\teither(cur, ~li[1]);",
            "\t}",
            "\tvt<bool> solve() {",
            "\t\tSCC scc; ",
            "\t\tscc.init(2 * n);",
            "\t\tfor(auto& e : edges) {",
            "\t\t\tscc.ae(e.f ^ 1, e.s);",
            "\t\t\tscc.ae(e.s ^ 1, e.f);",
            "\t\t}",
            "\t\tscc.gen(); ",
            "\t\treverse(all(scc.comps)); // reverse topo order",
            "\t\tfor (int i = 0; i < 2 * n; i += 2) ",
            "\t\t\tif (scc.comp[i] == scc.comp[i ^ 1]) return {};",
            "\t\tvt<int> tmp(2 * n); ",
            "\t\tfor (auto i : scc.comps) {",
            "\t\t\tif (!tmp[i]) tmp[i] = 1, tmp[scc.comp[i ^ 1]] = -1;",
            "\t\t}",
            "\t\tvt<bool> ans(n); ",
            "\t\tFOR (i, n) ans[i] = tmp[scc.comp[2 * i]] == 1;",
            "\t\treturn ans;",
            "\t}",
            "};"
        ]
    },
    "bellmanford": {
        "prefix": "bellmanford",
        "body": [
            "struct BellmanFord {",
            "\tint n;",
            "\tvt<pair<pl, int>> edges;",
            "\tvt<ll> dist;",
            "\tvoid ae(int u, int v, int w) { ",
            "\t\tedges.pb({{u, v}, w}); ",
            "\t}",
            "\t// returns if there is a negative cycle",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tn = _n; ",
            "\t\tdist.resize(n, INF);",
            "\t}",
            "\tbool gen(int s = 0) {",
            "\t\tdist[s] = 0;",
            "\t\tFOR (i, n) {",
            "\t\t\tfor (auto& a : edges) {",
            "\t\t\t\tif (dist[a.f.f] < INF) {",
            "\t\t\t\t\tdist[a.f.s] = min(dist[a.f.s], dist[a.f.f] + a.s);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (auto& a : edges) {",
            "\t\t\tif (dist[a.f.f] < INF && dist[a.f.s] > dist[a.f.f] + a.s) {",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "};"
        ]
    },
    "floydwarshall": {
        "prefix": "floydwarshall",
        "body": [
            "FOR (k, n) FOR (i, n) FOR (j, n) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);"
        ]
    },
    "floydwarshallsafe": {
        "prefix": "floydwarshallsafe",
        "body": [
            "void apsp(vt<vt<ll>> &m) {",
            "\tint n = size(m);",
            "\tFOR (i, n) m[i][i] = min(m[i][i], 0ll);",
            "\tFOR (k, n) FOR(i, n) FOR(j, n)",
            "\t\tif (m[i][k] != INF && m[k][j] != INF) {",
            "\t\t\tauto newDist = max(m[i][k] + m[k][j], -INF);",
            "\t\t\tm[i][j] = min(m[i][j], newDist);",
            "\t\t}",
            "\tFOR (k, n) if (m[k][k] < 0) FOR (i, n) FOR(j, n)",
            "\t\tif (m[i][k] != INF && m[k][j] != INF) m[i][j] = -INF;",
            "}"
        ]
    },
    "topsort": {
        "prefix": "topsort",
        "body": [
            "int n;",
            "vt<bool> seen;",
            "vt<int> top;",
            "",
            "void dfs(int u) {",
            "\tif (seen[u]) return;",
            "\tseen[u] = true;",
            "\tfor (int v : adj[u]) dfs(v);",
            "\ttop.pb(u);",
            "}",
            "",
            "void topsort() {",
            "\tseen.assign(n, 0);",
            "\tFOR (u, n) dfs(u);",
            "\treverse(all(top)); // reverse to make edges point to the right",
            "}"
        ]
    },
    "topsort": {
        "prefix": "topsort",
        "body": [
            "ll solve(int n, vt<vt<ll>>& cost) {",
            "\tvt<vt<ll>> dp(1 << n, vt<ll>(n, INF));",
            "",
            "\t// initialise starting states",
            "\tFOR (i, n) {",
            "\t\tdp[1 << i][i] = 0;",
            "\t}",
            "",
            "\t// iterative dp",
            "\tFOR (i, 1 << n) {",
            "\t\tFOR (j, n) {",
            "\t\t\tif (dp[i][j] == INF) continue; // skip infinity",
            "\t\t\tFOR (k, n) {",
            "\t\t\t\tif (i & (1 << k)) continue; // skip things already in bitmask",
            "\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + cost[j][k]); // push dp values",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// find minimum of all complete walks",
            "\tll ans = INF;",
            "\tFOR (i, n) {",
            "\t\tans = min(ans, dp[(1 << n) - 1][i]);",
            "\t}",
            "}"
        ]
    },
    "fft": {
        "prefix": "fft",
        "body": [
            "const ll mod = (119 << 23) + 1, root = 62; // = 998244353",
            "// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
            "// and 483 << 21 (same root). The last two are > 10^9.",
            "",
            "ll modpow(ll b, ll e) {",
            "\tll ans = 1;",
            "\tfor (; e; b = b * b % mod, e /= 2)",
            "\t\tif (e & 1) ans = ans * b % mod;",
            "\treturn ans;",
            "}",
            "",
            "void ntt(vt<ll> &a) {",
            "\tint n = size(a), L = 31 - __builtin_clz(n);",
            "\tstatic vt<ll> rt(2, 1);",
            "\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {",
            "\t\trt.resize(n);",
            "\t\tll z[] = {1, modpow(root, mod >> s)};",
            "\t\tFOR (i, k, 2 * k) rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "\t}",
            "\tvt<int> rev(n);",
            "\tFOR (i, 0, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\tFOR (i, 0, n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) FOR (j, 0, k) {",
            "\t\t\tll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "\t\t\tai += (ai + z >= mod ? z - mod : z);",
            "\t\t}",
            "}",
            "vt<ll> conv(const vt<ll> &a, const vt<ll> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tint s = (int) size(a) + size(b) - 1, B = 32 - __builtin_clz(s),",
            "\t\tn = 1 << B;",
            "\tint inv = modpow(n, mod - 2);",
            "\tvt<ll> L(a), R(b), out(n);",
            "\tL.resize(n), R.resize(n);",
            "\tntt(L), ntt(R);",
            "\tFOR (i, 0, n) out[-i & (n - 1)] = (ll)L[i] * R[i] % mod * inv % mod;",
            "\tntt(out);",
            "\treturn {out.begin(), out.begin() + s};",
            "}"
        ]
    },
    "math": {
        "prefix": "math",
        "body": [
            "const ll MOD = 1e9 + 7;",
            "",
            "ll power(ll x, ll y) { // make y unsigned long long if large numbers",
            "\tll res = 1;",
            "\tx %= MOD;",
            "\twhile (y) {",
            "\t\tif (y & 1) res = (res * x) % MOD;",
            "\t\ty /= 2;",
            "\t\tx = (x * x) % MOD;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "// just use __gcd if available",
            "ll gcd(ll a, ll b){",
            "\t\tif (!a) return b;",
            "\t  return gcd(b % a, a);",
            "}",
            "",
            "// finds two integers x and y, such that ax + by = gcd(a, b)",
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a / b * x, d;",
            "}"
        ]
    },
    "matrix": {
        "prefix": "matrix",
        "body": [
            "const ll MOD = 1e9 + 7;",
            "using Mat = vt<vt<ll>>;",
            "",
            "Mat makeMat(int r, int c) { return Mat(r, vt<ll>(c)); }",
            "Mat makeId(int n) { ",
            "\tMat m = makeMat(n, n); FOR(i, n) m[i][i] = 1;",
            "\treturn m;",
            "}",
            "Mat operator*(const Mat& a, const Mat& b) {",
            "\tint x = size(a), y = size(a[0]), z = size(b[0]); ",
            "\tMat c = makeMat(x, z);",
            "\tFOR(i, x) FOR(j, y) FOR(k, z) c[i][k] = (c[i][k] + a[i][j] * b[j][k]) % MOD;",
            "\treturn c;",
            "}",
            "Mat& operator*=(Mat& a, const Mat& b) { return a = a * b; }",
            "Mat pow(Mat m, ll p) {",
            "\tint n = size(m); assert(n == size(m[0]) && p >= 0);",
            "\tMat res = makeId(n);",
            "\tfor (; p; p /= 2, m *= m) if (p & 1) res *= m;",
            "\treturn res;",
            "}"
        ]
    },
    "centroiddecomp": {
        "prefix": "centroiddecomp",
        "body": [
            "int n;",
            "vt<vt<ll>> adj;",
            "vt<bool> done;",
            "vt<vt<pl>> pars;",
            "vt<int> sz;",
            "",
            "int dfs_sz(int u, int p = -1) {",
            "\tsz[u] = 1;",
            "\tfor (int v : adj[u]) {",
            "\t\t\t\tif (v == p || done[v]) continue;",
            "\t\tsz[u] += dfs_sz(v, u);",
            "\t}",
            "\treturn sz[u];",
            "}",
            "",
            "int find_centroid(int u, int tsz, int p = -1) {",
            "\tfor (int v : adj[u]) {",
            "\t\tif (v == p || done[v]) continue;",
            "\t\tif (sz[v] * 2 > tsz) return find_centroid(v, tsz, u);",
            "\t}",
            "\treturn u;",
            "}",
            "",
            "// calculates {centroid, distance} pairs for each node",
            "void process(int u, int r, int d, int par = -1) {",
            "\tpars[u].pb({r, d});",
            "\tfor (int v : adj[u]) {",
            "\t\tif (v != par && !done[v]) process(v, r, d + 1, u);",
            "\t}",
            "}",
            "",
            "void decomp(int u = 0) {",
            "\tu = find_centroid(u, dfs_sz(u)); // keep in mind subtree sizes are not correct after this",
            "\t// do stuff",
            "\tprocess(u, u, 0);",
            "\t// end stuff",
            "\tdone[u] = true;",
            "\tfor (int v : adj[u]) {",
            "\t\tif (!done[v]) decomp(v);",
            "\t}",
            "}"
        ]
    },
    "lazyhld": {
        "prefix": "lazyhld",
        "body": [
            "struct Lazy {",
            "\tll v;",
            "\tbool inc;",
            "\tvoid operator+=(const Lazy &b) {",
            "\t\tif (b.inc) v += b.v;",
            "\t\telse v = b.v, inc = false;",
            "\t}",
            "};",
            " ",
            "struct Node {",
            "\tll mx, sum;",
            "\tNode operator+(const Node &b) {",
            "\t\treturn {max(mx, b.mx), sum + b.sum};",
            "\t}",
            "\tvoid upd(const Lazy &u, int l, int r) {",
            "\t\tif (!u.inc) mx = sum = 0;",
            "\t\tmx += u.v, sum += u.v * (r - l + 1);",
            "\t}",
            "};",
            "",
            "const Node NID = {-INF, 0};",
            "const Lazy LID = {0, true};",
            "const int sz = 1 << 17;",
            "",
            "struct LazySeg {",
            "\tvt<Node> seg;",
            "\tvt<Lazy> lazy;",
            "\tvoid init() {",
            "\t\tseg.resize(2 * sz, NID);",
            "\t\tlazy.resize(2 * sz, LID);",
            "\t}",
            "\tvoid pull(int i) {",
            "\t\tseg[i] = seg[2 * i] + seg[2 * i + 1];",
            "\t}",
            "\tvoid push(int i, int l, int r) {",
            "\t\tseg[i].upd(lazy[i], l, r);",
            "\t\tif (l != r)  FOR (j, 2) lazy[2 * i + j] += lazy[i];",
            "\t\tlazy[i] = LID;",
            "\t}",
            "\tvoid build() {",
            "\t\tfor (int i = sz - 1; i > 0; i--) pull(i);",
            "\t}",
            "\tvoid upd(int lo, int hi, Lazy val, int i = 1, int l = 0, int r = sz - 1) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r < lo || l > hi) return;",
            "\t\tif (lo <= l && r <= hi) {",
            "\t\t\tlazy[i] += val;",
            "\t\t\tpush(i, l, r);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tupd(lo, hi, val, 2 * i, l, m);",
            "\t\tupd(lo, hi, val, 2 * i + 1, m + 1, r);",
            "\t\tpull(i);",
            "\t}",
            "\tNode query(int lo = 0, int hi = sz - 1, int i = 1, int l = 0, int r = sz - 1) {",
            "\t\tpush(i, l, r);",
            "\t\tif (r < lo || l > hi) return NID;",
            "\t\tif (lo <= l && r <= hi) return seg[i];",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m + 1, r);",
            "\t}",
            "\tNode& operator[](int i) {",
            "\t\treturn seg[i + sz];",
            "\t}",
            "};",
            "",
            "template<bool in_edges> struct HLD {",
            "\tvt<int> adj[sz];",
            "\tint par[sz], root[sz], depth[sz], size[sz], pos[sz], time;",
            "\tvt<int> rpos;",
            "\tLazySeg tree;",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "\tvoid dfs_sz(int u) {",
            "\t\tsize[u] = 1;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\tpar[v] = u;",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs_sz(v);",
            "\t\t\tsize[u] += size[v];",
            "\t\t\tif (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfs_hld(int u) {",
            "\t\tpos[u] = time++;",
            "\t\trpos.pb(u);",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\troot[v] = (v == adj[u][0] ? root[u] : v);",
            "\t\t\tdfs_hld(v);",
            "\t\t}",
            "\t}",
            "\tvoid init(int r = 0) {",
            "\t\tpar[r] = depth[r] = time = 0;",
            "\t\tdfs_sz(r);",
            "\t\troot[r] = r;",
            "\t\tdfs_hld(r);",
            "\t\ttree.init();",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "",
            "\ttemplate <class Op>",
            "\tvoid process(int u, int v, Op op) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\top(pos[root[v]], pos[v]);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + in_edges, pos[v]);",
            "\t}",
            "\tvoid modify(int u, int v, Lazy upd) {",
            "\t\tprocess(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });",
            "\t}",
            "\tNode query(int u, int v) {",
            "\t\tNode res = NID;",
            "\t\tprocess(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });",
            "\t\treturn res;",
            "\t}",
            "\tvoid modify_subtree(int u, Lazy upd) {",
            "\t\ttree.upd(pos[u] + in_edges, pos[u] + size[u] - 1, upd);",
            "\t}",
            "\tNode query_subtree(int u) {",
            "\t\treturn tree.query(pos[u] + in_edges, pos[u] + size[u] - 1);",
            "\t}",
            "};"
        ]
    },
    "hld": {
        "prefix": "hld",
        "body": [
            "struct SegTree {",
            "\tint n;",
            "\tvt<int> seg;",
            "\tvoid init(int _n) {",
            "\t\tfor (n = 1; n < _n; n *= 2);",
            "\t\tseg.resize(2 * n);",
            "\t}",
            "\tint query(int i, int balls) {",
            "\t\tint sum = 0;",
            "\t\tfor (i += n; i > 0; i /= 2) sum += seg[i];",
            "\t\treturn sum;",
            "\t}",
            "\tvoid upd(int l, int r, int v) {",
            "\t\tfor (l += n, r += n + 1; l < r; l /= 2, r /= 2) {",
            "\t\t\tif (l & 1) seg[l++] += v;",
            "\t\t\tif (r & 1) seg[--r] += v;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "template<bool in_edges> struct HLD {",
            "\tint sz;",
            "\tvt<vt<int>> adj;",
            "\tvt<int> par, root, depth, size, pos;",
            "\tint time;",
            "\tSegTree tree;",
            "",
            "\tvoid ae(int u, int v) {",
            "\t\tadj[u].pb(v);",
            "\t\tadj[v].pb(u);",
            "\t}",
            "\tvoid dfs_sz(int u) {",
            "\t\tsize[u] = 1;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\tpar[v] = u;",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs_sz(v);",
            "\t\t\tsize[u] += size[v];",
            "\t\t\tif (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfs_hld(int u) {",
            "\t\tpos[u] = time++;",
            "\t\tfor (int& v : adj[u]) {",
            "\t\t\troot[v] = (v == adj[u][0] ? root[u] : v);",
            "\t\t\tdfs_hld(v);",
            "\t\t}",
            "\t}",
            "\tvoid init(int _sz) {",
            "\t\tsz = _sz;",
            "\t\tadj.resize(sz);",
            "\t\tpar = root = depth = size = pos = vt<int>(sz);",
            "\t}",
            "\tvoid gen(int r = 0) {",
            "\t\tpar[r] = depth[r] = time = 0;",
            "\t\tdfs_sz(r);",
            "\t\troot[r] = r;",
            "\t\tdfs_hld(r);",
            "\t\ttree.init(sz);",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "",
            "\ttemplate <class Op>",
            "\tvoid process(int u, int v, Op op) {",
            "\t\twhile (root[u] != root[v]) {",
            "\t\t\tif (depth[root[u]] > depth[root[v]]) swap(u, v);",
            "\t\t\top(pos[root[v]], pos[v]);",
            "\t\t\tv = par[root[v]];",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + in_edges, pos[v]);",
            "\t}",
            "\tvoid modify(int u, int v, ll upd) {",
            "\t\tprocess(u, v, [&] (int l, int r) { tree.upd(l, r, upd); });",
            "\t}",
            "\tll query(int u, int v) {",
            "\t\tll res = 0;",
            "\t\tprocess(u, v, [&] (int l, int r) { res = res + tree.query(l, r); });",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "liftlca": {
        "prefix": "liftlca",
        "body": [
            "struct BinaryLifting {",
            "\tint n, r; ",
            "\tvt<vt<int>> adj; ",
            "\tvt<int> par, jmp, depth;",
            "\tvoid init(int _n) {  ",
            "\t\tn = _n;",
            "\t\tadj.resize(n);",
            "\t\tpar = jmp = depth = vt<int>(n);",
            "\t}",
            "\tvoid ae(int u, int v, ll w = 1) { adj[u].pb(v), adj[v].pb(u); }",
            "\tvoid gen(int _r = 0) { r = _r, par[r] = jmp[r] = r; dfs(r); }",
            "\tvoid dfs(int u = 0) {",
            "\t\tfor (int v : adj[u]) {",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tpar[v] = u;",
            "\t\t\tif (depth[jmp[jmp[u]]] + depth[u] == 2 * depth[jmp[u]]) jmp[v] = jmp[jmp[u]];",
            "\t\t\telse jmp[v] = u;",
            "\t\t\tadj[v].erase(find(all(adj[v]), u));",
            "\t\t\tdfs(v);",
            "\t\t}",
            "\t}",
            "\tint lift(int u, int d) {",
            "\t\tif (d == 0) return r;",
            "\t\twhile (depth[par[u]] >= d) {",
            "\t\t\tif (depth[jmp[u]] >= d) u = jmp[u];",
            "\t\t\telse u = par[u];",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tif (depth[u] < depth[v]) swap(u, v);",
            "\t\tu = lift(u, depth[v]); ",
            "\t\tif (u == v) return u;",
            "\t\twhile (u != v) {",
            "\t\t\tif (jmp[u] != jmp[v]) u = jmp[u], v = jmp[v];",
            "\t\t\telse u = par[u], v = par[v];",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "\tint dist(int u, int v) { // # of edges on path",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};",
            ""
        ]
    },
    "rmqlca": {
        "prefix": "rmqlca",
        "body": [
            "template<class T> struct RMQ {",
            "\tvt<vt<T>> dp;",
            "\tvoid init(const vt<T>& v) {",
            "\t\tdp.resize(32 - __builtin_clz(size(v)), vt<T>(size(v)));",
            "\t\tcopy(all(v), begin(dp[0]));",
            "\t\tfor (int j = 1; 1 << j <= size(v); ++j) {",
            "\t\t\tFOR (i, size(v) - (1 << j) + 1) dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l + 1);",
            "\t\treturn min(dp[d][l], dp[d][r - (1 << d) + 1]); ",
            "\t}",
            "};",
            "",
            "struct LCA {",
            "\tint n; ",
            "\tvt<vt<int>> adj;",
            "\tvt<int> depth, pos, par; // rev is for compress",
            "\tvt<pl> tmp; ",
            "\tRMQ<pl> r;",
            "\tvoid init(int _n) { ",
            "\t\tn = _n; ",
            "\t\tadj.resize(n); ",
            "\t\tdepth = pos = par = vt<int>(n); ",
            "\t}",
            "\tvoid ae(int x, int y) { ",
            "\t\tadj[x].pb(y), adj[y].pb(x); ",
            "\t}",
            "\tvoid dfs(int x) {",
            "\t\tpos[x] = size(tmp); ",
            "\t\ttmp.pb({depth[x], x}); ",
            "\t\tfor(int y : adj[x]) ",
            "\t\t\tif (y != par[x]) {",
            "\t\t\t\tdepth[y] = depth[par[y] = x] + 1, dfs(y);",
            "\t\t\t\ttmp.pb({depth[x], x}); ",
            "\t\t\t}",
            "\t}",
            "\tvoid gen(int R = 0) { ",
            "\t\tpar[R] = R; ",
            "\t\tdfs(R); r.init(tmp); ",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tu = pos[u], v = pos[v]; ",
            "\t\tif (u > v) swap(u,v);",
            "\t\treturn r.query(u,v).s;",
            "\t}",
            "\tint dist(int u, int v) {",
            "\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)]; ",
            "\t}",
            "};"
        ]
    },
    "virtualtree": {
        "prefix": "virtualtree",
        "body": [
            "// pos is dfs time",
            "vt<pl> virtual_tree(vt<ll>& nodes) { // pairs of {ancestor, child}",
            "\tauto cmp = [&] (ll u, ll v) { return pos[u] < pos[v]; };",
            "\tsort(all(nodes), cmp);",
            "\tint sz = size(nodes);",
            "\tFOR (i, sz - 1) nodes.pb(lca(nodes[i], nodes[i + 1]));",
            "\tsort(all(nodes), cmp);",
            "\tnodes.erase(unique(all(nodes)), nodes.end());",
            "\tvt<pl> res;",
            "\tFOR (i, (int) size(nodes) - 1) res.pb({lca(nodes[i], nodes[i + 1]), nodes[i + 1]});",
            "\treturn res;",
            "}"
        ]
    },
    "bit": {
        "prefix": "bit",
        "body": [
            "struct BIT {",
            "\tint n; vt<ll> arr;",
            "\tvoid init(int _n) {",
            "\t\tn = _n;",
            "\t\tarr.resize(n);",
            "\t}",
            "\t// 1-indexed",
            "\tll sum(int r) {",
            "\t\tll s = 0;",
            "\t\twhile (r) {",
            "\t\t\ts += arr[r - 1];",
            "\t\t\tr -= r & -r;",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "\t// public",
            "\tvoid add(int p, ll x) {",
            "\t\tfor (++p; p <= n; p += p & -p) arr[p - 1] += x;",
            "\t}",
            "\tll sum(int l, int r) { // inc exc",
            "\t\treturn sum(r) - sum(l);",
            "\t}",
            "\t\t// optional",
            "\tint lower_bound(ll sum) {",
            "\t\tif (sum <= 0) return -1;",
            "\t\tint pos = 0;",
            "\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {",
            "\t\t\tint npos = pos + pw;",
            "\t\t\tif (npos <= n && arr[npos - 1] < sum)",
            "\t\t\t\tpos = npos, sum -= arr[pos - 1];",
            "\t\t}",
            "\t\treturn pos;",
            "\t}",
            "};"
        ]
    },
}
