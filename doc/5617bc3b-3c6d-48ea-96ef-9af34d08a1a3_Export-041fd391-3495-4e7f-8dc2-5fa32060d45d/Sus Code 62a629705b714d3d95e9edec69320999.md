---
print_background: true
---

# Sus Code

# Range Queries

### Sparse Segtree

```cpp
using ptr = struct Node*;
const int sz = 1 << 30;
struct Node {
    #define func(a, b) min(a, b)
    #define ID INF
    ll val;
    ptr lc, rc;

    ptr get(ptr& p) { return p ? p : p = new Node {ID}; }

    ll query(int lo, int hi, int l = 0, int r = sz) {
        if (lo >= r || hi <= l) return ID;
        if (lo <= l && r <= hi) return val;
        int m = (l + r) / 2;
        return func(get(lc)->query(lo, hi, l, m), 
		        get(rc)->query(lo, hi, m, r));
    }

    ll upd(int i, ll nval, int l = 0, int r = sz) {
        if (r - l == 1) return val = nval;
        int m = (l + r) / 2;
        if (i < m) get(lc)->upd(i, nval, l, m);
        else get(rc)->upd(i, nval, m, r);
        return val = func(get(lc)->val, get(rc)->val);
    }
    #undef ID
    #undef func
};
```

### Lazy Segtree

```cpp
struct Lazy {
    ll v;
    bool inc;
    void operator+=(const Lazy &b) {
        if (b.inc) v += b.v;
        else v = b.v, inc = false;
    }
};
 
struct Node {
    ll mx, sum;
    Node operator+(const Node &b) {
        return {max(mx, b.mx), sum + b.sum};
    }
    void upd(const Lazy &u, int l, int r) {
        if (!u.inc) mx = sum = 0;
        mx += u.v, sum += u.v * (r - l);
    }
};

const Lazy LID = {0, true};
const Node NID = {-INF, 0};
 
struct LazySeg { 
    int n;
    vt<Node> seg;
    vt<Lazy> lazy;
    void init(int _n) {
        for (n = 1; n < _n; n *= 2);
        seg.resize(2 * n, NID);
        lazy.resize(2 * n, LID);
    }
    void pull(int i) {
        seg[i] = seg[2 * i] + seg[2 * i + 1];
    }
    void push(int i, int l, int r) {
        seg[i].upd(lazy[i], l, r);
        if (r - l > 1) FOR (j, 2) lazy[2 * i + j] += lazy[i];
        lazy[i] = LID;
    }
    void build() {
        for (int i = n - 1; i > 0; i--) pull(i);
    }
    void upd(int lo, int hi, Lazy val) { upd(lo, hi, val, 1, 0, n); }
    void upd(int lo, int hi, Lazy val, int i, int l, int r) {
        if (r == -1) r = n;
        push(i, l, r);
        if (r <= lo || l >= hi) return;
        if (lo <= l && r <= hi) {
            lazy[i] += val;
            push(i, l, r);
            return;
        }
        int m = (l + r) / 2;
        upd(lo, hi, val, 2 * i, l, m);
        upd(lo, hi, val, 2 * i + 1, m, r);
        pull(i);
    }
    Node query() { return query(0, n, 1, 0, n); }
    Node query(int lo, int hi) { return query(lo, hi, 1, 0, n); }
    Node query(int lo, int hi, int i, int l, int r) {
        push(i, l, r);
        if (r <= lo || l >= hi) return NID;
        if (lo <= l && r <= hi) return seg[i];
        int m = (l + r) / 2;
        return query(lo, hi, 2 * i, l, m) 
            + query(lo, hi, 2 * i + 1, m, r);
    }
    Node& operator[](int i) {
        return seg[i + n];
    }
};
```

### Sparse Lazy Segtree

```cpp
struct Lazy {
    int v;
    bool inc;

    void operator+=(const Lazy& oth) {
        if (!oth.inc) v = 0, inc = 0;
        v += oth.v;
    }
};

struct Val {
    ll sum;
    int mx;

    Val operator+(const Val& oth) const {
        return {sum + oth.sum, max(mx, oth.mx)};
    }

    void upd(Lazy& lazy, ll l, ll r) {
        if (!lazy.inc) sum = mx = 0;
        sum += lazy.v * (r - l);
        mx += lazy.v;
    }
};

const Lazy lid = {0, 1};
const Val vid = {0, -inf};

using ptr = struct Node*;
const int sz = 1 << 30;
struct Node {
    Val val;
    Lazy lazy;
    ptr lc, rc;

    ptr get(ptr& p) { return p ? p : p = new Node {vid, lid}; }

    void push(ll l, ll r) {
        val.upd(lazy, l, r);
        if (r - l > 1) {
            get(lc)->lazy += lazy; 
            get(rc)->lazy += lazy;
        }
        lazy = lid;
    }

    Val query(ll lo, ll hi, ll l = 0, ll r = sz) {
        push(l, r);
        if (lo >= r || hi <= l) return vid;
        if (lo <= l && r <= hi) return val;
        ll m = (l + r) / 2;
        return get(lc)->query(lo, hi, l, m) 
            + get(rc)->query(lo, hi, m, r);
    }

    void upd(ll lo, ll hi, Lazy v, ll l = 0, ll r = sz) {
        push(l, r);
        if (lo >= r || hi <= l) return;
        if (lo <= l && r <= hi) {
            lazy += v;
            push(l, r);
            return;
        }
        ll m = (l + r) / 2;
        get(lc)->upd(lo, hi, v, l, m);
        get(rc)->upd(lo, hi, v, m, r);
        val = get(lc)->val + get(rc)->val;
    }
};
```

### Persistent Segtree

```cpp
using ptr = struct Node*;
const int sz = 1 << 18;
 
struct Node {
    #define func(a, b) min(a, b)
    #define ID inf
    int v;
    ptr lc, rc;
 
    ptr pull(ptr lc, ptr rc) {
        return new Node {func(lc->v, rc->v), lc, rc};
    }
 
    ptr upd(int i, int nv, int l = 0, int r = sz) {
        if (r - l == 1) return new Node {nv};
        int m = (l + r) / 2;
        if (i < m) return pull(lc->upd(i, nv, l, m), rc);
        else return pull(lc, rc->upd(i, nv, m, r));
    }
 
    int query(int lo, int hi, int l = 0, int r = sz) {
        if (lo >= r || hi <= l) return ID;
        if (lo <= l && r <= hi) return v;
        int m = (l + r) / 2;
        return func(lc->query(lo, hi, l, m), 
            rc->query(lo, hi, m, r)); 
    }
    #undef id
    #undef func
};
```

### K-th Smallest

```cpp
using ptr = struct Node*;
const ll sz = 1 << 30;
 
struct Node {
    int cnt;
    ptr lc, rc;
 
    ptr pull(ptr lc, ptr rc) {
        return new Node {lc->cnt + rc->cnt, lc, rc};
    }
 
    ptr upd(int i, int l = 0, int r = sz) {
        if (r - l == 1) return new Node {cnt + 1};
        int m = (l + r) / 2;
        if (i < m) return pull(lc->upd(i, l, m), rc);
        else return pull(lc, rc->upd(i, m, r));
    }
};

int walk(ptr lo, ptr hi, int k, int l = 0, int r = sz) {
    if (r - l == 1) return l;
    int m = (l + r) / 2;
    int lhs = hi->lc->cnt - lo->lc->cnt;
    if (lhs >= k) return walk(lo->lc, hi->lc, k, l, m);
    else return walk(lo->rc, hi->rc, k - lhs, m, r);
}
```

### Sparse Table

```cpp
template<class T> struct RMQ {
    #define func min
    vector<vector<T>> dp;
    void init(const vector<T>& v) {
        dp.resize(32 - __builtin_clz(size(v)), vector<T>(size(v)));
        copy(v.begin(), v.end(), begin(dp[0]));
        for (int j = 1; 1 << j <= size(v); ++j) {
            for (int i = 0; i < size(v) - (1 << j) + 1; i++) 
                dp[j][i] = func(dp[j - 1][i], 
                    dp[j - 1][i + (1 << (j - 1))]);
        }
    }
    T query(int l, int r) {
        int d = 31 - __builtin_clz(r - l);
        return func(dp[d][l], dp[d][r - (1 << d)]); 
    }
    #undef func
};
```

### Static Range Query

```cpp
template<class T> struct RangeQuery {
    #define comb(a, b) (a) + (b)
    #define id 0
    int lg, n;
    vt<vt<T>> stor;
    vt<T> a;
    void fill(int l, int r, int ind) {
        if (ind < 0) return;
        int m = (l + r) / 2;
        T prod = id; 
        FOR (i, m, r) stor[i][ind] = prod = comb(prod, a[i]);
        prod = id; 
        ROF (i, l, m) stor[i][ind] = prod = comb(a[i], prod);
        fill(l, m, ind - 1); 
        fill(m, r, ind - 1);
    }
    template <typename It>
    void build(It l, It r) {
        lg = 1;
        while ((1 << lg) < r - l) lg++;
        n = 1 << lg;
        a.resize(n, id);
        for (It i = l; i != r; i++) a[i - l] = *i;
        stor.resize(n, vt<T>(32 - __builtin_clz(n)));
        fill(0, n, lg - 1);
    }
    T query(int l, int r) {
        if (l == r) return a[l];
        int t = 31 - __builtin_clz(r ^ l);
        return comb(stor[l][t], stor[r][t]);
    }
    #undef id
    #undef comb
};
```

### Fenwick Tree

```cpp
struct BIT {
    int n; vt<ll> arr;
    void init(int _n) {
        n = _n;
        arr.resize(n);
    }
    // 1-indexed
    ll sum(int r) {
        ll s = 0;
        while (r) {
            s += arr[r - 1];
            r -= r & -r;
        }
        return s;
    }
    // public
    void add(int p, ll x) {
        for (++p; p <= n; p += p & -p) arr[p - 1] += x;
    }
    ll sum(int l, int r) { // inc exc
        return sum(r) - sum(l);
    }
        // optional
    int lower_bound(ll sum) {
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1 << 25; pw; pw >>= 1) {
            int npos = pos + pw;
            if (npos <= n && arr[npos - 1] < sum)
                pos = npos, sum -= arr[pos - 1];
        }
        return pos;
    }
};
```

# Data Structures

### Li Chao Tree

```cpp
struct Line {
    ll m, c;
    ll operator()(ll x) {
        return m * x + c;
    }
};

const ll sz = 1ll << 30;

using ptr = struct Node*;
struct Node {
    ptr lc, rc;
    Line line;

    Node(Line _line) {
        line = _line;
        lc = rc = 0;
    }
};

// min tree (flip signs for max)
void add(ptr& n, Line loser, ll l = 0, ll r = sz) {
    if (n ? 0 : n = new Node(loser)) return;
    ll m = (l + r) / 2;
    if (loser(m) < n->line(m)) swap(loser, n->line);
    if (r - l == 1) return;
    if (loser(l) < n->line(l)) add(n->lc, loser, l, m);
    else add(n->rc, loser, m, r);
}

ll query(ptr n, ll x, ll l = 0, ll r = sz) {
    if (!n) return sz;
    ll m = (l + r) / 2;
    if (x < m) return min(n->line(x), query(n->lc, x, l, m));
    else return min(n->line(x), query(n->rc, x, m, r));
}
```


# Tree

### HLD

```cpp
template<bool in_edges> struct HLD {
    int n;
    vt<vt<int>> adj;
    vt<int> par, root, depth, size, pos;
    int time;
    SegTree tree;
    void ae(int u, int v) {
        adj[u].pb(v);
        adj[v].pb(u);
    }
    void dfs_sz(int u) {
        size[u] = 1;
        for (int& v : adj[u]) {
            par[v] = u;
            depth[v] = depth[u] + 1;
            adj[v].erase(find(all(adj[v]), u));
            dfs_sz(v);
            size[u] += size[v];
            if (size[v] > size[adj[u][0]]) swap(v, adj[u][0]);
        }
    }
    void dfs_hld(int u) {
        pos[u] = time++;
        for (int& v : adj[u]) {
            root[v] = (v == adj[u][0] ? root[u] : v);
            dfs_hld(v);
        }
    }
    void init(int _n) {
        n = _n;
        adj.resize(n);
        par = root = depth = size = pos = vt<int>(n);
    }
    void gen(int r = 0) {
        par[r] = depth[r] = time = 0;
        dfs_sz(r);
        root[r] = r;
        dfs_hld(r);
        tree.init(n);
    }
    int lca(int u, int v) {
        while (root[u] != root[v]) {
            if (depth[root[u]] > depth[root[v]]) swap(u, v);
            v = par[root[v]];
        }
        return depth[u] < depth[v] ? u : v;
    }
    template <class Op>
    void process(int u, int v, Op op) {
        while (root[u] != root[v]) {
            if (depth[root[u]] > depth[root[v]]) swap(u, v);
            op(pos[root[v]], pos[v] + 1);
            v = par[root[v]];
        }
        if (depth[u] > depth[v]) swap(u, v);
        op(pos[u] + in_edges, pos[v] + 1);
    }
    void upd(int u, int v, ll upd) {
        process(u, v, [&] (int l, int r) { 
            tree.upd(l, r, upd); 
        });
    }
    ll query(int u, int v) {
        ll res = 0;
        process(u, v, [&] (int l, int r) { 
            res = res + tree.query(l, r); 
        });
        return res;
    }
};
```

### Virtual Tree

```cpp
// pos is dfs time
// pairs of {ancestor, child}
vt<pl> virtual_tree(vt<ll>& nodes) { 
    auto cmp = [&] (ll u, ll v) { return pos[u] < pos[v]; };
    sort(all(nodes), cmp);
    int sz = size(nodes);
    FOR (i, sz - 1) nodes.pb(lca(nodes[i], nodes[i + 1]));
    sort(all(nodes), cmp);
    nodes.erase(unique(all(nodes)), nodes.end());
    vt<pl> res;
    FOR (i, (int) size(nodes) - 1) 
    res.pb({lca(nodes[i], nodes[i + 1]), nodes[i + 1]});
    return res;
}
```

# Graph

### Strongly Connected Components

```cpp
struct SCC {
    int n; 
    vt<vt<int>> adj, radj;
    vt<int> todo, seen, comp, comps; // comps is top sorted
    void init(int _n) { 
        n = _n; 
        adj = radj = vt<vt<int>>(n);
        comp.resize(n, -1);
        seen.resize(n); 
    }
    void ae(int u, int v) { 
        adj[u].pb(v); 
        radj[v].pb(u); 
    }
    void dfs(int u) {
        if (seen[u]++) return;
        for (int v : adj[u]) dfs(v); 
        todo.pb(u);
    }
    void rdfs(int u, int w) {
        comp[u] = w;
        for (int v : radj[u]) if (comp[v] == -1) rdfs(v, w); 
    }
    void gen() {
        FOR (i, n) dfs(i);
        reverse(all(todo));
        for (int u : todo) if (comp[u] == -1) 
            rdfs(u, u), comps.pb(u);
    }
};
```

### Biconnected Components

```cpp
// for bridges, you can turn edge i = (u, v)
// into edges (u, i + n) (i + n, v)
struct BCC { 
    int n, t; 
    vt<vt<int>> adj;
    vt<vt<int>> comps;
    vt<int> tin, low, stk;
 
    void init(int _n) {
        n = _n;
        adj.resize(n);
    }
 
    void ae(int u, int v) {
        adj[u].pb(v);
        adj[v].pb(u);
    }
 
    void dfs(int u) {
        tin[u] = low[u] = ++t;
        stk.pb(u);   
        for (int v : adj[u]) {
            if (tin[v]) low[u] = min(low[u], tin[v]);
            else {
                int i = size(stk);
                dfs(v);
                low[u] = min(low[u], low[v]);
                if (low[v] == tin[u]) {
                    // u is an articulation point
                    stk.pb(u);
                    comps.pb({i + all(stk)});
                    stk.resize(i);
                }
            }
        }
    }
 
    void gen() {
        t = 0;
        tin = low = vt<int>(n);
        FOR (u, n) if (!tin[u]) dfs(u); 
        FOR (u, n) if (adj[u].empty()) comps.pb({u});   
    }
};
```

### Block Cut Tree

```cpp
/*

to build block cut tree:
	  run bcc
	  put all the normal nodes on the left
	  make a new node for each bcc on the right
	  connect normal nodes to components that contain them
	  if its a forest, add {-1, -1} between dfs calls 
	  in rmq lc

	  the component an edge belongs to is the parent
	  of the deeper endpoint
	
*/
```

### Floyd-Warshall

```cpp
// for validated input (no neg cycles, etc, m[i][i] = 0)
void apsp(vt<vt<ll>>& m) {
    FOR (k, n) FOR (i, n) FOR (j, n) 
        m[i][j] = min(m[i][j], m[i][k] + m[k][j]);
}
```

### Bellman-Ford

```cpp
struct BellmanFord {
    int n;
    vt<pair<pl, int>> edges;
    vt<ll> dist;
    void ae(int u, int v, int w) { 
        edges.pb({{u, v}, w}); 
    }
    // returns if there is a negative cycle
    void init(int _n) {
        n = _n;
        n = _n; 
        dist.resize(n, INF);
    }
    bool gen(int s = 0) {
        dist[s] = 0;
        FOR (i, n) {
            for (auto& a : edges) {
                if (dist[a.f.f] < INF) {
                    dist[a.f.s] = min(dist[a.f.s], 
                        dist[a.f.f] + a.s);
                }
            }
        }
        for (auto& a : edges) {
            if (dist[a.f.f] < INF && dist[a.f.s] 
                > dist[a.f.f] + a.s) {
                return true;
            }
        }
        return false;
    }
};
```

### Euler Tour

```cpp
int n, m;
vector<vector<pair<int, int>>> adj;
vector<int> ret, used;

// for edges, print the edge u came from instead of current node
void dfs(int u) {
    while (adj[u].size()) {
        auto [v, ei] = adj[u].back();
        adj[u].pop_back();
        if (used[ei]++) continue;
        dfs(v);
    }
    ret.push_back(u);
}
```

# Math

### Matrix

```cpp
using mat = vt<vt<ll>>;

mat make_mat(int r, int c) { return mat(r, vt<ll>(c)); }
mat make_id(int n) { 
    mat m = make_mat(n, n); FOR(i, n) m[i][i] = 1;
    return m;
}
mat operator*(const mat& a, const mat& b) {
    int x = size(a), y = size(a[0]), z = size(b[0]); 
    mat c = make_mat(x, z);
    FOR(i, x) FOR(j, y) FOR(k, z) 
        c[i][k] = (c[i][k] + a[i][j] * b[j][k]) % mod;
    return c;
}
mat& operator*=(mat& a, const mat& b) { return a = a * b; }
mat pow(mat m, ll p) {
    int n = size(m); assert(n == size(m[0]) && p >= 0);
    mat res = make_id(n);
    for (; p; p /= 2, m *= m) if (p & 1) res *= m;
    return res;
}
```

### Euclid

```cpp
// finds two integers x and y, such that ax + by = gcd(a, b)
ll euclid(ll a, ll b, ll &x, ll &y) {
	if (!b) return x = 1, y = 0, a;
	ll d = euclid(b, a % b, y, x);
	return y -= a / b * x, d;
}
```

### Chinese Remainder Theorem

```cpp
ll crt(ll a, ll m, ll b, ll n) {
    if (n > m) swap(a, b), swap(m, n);
    ll x, y, g = euclid(m, n, x, y);
    assert((a - b) % g == 0); // else no solution
    x = (b - a) % n * x % n / g * m + a;
    return x < 0 ? x + m * n / g : x;
}
```

### Pollard’s Rho

```cpp
using ul = unsigned long long;

ul mod_mul(ul a, ul b, const ul mod) {
	ll ret = a * b - mod * (ul) ((db) a * b / mod);
	return ret + ((ret < 0) - (ret >= (ll) mod)) * mod; 
}
ul mod_pow(ul a, ul b, const ul mod) {
	if (b == 0) return 1;
	ul res = mod_pow(a, b / 2, mod); 
    res = mod_mul(res, res, mod);
	return b & 1 ? mod_mul(res, a,mod) : res;
}
 
bool prime(ul n) { // not ll!
	if (n < 2 || n % 6 % 4 != 1) return n - 2 < 2;
	ul A[] = {2, 325, 9375, 28178, 
		450775, 9780504, 1795265022};
	ul s = __builtin_ctzll(n - 1), d = n >> s;
	for (auto a : A) {   // ^ count trailing zeroes
		ul p = mod_pow(a, d, n), i = s;
		while (p != 1 && p != n - 1 && a % n && i--) 
			p = mod_mul(p, p, n);
		if (p != n - 1 && i != s) return 0;
	}
	return 1;
}
 
ul pollard(ul n) { // return some nontrivial factor of n
    if (n % 2 == 0) return 2;
	auto f = [n](ul x) { return mod_mul(x, x, n) + 1; };
	ul x = 0, y = 0, t = 30, prd = 2, i = 1, q;
	// speedup: don't take gcd every it
	while (t++ % 40 || gcd(prd, n) == 1) {
		if (x == y) x = ++i, y = f(x);
		if ((q = mod_mul(prd, max(x,y) - min(x, y), n))) 
			prd = q;
		x = f(x), y = f(f(y));
	}
	return gcd(prd, n);
}

void factor_rec(ul n, map<ul, int>& cnt) {
	if (n == 1) return;
	if (prime(n)) { ++cnt[n]; return; }
	ul u = pollard(n);
	factor_rec(u, cnt), factor_rec(n / u,cnt);
}
```

### Sieve

```cpp
struct Sieve {
    vi lp, primes;
    void calc(int n) {
        lp.rsz(n);
		FOR (i, 2, n) { 
			if (lp[i] == 0) lp[i] = i, primes.pb(i); 
			for (int p : primes) {
				if (p > lp[i] || i * p >= n) break;
				lp[i * p] = p;
			}
		}
    }
    void get_prime_fact(int x, vpi& out) {
        if (x == 1) return;
        if (out.empty() || out.back().f != lp[x]) 
            out.eb(x, 1);
        else out.back().s++;
    }
};
```

### XOR Basis

```cpp
ll reduce(vl& b, ll x) { 
    each(t, b) chmin(x, x ^ t);
	return x; 
}

bool add(vl& b, ll x) {
	if (!(x = reduce(b, x))) return 0;
	int ind = 0; 
    while (ind < size(b) && b[ind] > x) ind++;
	b.insert(begin(b) + ind, x); 
    return 1;
}
```

# Convolutions

### Number Theoretic Transform

```cpp
const ll mod = (119 << 23) + 1, root = 62; // = 998244353
// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21
// and 483 << 21 (same root). The last two are > 10^9.

ll modpow(ll b, ll e) {
	ll ans = 1;
	for (; e; b = b * b % mod, e /= 2)
		if (e & 1) ans = ans * b % mod;
	return ans;
}

void ntt(vt<ll> &a) {
	int n = size(a), L = 31 - __builtin_clz(n);
	static vt<ll> rt(2, 1);
	for (static int k = 2, s = 2; k < n; k *= 2, s++) {
		rt.resize(n);
		ll z[] = {1, modpow(root, mod >> s)};
		FOR (i, k, 2 * k) rt[i] = rt[i / 2] * z[i & 1] % mod;
	}
	vt<int> rev(n);
	FOR (i, 0, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
	FOR (i, 0, n) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int k = 1; k < n; k *= 2)
		for (int i = 0; i < n; i += 2 * k) FOR (j, 0, k) {
			ll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];
			a[i + j + k] = ai - z + (z > ai ? mod : 0);
			ai += (ai + z >= mod ? z - mod : z);
		}
}
vt<ll> conv(const vt<ll> &a, const vt<ll> &b) {
	if (a.empty() || b.empty()) return {};
	int s = (int) size(a) + size(b) - 1, 
		B = 32 - __builtin_clz(s), n = 1 << B;
	int inv = modpow(n, mod - 2);
	vt<ll> L(a), R(b), out(n);
	L.resize(n), R.resize(n);
	ntt(L), ntt(R);
	FOR (i, 0, n) out[-i & (n - 1)] 
		= (ll) L[i] * R[i] % mod * inv % mod;
	ntt(out);
	return {out.begin(), out.begin() + s};
}
```

### Fast Fourier Transform

```cpp
// remember to add 0.5 before casting to int dumbass
typedef complex<double> C;
typedef vector<double> vd;
void fft(vector<C>& a) {
    int n = size(a), L = 31 - __builtin_clz(n);
    static vector<complex<long double>> R(2, 1);
    static vector<C> rt(2, 1);  // (^ 10% faster if double) ??
    for (static int k = 2; k < n; k *= 2) {
        R.resize(n); 
        rt.resize(n);
        auto x = polar(1.0L, acos(-1.0L) / k);
        FOR (i, k, 2 * k) 
            rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];
    }
    vi rev(n);
    FOR (i, n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
    FOR (i, n) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int k = 1; k < n; k *= 2)
        for (int i = 0; i < n; i += 2 * k) FOR (j, 0, k) {
            auto x = (double *) &rt[j + k], 
                y = (double *) &a[i + j + k];
            C z(x[0] * y[0] - x[1] * y[1], 
                x[0] * y[1] + x[1] * y[0]);
            a[i + j + k] = a[i + j] - z;
            a[i + j] += z;
        }
}

vd conv(const vd& a, const vd& b) {
    if (a.empty() || b.empty()) return {};
    vd res(size(a) + size(b) - 1);
    int L = 32 - __builtin_clz(size(res)), n = 1 << L;
    vector<C> in(n), out(n);
    copy(all(a), begin(in));
    FOR (i, size(b)) in[i].imag(b[i]);
    fft(in);
    for (C &x : in) x *= x;
    FOR (i, n) out[i] = in[-i & (n - 1)] - conj(in[i]);
    fft(out);
    FOR (i, size(res)) res[i] = imag(out[i]) / (4 * n);
    return res;
}

// inputs [0, mod)
// N log_2(N) * mod < 8.6e14 (in practice 1e16+)
template<ll mod, class T> 
vt<T> convMod(const vt<T> &a, const vt<T> &b) {
    if (a.empty() || b.empty()) return {};
    vt<T> res(size(a) + size(b) - 1);
    int B = 32 - __builtin_clz(size(res)), 
        n = 1 << B, cut = int(sqrt(mod));
    vector<C> L(n), R(n), outs(n), outl(n);
    FOR (i, size(a)) 
        L[i] = C((int) a[i] / cut, (int) a[i] % cut);
    FOR (i, size(b)) 
        R[i] = C((int) b[i] / cut, (int) b[i] % cut);
    fft(L), fft(R);
    FOR (i, n) {
        int j = -i & (n - 1);
        outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);
        outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;
    }
    fft(outl), fft(outs);
    FOR (i, size(res)) {
        ll av = ll(real(outl[i]) + 0.5), 
            cv = ll(imag(outs[i]) + 0.5);
        ll bv = ll(imag(outl[i]) + 0.5) 
            + ll(real(outs[i]) + 0.5);
        res[i] = ((av % mod * cut + bv) % mod * cut + cv) % mod;
    }
    return res;
}
```

# Flows/Matching

### Hungarian Algorithm

```cpp
// n^2 m
// negate costs for max
// returns {min_cost, match[]}
pair<int, vi> hungarian(const vector<vi> &a) {
    if (a.empty()) return {0, {}};
    int n = size(a) + 1, m = size(a[0]) + 1;
    vi u(n), v(m), p(m), ans(n - 1);
    FOR (i, 1, n) {
        p[0] = i;
        int j0 = 0; // add "dummy" worker 0
        vi dist(m, INT_MAX), pre(m, -1);
        vector<bool> done(m + 1);
        do { // dijkstra
            done[j0] = true;
            int i0 = p[j0], j1, delta = INT_MAX;
            FOR (j, 1, m) if (!done[j]) {
                auto cur = a[i0 - 1][j - 1] - u[i0] - v[j];
                if (cur < dist[j]) dist[j] = cur, pre[j] = j0;
                if (dist[j] < delta) delta = dist[j], j1 = j;
            }
            FOR (j, m) {
                if (done[j]) u[p[j]] += delta, v[j] -= delta;
                else dist[j] -= delta;
            }
            j0 = j1;
        } while (p[j0]);
        while (j0) { // update alternating path
            int j1 = pre[j0];
            p[j0] = p[j1], j0 = j1;
        }
    }
    FOR (j, 1, m) if (p[j]) ans[p[j] - 1] = j - 1;
    return {-v[0], ans}; // min cost
}
```

### Min Cost Max Flow

```cpp
// O(FE logV)
// O(VE) for setpi
struct MCMF {
    struct edge {
        int from, to, rev;
        ll cap, cost, flow;
    };
    int N;
    vt<vt<edge>> ed;
    vt<int> seen;
    vt<ll> dist, pi;
    vt<edge*> par;

    MCMF(int N) : N(N), ed(N), seen(N), dist(N), pi(N), par(N) {}

    void ae(int from, int to, ll cap, ll cost) {
        if (from == to) return;
        ed[from].push_back(edge{ from, to, size(ed[to]), 
            cap,cost,  0 });
        ed[to].push_back(edge{ to,  from, size(ed[from]) - 1,  
            0, -cost, 0 });
    }

    void path(int s) {
        fill(all(seen), 0);
        fill(all(dist), INF);
        dist[s] = 0; ll di;

        __gnu_pbds::priority_queue<pair<ll, int>> q;
        vt<decltype(q)::point_iterator> its(N);
        q.push({ 0, s });

        while (!q.empty()) {
            s = q.top().second; q.pop();
            seen[s] = 1; di = dist[s] + pi[s];
            for (edge& e : ed[s]) if (!seen[e.to]) {
                ll val = di - pi[e.to] + e.cost;
                if (e.cap - e.flow > 0 && val < dist[e.to]) {
                    dist[e.to] = val;
                    par[e.to] = &e;
                    if (its[e.to] == q.end())
                        its[e.to] = q.push({ -dist[e.to], e.to });
                    else
                        q.modify(its[e.to], { -dist[e.to], e.to });
                }
            }
        }
        FOR (i, N) pi[i] = min(pi[i] + dist[i], INF);
    }

    pair<ll, ll> maxflow(int s, int t) {
        ll totflow = 0, totcost = 0;
        while (path(s), seen[t]) {
            ll fl = INF;
            for (edge* x = par[t]; x; x = par[x->from])
                fl = min(fl, x->cap - x->flow);

            totflow += fl;
            for (edge* x = par[t]; x; x = par[x->from]) {
                x->flow += fl;
                ed[x->to][x->rev].flow -= fl;
            }
        }
        FOR (i, N) for(edge& e : ed[i]) totcost += e.cost * e.flow;
        return {totflow, totcost/2};
    }

    // If some costs can be negative, call this before maxflow:
    void setpi(int s) { // (otherwise, leave this out)
        fill(all(pi), INF); pi[s] = 0;
        int it = N, ch = 1; ll v;
        while (ch-- && it--)
            FOR (i, N) if (pi[i] != INF)
                for (edge& e : ed[i]) if (e.cap)
                    if ((v = pi[i] + e.cost) < pi[e.to])
                        pi[e.to] = v, ch = 1;
        assert(it >= 0); // negative cost cycle
    }
};
```

### Push-Relabel

```cpp
// O(VE sqrt E)
template<typename flow_t = long long>
struct PushRelabel {
    struct Edge {
        int to, rev;
        flow_t f, c;
    };
    vt<vt<Edge> > g;
    vt<flow_t> ec;
    vt<Edge*> cur;
    vt<vt<int> > hs;
    vt<int> h;

    void init(int n) {
        g.resize(n);
        ec.resize(n);
        cur.resize(n);
        hs.resize(2 * n);
        h.resize(n);
    }

    void ae(int s, int t, flow_t cap, flow_t rcap = 0) {
        if (s == t) return;
        Edge a = {t, size(g[t]), 0, cap};
        Edge b = {s, size(g[s]), 0, rcap};
        g[s].push_back(a);
        g[t].push_back(b);
    }
    void add_flow(Edge& e, flow_t f) {
        Edge &back = g[e.to][e.rev];
        if (!ec[e.to] && f)
            hs[h[e.to]].push_back(e.to);
        e.f += f; e.c -= f;
        ec[e.to] += f;
        back.f -= f; back.c += f;
        ec[back.to] -= f;
    }
    flow_t calc(int s, int t) {
        int v = size(g);
        h[s] = v;
        ec[t] = 1;
        vt<int> co(2 * v);
        co[0] = v - 1;
        for(int i=0;i<v;++i) cur[i] = g[i].data();
        for(auto &e:g[s]) add_flow(e, e.c);
        if(size(hs[0]))
        for (int hi = 0; hi>=0; ) {
            int u = hs[hi].back();
            hs[hi].pop_back();
            while (ec[u] > 0) // discharge u
                if (cur[u] == g[u].data() + size(g[u])) {
                    h[u] = 1e9;
                    for(auto &e : g[u])
                        if (e.c && h[u] > h[e.to] + 1)
                            h[u] = h[e.to] + 1, cur[u] = &e;
                    if (++co[h[u]], !--co[hi] && hi < v)
                        for (int i=0; i<v; ++i)
                            if (hi < h[i] && h[i] < v){
                                --co[h[i]];
                                h[i] = v + 1;
                            }
                    hi = h[u];
                } else if (cur[u]->c && h[u] == h[cur[u]->to] + 1)
                    add_flow(*cur[u], min(ec[u], cur[u]->c));
                else ++cur[u];
            while (hi>=0 && hs[hi].empty()) --hi;
        }
        return -ec[s];
    }
    bool leftOfMinCut(int a) { return h[a] >= sz(g); }
};
```

### Dinic’s

```cpp
// O(VE log U)
// U is the max capacity of any edge
struct Dinic {
    struct Edge {
        int to, rev;
        ll c, oc;
        ll flow() { return max(oc - c, 0LL); } // if you need flows
    };
    vt<int> lvl, ptr, q;
    vt<vt<Edge>> adj;

    void init(int n) {
        lvl = ptr = q = vt<int>(n);
        adj.resize(n);
    }

    void ae(int a, int b, ll c, ll rcap = 0) {
        adj[a].push_back({b, size(adj[b]), c, c});
        adj[b].push_back({a, size(adj[a]) - 1, rcap, rcap});
    }
    ll dfs(int v, int t, ll f) {
        if (v == t || !f) return f;
        for (int& i = ptr[v]; i < size(adj[v]); i++) {
            Edge& e = adj[v][i];
            if (lvl[e.to] == lvl[v] + 1)
                if (ll p = dfs(e.to, t, min(f, e.c))) {
                    e.c -= p, adj[e.to][e.rev].c += p;
                    return p;
                }
        }
        return 0;
    }
    ll calc(int s, int t) {
        ll flow = 0; q[0] = s;
        FOR (L, 0, 31) do { 
            lvl = ptr = vt<int>(size(q));
            int qi = 0, qe = lvl[s] = 1;
            while (qi < qe && !lvl[t]) {
                int v = q[qi++];
                for (Edge e : adj[v])
                    if (!lvl[e.to] && e.c >> (30 - L))
                        q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;
            }
            while (ll p = dfs(s, t, LLONG_MAX)) flow += p;
        } while (lvl[t]);
        return flow;
    }
    bool leftOfMinCut(int a) { return lvl[a] != 0; }
};
```

### 2-SAT

```cpp
struct TwoSAT {
    int n = 0; 
    vt<pi> edges;
    void init(int _n) { n = _n; }
    int add() { return n++; }
    void either(int x, int y) { // x | y
        x = max(2 * x, -1 - 2 * x); // ~(2 * x)
        y = max(2 * y, -1 - 2 * y); // ~(2 * y)
        edges.pb({x, y}); 
    }
    // x -> y
    void implies(int x, int y) { either(~x, y); } 
    void force(int x) { either(x, x); } // x = true
    // xor
    void exactly_one(int x, int y) { 
        either(x, y), either(~x, ~y); 
    }
    // x and y have the same value
    void tie(int x, int y) { 
        implies(x, y), implies(~x, ~y); 
    } 
    // x and y are not both true
    void nand(int x, int y ) { either(~x, ~y); } 
    // at most one of li is true
    void at_most_one(const vt<int>& li) { 
        if (size(li) <= 1) return;
        int cur = ~li[0];
        FOR (i, 2, size(li)) {
            int next = add();
            either(cur, ~li[i]); 
            either(cur,next);
            either(~li[i], next); 
            cur = ~next;
        }
        either(cur, ~li[1]);
    }
    vt<bool> solve() {
        SCC scc; 
        scc.init(2 * n);
        for(auto& e : edges) {
            scc.ae(e.f ^ 1, e.s);
            scc.ae(e.s ^ 1, e.f);
        }
        scc.gen(); 
        reverse(all(scc.comps)); // reverse topo order
        for (int i = 0; i < 2 * n; i += 2) 
            if (scc.comp[i] == scc.comp[i ^ 1]) return {};
        vt<int> tmp(2 * n); 
        for (auto i : scc.comps) {
            if (!tmp[i]) tmp[i] = 1, tmp[scc.comp[i ^ 1]] = -1;
        }
        vt<bool> ans(n); 
        FOR (i, n) ans[i] = tmp[scc.comp[2 * i]] == 1;
        return ans;
    }
};
```

# String

### KMP

```cpp
vt<int> pref(const string& s) {
	vt<int> p(size(s));
	FOR (i, 1, size(s)) {
		int g = p[i-1];
		while (g && s[i] != s[g]) g = p[g - 1];
		p[i] = g + (s[i] == s[g]);
	}
	return p;
}

vt<int> match(const string& s, const string& pat) {
	vt<int> p = pref(pat + '\0' + s), res;
	FOR (i, size(p) - size(s), size(p))
		if (p[i] == size(pat)) res.pb(i - 2 * size(pat));
	return res;
}
```

### Hashing

```cpp
// skip the stuff that starts with r 
// if you dont care about reverse functions
struct H {
    ull x; H(ull x = 0) : x(x) {}
    H operator+(H o) { return x + o.x + (x + o.x < x); }
    H operator-(H o) { return *this + ~o.x; }
    H operator*(H o) { auto m = (__uint128_t) x * o.x;
        return H((ull) m) + (ull)(m >> 64); }
    ull get() const { return x + !~x; }
    bool operator==(H o) const { return get() == o.get(); }
    bool operator<(H o) const { return get() < o.get(); }
};

static const H C = (ll) 1e11 + 3; // (order ~ 3e9; random also ok)

struct HashInterval {
    vector<H> ha, pw, rha; 
    template<class T>
    HashInterval(T& str) : ha(size(str) + 1), pw(ha), rha(ha) {
        pw[0] = 1;
        FOR (i, size(str)) {
            ha[i + 1] = ha[i] * C + str[i] + 1;
            pw[i + 1] = pw[i] * C;
        }
        ROF (i, size(str)) rha[i] = rha[i + 1] * C + str[i] + 1;
    }
    H hash_interval(int a, int b) { // hash [a, b)
        return ha[b] - ha[a] * pw[b - a];
    }
    H rhash_interval(int a, int b) { // hash [a, b) from right to left
        return rha[a] - rha[b] * pw[b - a];
    }
};

// get all hashes of length <len>
template<class T>
vector<H> get_hashes(T& str, int length) {
    if (size(str) < length) return {};
    H h = 0, pw = 1;
    FOR (i, length) h = h * C + str[i] + 1, pw = pw * C;
    vector<H> ret = {h};
    FOR (i, length, size(str)) {
        ret.push_back(h = h * C + str[i] + 1 
            - pw * (str[i - length] + 1));
    }
    return ret;
}

template<class T>
H hash_string(T& s) { 
    H h = 1; 
    for (auto c : s) h = h * C + c + 1; 
    return h; 
}
```

### Manacher’s Algorithm

```cpp
// res[0][i] = half length of longest even palindrome 
// around pos i (n + 1 elements) 
// res[1][i] = half length of longest odd palindrome 
// around index i rounded down (n elements)
template<class T>
array<vi, 2> manacher(const T& s) {
    int n = size(s);
    array<vi,2> p = {vi(n+1), vi(n)};
    FOR (z,  2) for (int i = 0, l = 0, r = 0; i < n; i++) {
        int t = r - i + !z;
        if (i < r) p[z][i] = min(t, p[z][l + t]);
        int L = i - p[z][i], R = i + p[z][i] - !z;
        while (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1])
            p[z][i]++, L--, R++;
        if (R > r) l = L, r = R;
    }
    return p;
}
```

# Geometry

### Point

```cpp
// T can be e.g. double or long long. (Avoid int.)
template <class T> int sgn(T x) { return (x > 0) - (x < 0); }
template<class T>
struct Point {
    typedef Point P;
    T x, y;
    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}
    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }
    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }
    P operator+(P p) const { return P(x + p.x, y + p.y); }
    P operator-(P p) const { return P(x - p.x, y - p.y); }
    P operator*(T d) const { return P(x * d, y * d); }
    P operator/(T d) const { return P(x / d, y / d); }
    T dot(P p) const { return x * p.x + y * p.y; }
    T cross(P p) const { return x * p.y - y * p.x; }
    T cross(P a, P b) const { return (a - *this).cross(b - *this); }
    T dist2() const { return x * x + y * y; }
    double dist() const { return sqrt((double) dist2()); }
    // angle to x-axis in interval [-pi, pi]
    double angle() const { return atan2(y, x); }
    P unit() const { return *this / dist(); } // makes dist()=1
    P perp() const { return P(-y, x); } // rotates +90 degrees
    P normal() const { return perp().unit(); }
    // returns point rotated 'a' radians ccw around the origin
    P rotate(double a) const {
        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); 
    }
    friend ostream& operator<<(ostream& os, P p) {
        return os << "(" << p.x << "," << p.y << ")"; 
    }
};
```

### On Segment

```cpp
// use seg_dist for floats
template<class P> bool on_segment(P s, P e, P p) {
    return p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;
}
```

### Point in Polygon

```cpp
template<class P>
bool in_polygon(vector<P> &p, P a, bool strict) {
    int cnt = 0, n = size(p);
    FOR (i, n) {
        P q = p[(i + 1) % n];
        if (on_segment(p[i], q, a)) return !strict;
        // if (segDist(p[i], q, a) <= eps) return !strict;
        cnt ^= ((a.y < p[i].y) - (a.y < q.y)) * a.cross(p[i], q) > 0;
    }
    return cnt;
}
```

### Segment Distance

```cpp
// for floats
double seg_dist(P& s, P& e, P& p) {
	if (s == e) return (p - s).dist();
	auto d = (e - s).dist2(), t = min(d, max(.0, (p - s).dot(e - s)));
	return ((p - s) * d - (e - s) * t).dist() / d;
}
```

### Polygon Area

```cpp
// 2x signed area
// negative for counterclockwise
template<class T>
T polygon_area(vector<Point<T>>& v) {
    T a = v.back().cross(v[0]);
    FOR (i, size(v) - 1) a += v[i].cross(v[i + 1]);
    return a;
}
```

### Line Intersection

```cpp
// 1 if intersect, 0 if not, -1 if collinear
// uses product of 3 coordinates (care overflow)
template<class P>
pair<int, P> lineInter(P s1, P e1, P s2, P e2) {
    auto d = (e1 - s1).cross(e2 - s2);
    if (d == 0) // if parallel
        return {-(s1.cross(e1, s2) == 0), P(0, 0)};
    auto p = s2.cross(e1, e2), q = s2.cross(e2, s1);
    return {1, (s1 * p + e1 * q) / d};
}
```

### Segment Intersection

```cpp
// 0 points = no inter
// 1 point = unique inter
// 2 points = line segment of solutions
// product of 3 coordinates used (care overflow)
template<class P> vector<P> seg_inter(P a, P b, P c, P d) {
    auto oa = c.cross(d, a), ob = c.cross(d, b),
         oc = a.cross(b, c), od = a.cross(b, d);
    // Checks if intersection is single non-endpoint point.
    if (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)
        return {(a * ob - b * oa) / (ob - oa)};
    set<P> s;
    if (on_segment(c, d, a)) s.insert(a);
    if (on_segment(c, d, b)) s.insert(b);
    if (on_segment(a, b, c)) s.insert(c);
    if (on_segment(a, b, d)) s.insert(d);
    return {all(s)};
}
```

### Side Of

```cpp
// returns 1/0/-1 if l/on/r when looking from s to e
// eps is the tolerance for collinearity
template<class P>
int side_of(P s, P e, P p) { return sgn(s.cross(e, p)); }

template<class P>
int side_of(const P& s, const P& e, const P& p, double eps) {
    auto a = (e - s).cross(p - s);
    double l = (e - s).dist() * eps;
    return (a > l) - (a < -l);
}
```

### In Hull

```cpp
// returns whether point is in a convex hull (ccw, no collinear pts)
using P = Point<ll>;
bool in_hull(const vector<P>& l, P p, bool strict = true) {
    int a = 1, b = size(l) - 1, r = !strict;
    if (size(l) < 3) return r && on_segment(l[0], l.back(), p);
    if (side_of(l[0], l[a], l[b]) > 0) swap(a, b);
    if (side_of(l[0], l[a], p) >= r || side_of(l[0], l[b], p) <= -r)
        return false;
    while (abs(a - b) > 1) {
        int c = (a + b) / 2;
        (side_of(l[0], l[c], p) > 0 ? b : a) = c;
    }
    return sgn(l[a].cross(l[b], p)) < r;
}
```

### Closest Pair

```cpp
// O(n \log n) closest pair of points in 2D
pair<P, P> closest(vector<P> v) {
    assert(size(v) > 1);
    set<P> S;
    sort(all(v), [](P a, P b) { return a.y < b.y; });
    pair<ll, pair<P, P>> ret{LLONG_MAX, {P(), P()}};
    int j = 0;
    for (P p : v) {
        P d{1 + (ll)sqrt(ret.first), 0};
        while (v[j].y <= p.y - d.x) S.erase(v[j++]);
        auto lo = S.lower_bound(p - d), hi = S.upper_bound(p + d);
        for (; lo != hi; ++lo)
            ret = min(ret, {(*lo - p).dist2(), {*lo, p}});
        S.insert(p);
    }
    return ret.second;
}
```

### Manhattan MST

```cpp
// returns 4n edges that are guaranteed to contain an mst
// {distance, u, v}
vector<array<int, 3>> manhattan_mst(vector<P> ps) {
	vi id(size(ps));
	iota(all(id), 0);
	vector<array<int, 3>> edges;
    FOR (k, 4) {
		sort(all(id), [&] (int i, int j) {
		     return (ps[i] - ps[j]).x < (ps[j] - ps[i]).y;} );
		map<int, int> sweep;
		for (int i : id) {
			for (auto it = sweep.lower_bound(-ps[i].y);
                    it != sweep.end(); sweep.erase(it++)) {
				int j = it->second;
				P d = ps[i] - ps[j];
				if (d.y > d.x) break;
				edges.push_back({d.y + d.x, i, j});
			}
			sweep[-ps[i].y] = i;
		}
		for (P& p : ps) if (k & 1) p.x = -p.x; else swap(p.x, p.y);
	}
	return edges;
}
```

### Convex Hull

```cpp
vt<P> convex_hull(vt<P> pts) {
    if (size(pts) <= 1) return pts;
    sort(all(pts));
    vector<P> h(size(pts)+1);
    int s = 0, t = 0;
    for (int it = 2; it--; s = --t, reverse(all(pts)))
        for (P p : pts) {
            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;
            h[t++] = p;
        }
    return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};
}
```

### Circle Tangent

```cpp
template<class P>
vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {
    P d = c2 - c1;
    double dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;
    if (d2 == 0 || h2 < 0)  return {};
    vector<pair<P, P>> out;
    for (double sign : {1, -1}) {
        P v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;
        out.push_back({c1 + v * r1, c2 + v * r2});
    }
    if (h2 == 0) out.pop_back();
    return out;
}
```

### 2D K-d Tree (untested)

```cpp
using P = array<int, 2>;
struct Node {
    #define _sq(x) (x) * (x)
    P lo, hi;
    struct Node *lc, *rc;

    ll dist2(const P &a, const P &b) const { 
        return 1ll * _sq(a[0] - b[0]) + 1ll * _sq(a[1] - b[1]); 
    }

    ll dist2(P &p) {
        //     #define _loc(i) (p[i] < lo[i] ? lo[i] : (p[i] > hi[i] ? hi[i] : p[i]))
		    //     return dist2(p, {_loc(0), _loc(1)});
        ll res = 0;
        FOR (i, 2) {
            ll tmp = (p[i] < lo[i] ? lo[i] - p[i] : 0) + (hi[i] < p[i] ? p[i] - hi[i] : 0);
            res += tmp * tmp;
        }
        return res;
    }

    template<class ptr>
    Node (ptr l, ptr r, int d) : lc(0), rc(0) {
        lo = {inf, inf}, hi = {-inf, -inf};
        for (ptr p = l; p < r; p++) {
            FOR (i, 2) lo[i] = min(lo[i], (*p)[i]), hi[i] = max(hi[i], (*p)[i]);
        }
        if (r - l == 1) return;
        ptr m = l + (r - l) / 2;
        nth_element(l, m, r, [&] (auto a, auto b) { return a[d] < b[d]; });
        lc = new Node(l, m, d ^ 1);
        rc = new Node(m, r, d ^ 1);
    }

    void search(P p, ll &best) {
        if (lc) { // rc will also exist
            ll dl = lc->dist2(p), dr = rc->dist2(p);
            if (dl > dr) swap(lc, rc), dr = dl;
            lc->search(p, best);
            if (dr < best) rc->search(p, best);
        } else best = min(best, dist2(p, lo));
    } 

    // fill pq with k infinities for nearest k points
    void search(P p, priority_queue<ll> &pq) {
        if (lc) {
            ll dl = lc->dist2(p), dr = rc->dist2(p);
            if (dl > dr) swap(lc, rc), dr = dl;
            lc->search(p, pq);
            if (dr < pq.top()) rc->search(p, pq);
        } else pq.push(dist2(p, lo)), pq.pop();
    }
};
```

### K-d Tree (arbitrary dimensions)

```cpp
template<int d, int dim>
struct Node {
    const static int ndim = (dim + 1) % d;
    using P = array<int, d>;
    P lo, hi;
    Node<d, ndim> *lc, *rc;

    ll dist2(P &a, P &b) {
        ll dist = 0;
        FOR (i, d) dist += 1ll * (a[i] - b[i]) * (a[i] - b[i]);
        return dist;
    }

    ll dist2(P &p) {
        ll res = 0;
        FOR (i, d) {
            ll tmp = (p[i] < lo[i] ? lo[i] - p[i] : 0) + (hi[i] < p[i] ? p[i] - hi[i] : 0);
            res += tmp * tmp;
        }
        return res;
    }

    Node(vt<P> pts) : lc(0), rc(0) {
        FOR (i, d) lo[i] = inf, hi[i] = -inf;
        for (auto &p : pts) {
            FOR (i, d) {
                lo[i] = min(lo[i], p[i]);
                hi[i] = max(hi[i], p[i]);
            }
        }
        int n = size(pts);
        if (n == 1) return;
        auto l = pts.begin(), m = l + n / 2, r = l + n;
        nth_element(l, m, r, [&] (auto a, auto b) { return a[dim] < b[dim]; });
        lc = new Node<d, ndim>({l, m});
        rc = new Node<d, ndim>({m, r});
    }

    void search(P p, ll &best) {
        if (lc) { // rc will also exist
            ll dl = lc->dist2(p), dr = rc->dist2(p);
            if (dl > dr) swap(lc, rc), dr = dl;
            lc->search(p, best);
            if (dr < best) rc->search(p, best);
        } else best = min(best, dist2(p, lo));
    } 

    // fill pq with k infinities for nearest k points
    void search(P p, priority_queue<ll> &pq) {
        if (lc) {
            ll dl = lc->dist2(p), dr = rc->dist2(p);
            if (dl > dr) swap(lc, rc), dr = dl;
            lc->search(p, pq);
            if (dr < pq.top()) rc->search(p, pq);
        } else pq.push(dist2(p, lo)), pq.pop();
    }
};
```

### Pick’s Theorem

$A = i + \frac b2 - 1$

$i$ = number of points in the interior

$b$ = number of points on the boundary

# Miscellaneous

### Fast Input

```cpp
inline char gc() { // like getchar()
    static char buf[1 << 16];
    static size_t bc, be;
    if (bc >= be) {
        buf[0] = 0, bc = 0;
        be = fread(buf, 1, sizeof(buf), stdin);
    }
    return buf[bc++]; // returns 0 on EOF
}

int readInt() {
    int a, c;
    while ((a = gc()) < 40);
    if (a == '-') return -readInt();
    while ((c = gc()) >= 48) a = a * 10 + c - 480;
    return a - 48;
}
```

### Bump Allocator

```cpp
// only works when you allocate one type of object
// otherwise, alignment might break
static char buf[450 << 20];
void* operator new(size_t s) {
    static size_t i = sizeof buf;
    assert(s < i);
    return (void*) &buf[i -= s];
}
void operator delete(void*) {}
```

### Small Pointer

```cpp
template<class T> struct sptr {
    unsigned ind;
    sptr(T* p = 0) : ind(p ? unsigned((char*) p - buf) : 0) {
        assert(ind < sizeof buf);
    }
    T& operator*() const { return *(T*)(buf + ind); }
    T* operator->() const { return &**this; }
    T& operator[](int a) const { return (&**this)[a]; }
    explicit operator bool() const { return ind; }
    bool operator==(const sptr<T> &oth) const { return ind == oth.ind; }
};
```